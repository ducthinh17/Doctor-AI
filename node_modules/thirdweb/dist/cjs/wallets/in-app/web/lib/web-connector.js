"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InAppWebConnector = void 0;
const domains_js_1 = require("../../../../utils/domains.js");
const index_js_1 = require("../../core/authentication/index.js");
const type_js_1 = require("../../core/authentication/type.js");
const InAppWalletIframeCommunicator_js_1 = require("../utils/iFrameCommunication/InAppWalletIframeCommunicator.js");
const index_js_2 = require("./auth/index.js");
const passkeys_js_1 = require("./auth/passkeys.js");
const in_app_account_js_1 = require("./in-app-account.js");
/**
 * @internal
 */
class InAppWebConnector {
    isClientIdLegacyPaper(clientId) {
        if (clientId.indexOf("-") > 0 && clientId.length === 36) {
            return true;
        }
        return false;
    }
    /**
     * @example
     * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: "", chain: "Goerli" });`
     * @internal
     */
    constructor({ client, onAuthSuccess }) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "querier", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "wallet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Used to manage the Auth state of the user.
         */
        Object.defineProperty(this, "auth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (this.isClientIdLegacyPaper(client.clientId)) {
            throw new Error("You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page");
        }
        const baseUrl = (0, domains_js_1.getThirdwebBaseUrl)("inAppWallet");
        this.client = client;
        this.querier = new InAppWalletIframeCommunicator_js_1.InAppWalletIframeCommunicator({
            clientId: client.clientId,
            baseUrl,
        });
        this.wallet = new in_app_account_js_1.IFrameWallet({
            client,
            querier: this.querier,
        });
        this.auth = new index_js_2.Auth({
            client,
            querier: this.querier,
            baseUrl,
            onAuthSuccess: async (authResult) => {
                onAuthSuccess?.(authResult);
                await this.wallet.postWalletSetUp({
                    ...authResult.walletDetails,
                    walletUserId: authResult.storedToken.authDetails.userWalletId,
                });
                await this.querier.call({
                    procedureName: "initIframe",
                    params: {
                        deviceShareStored: authResult.walletDetails.deviceShareStored,
                        clientId: this.client.clientId,
                        walletUserId: authResult.storedToken.authDetails.userWalletId,
                        authCookie: authResult.storedToken.cookieString,
                    },
                });
                return {
                    user: {
                        status: type_js_1.UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,
                        authDetails: authResult.storedToken.authDetails,
                        account: await this.wallet.getAccount(),
                        walletAddress: authResult.walletDetails.walletAddress,
                    },
                };
            },
        });
    }
    /**
     * Gets the usr if they are logged in
     * @example
     * ```js
     *  const user = await thirdwebInAppWallet.getUser();
     *  switch (user.status) {
     *     case UserWalletStatus.LOGGED_OUT: {
     *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user
     *       break;
     *     }
     *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {
     *       // user is logged in and wallet is all set up.
     *       // You have access to:
     *       user.status;
     *       user.authDetails;
     *       user.walletAddress;
     *       user.wallet;
     *       break;
     *     }
     * }
     * ```
     * @returns GetUser - an object to containing various information on the user statuses
     */
    async getUser() {
        return this.wallet.getUserWalletStatus();
    }
    getAccount() {
        return this.wallet.getAccount();
    }
    async preAuthenticate(args) {
        const strategy = args.strategy;
        switch (strategy) {
            case "email": {
                return this.auth.sendEmailLoginOtp({ email: args.email });
            }
            case "phone": {
                return this.auth.sendSmsLoginOtp({ phoneNumber: args.phoneNumber });
            }
            default:
                assertUnreachable(strategy, `Provider: ${strategy} doesnt require pre-authentication`);
        }
    }
    async authenticate(args) {
        const strategy = args.strategy;
        switch (strategy) {
            case "email": {
                return await this.auth.verifyEmailLoginOtp({
                    email: args.email,
                    otp: args.verificationCode,
                });
            }
            case "phone": {
                return await this.auth.verifySmsLoginOtp({
                    otp: args.verificationCode,
                    phoneNumber: args.phoneNumber,
                });
            }
            case "apple":
            case "facebook":
            case "google": {
                const oauthProvider = index_js_1.oauthStrategyToAuthProvider[strategy];
                return this.auth.loginWithOauth({
                    oauthProvider,
                    closeOpenedWindow: args.closeOpenedWindow,
                    openedWindow: args.openedWindow,
                });
            }
            case "jwt": {
                return this.auth.loginWithCustomJwt({
                    jwt: args.jwt,
                    encryptionKey: args.encryptionKey,
                });
            }
            case "auth_endpoint": {
                return this.auth.loginWithCustomAuthEndpoint({
                    payload: args.payload,
                    encryptionKey: args.encryptionKey,
                });
            }
            case "iframe_email_verification": {
                return this.auth.loginWithEmailOtp({
                    email: args.email,
                });
            }
            case "iframe": {
                return this.auth.loginWithModal();
            }
            case "passkey": {
                if (args.type === "sign-up") {
                    const authToken = await (0, passkeys_js_1.registerPasskey)({
                        client: args.client,
                        authenticatorType: args.authenticatorType,
                        username: args.passkeyName,
                    });
                    return this.auth.loginWithAuthToken(authToken);
                }
                const authToken = await (0, passkeys_js_1.loginWithPasskey)({
                    client: args.client,
                    authenticatorType: args.authenticatorType,
                });
                return this.auth.loginWithAuthToken(authToken);
            }
            default:
                assertUnreachable(strategy);
        }
    }
    async logout() {
        return await this.auth.logout();
    }
}
exports.InAppWebConnector = InAppWebConnector;
function assertUnreachable(x, message) {
    throw new Error(message ?? `Invalid param: ${x}`);
}
//# sourceMappingURL=web-connector.js.map