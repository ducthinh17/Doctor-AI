"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_storage_upload_js"],{

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/storage/upload.js":
/*!**********************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/storage/upload.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   upload: function() { return /* binding */ upload; }\n/* harmony export */ });\n/* harmony import */ var _utils_detect_platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/detect-platform.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/detect-platform.js\");\n/* harmony import */ var _utils_json_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/json.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/json.js\");\n/* harmony import */ var _upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./upload/helpers.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/storage/upload/helpers.js\");\n\n\n\n/**\n * Uploads files based on the provided options.\n * @param options - The upload options.\n * @returns A promise that resolves to the uploaded file URI or URIs (when passing multiple files).\n * @throws An error if the upload fails.\n * @example\n * ```ts\n * import { upload } from \"thirdweb/storage\";\n * const uri = await upload({\n *  client,\n *  files: [\n *    new File([\"hello world\"], \"hello.txt\"),\n *  ],\n * });\n * ```\n * @storage\n */ async function upload(options) {\n    // deal with the differnt file types\n    // if there are no files, return an empty array immediately\n    if (options.files.length === 0) {\n        return null;\n    }\n    // handle file arrays\n    const isFileArray = options.files.map((item)=>(0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isFileOrUint8Array)(item) || typeof item === \"string\").every((item)=>!!item);\n    let uris;\n    if (isFileArray) {\n        // if we already have an array of files, we can just pass it through\n        uris = options.files;\n    } else {\n        // otherwise we have to process them first\n        let cleaned = options.files;\n        // Replace any gateway URLs with their hashes\n        cleaned = (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.replaceObjectGatewayUrlsWithSchemes)(cleaned);\n        // Recurse through data and extract files to upload\n        const files = (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.extractObjectFiles)(cleaned);\n        if (files.length) {\n            // Upload all files that came from the object\n            const uris_ = await upload({\n                ...options,\n                files\n            });\n            // Recurse through data and replace files with hashes\n            cleaned = (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.replaceObjectFilesWithUris)(cleaned, // always pass an array even if the underlying upload returns a single uri\n            Array.isArray(uris_) ? uris_ : [\n                uris_\n            ]);\n        }\n        uris = cleaned.map((item)=>{\n            if (typeof item === \"string\") {\n                return item;\n            }\n            return (0,_utils_json_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(item);\n        });\n    }\n    // end deal with the differnt file types\n    const form_ = new FormData();\n    const { fileNames, form } = (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.buildFormData)(form_, uris, options);\n    const platform = (0,_utils_detect_platform_js__WEBPACK_IMPORTED_MODULE_2__.detectPlatform)();\n    if (platform === \"browser\" || platform === \"node\") {\n        const { uploadBatch } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_thirdweb_dist_esm_storage_upload_web-node_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./upload/web-node.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/storage/upload/web-node.js\"));\n        const uris = await uploadBatch(options.client, form, fileNames, options);\n        // if we only passed a single file, return its URI directly\n        if (options.files.length === 1) {\n            return uris[0];\n        }\n        return uris;\n    }\n    throw new Error(\"Please, use the uploadMobile function in mobile environments.\");\n} //# sourceMappingURL=upload.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9zdG9yYWdlL3VwbG9hZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZEO0FBQ2hCO0FBQ2lIO0FBQzlKOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ00sZUFBZU8sT0FBT0MsT0FBTztJQUNoQyxvQ0FBb0M7SUFDcEMsMkRBQTJEO0lBQzNELElBQUlBLFFBQVFDLEtBQUssQ0FBQ0MsTUFBTSxLQUFLLEdBQUc7UUFDNUIsT0FBTztJQUNYO0lBQ0EscUJBQXFCO0lBQ3JCLE1BQU1DLGNBQWNILFFBQVFDLEtBQUssQ0FDNUJHLEdBQUcsQ0FBQyxDQUFDQyxPQUFTVCxzRUFBa0JBLENBQUNTLFNBQVMsT0FBT0EsU0FBUyxVQUMxREMsS0FBSyxDQUFDLENBQUNELE9BQVMsQ0FBQyxDQUFDQTtJQUN2QixJQUFJRTtJQUNKLElBQUlKLGFBQWE7UUFDYixvRUFBb0U7UUFDcEVJLE9BQU9QLFFBQVFDLEtBQUs7SUFDeEIsT0FDSztRQUNELDBDQUEwQztRQUMxQyxJQUFJTyxVQUFVUixRQUFRQyxLQUFLO1FBQzNCLDZDQUE2QztRQUM3Q08sVUFBVVYsdUZBQW1DQSxDQUFDVTtRQUM5QyxtREFBbUQ7UUFDbkQsTUFBTVAsUUFBUU4sc0VBQWtCQSxDQUFDYTtRQUNqQyxJQUFJUCxNQUFNQyxNQUFNLEVBQUU7WUFDZCw2Q0FBNkM7WUFDN0MsTUFBTU8sUUFBUSxNQUFNVixPQUFPO2dCQUFFLEdBQUdDLE9BQU87Z0JBQUVDO1lBQU07WUFDL0MscURBQXFEO1lBQ3JETyxVQUFVWCw4RUFBMEJBLENBQUNXLFNBQ3JDLDBFQUEwRTtZQUMxRUUsTUFBTUMsT0FBTyxDQUFDRixTQUFTQSxRQUFRO2dCQUFDQTthQUFNO1FBQzFDO1FBQ0FGLE9BQU9DLFFBQVFKLEdBQUcsQ0FBQyxDQUFDQztZQUNoQixJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDMUIsT0FBT0E7WUFDWDtZQUNBLE9BQU9aLHlEQUFTQSxDQUFDWTtRQUNyQjtJQUNKO0lBQ0Esd0NBQXdDO0lBQ3hDLE1BQU1PLFFBQVEsSUFBSUM7SUFDbEIsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLElBQUksRUFBRSxHQUFHckIsaUVBQWFBLENBQUNrQixPQUFPTCxNQUFNUDtJQUN2RCxNQUFNZ0IsV0FBV3hCLHlFQUFjQTtJQUMvQixJQUFJd0IsYUFBYSxhQUFhQSxhQUFhLFFBQVE7UUFDL0MsTUFBTSxFQUFFQyxXQUFXLEVBQUUsR0FBRyxNQUFNLHdSQUE4QjtRQUM1RCxNQUFNVixPQUFPLE1BQU1VLFlBQVlqQixRQUFRa0IsTUFBTSxFQUFFSCxNQUFNRCxXQUFXZDtRQUNoRSwyREFBMkQ7UUFDM0QsSUFBSUEsUUFBUUMsS0FBSyxDQUFDQyxNQUFNLEtBQUssR0FBRztZQUM1QixPQUFPSyxJQUFJLENBQUMsRUFBRTtRQUNsQjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSxNQUFNLElBQUlZLE1BQU07QUFDcEIsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3N0b3JhZ2UvdXBsb2FkLmpzPzIwNDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGV0ZWN0UGxhdGZvcm0gfSBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0LXBsYXRmb3JtLmpzXCI7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tIFwiLi4vdXRpbHMvanNvbi5qc1wiO1xuaW1wb3J0IHsgYnVpbGRGb3JtRGF0YSwgZXh0cmFjdE9iamVjdEZpbGVzLCBpc0ZpbGVPclVpbnQ4QXJyYXksIHJlcGxhY2VPYmplY3RGaWxlc1dpdGhVcmlzLCByZXBsYWNlT2JqZWN0R2F0ZXdheVVybHNXaXRoU2NoZW1lcywgfSBmcm9tIFwiLi91cGxvYWQvaGVscGVycy5qc1wiO1xuLyoqXG4gKiBVcGxvYWRzIGZpbGVzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgdXBsb2FkIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdXBsb2FkZWQgZmlsZSBVUkkgb3IgVVJJcyAod2hlbiBwYXNzaW5nIG11bHRpcGxlIGZpbGVzKS5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHVwbG9hZCBmYWlscy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgdXBsb2FkIH0gZnJvbSBcInRoaXJkd2ViL3N0b3JhZ2VcIjtcbiAqIGNvbnN0IHVyaSA9IGF3YWl0IHVwbG9hZCh7XG4gKiAgY2xpZW50LFxuICogIGZpbGVzOiBbXG4gKiAgICBuZXcgRmlsZShbXCJoZWxsbyB3b3JsZFwiXSwgXCJoZWxsby50eHRcIiksXG4gKiAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAc3RvcmFnZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkKG9wdGlvbnMpIHtcbiAgICAvLyBkZWFsIHdpdGggdGhlIGRpZmZlcm50IGZpbGUgdHlwZXNcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gZmlsZXMsIHJldHVybiBhbiBlbXB0eSBhcnJheSBpbW1lZGlhdGVseVxuICAgIGlmIChvcHRpb25zLmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGZpbGUgYXJyYXlzXG4gICAgY29uc3QgaXNGaWxlQXJyYXkgPSBvcHRpb25zLmZpbGVzXG4gICAgICAgIC5tYXAoKGl0ZW0pID0+IGlzRmlsZU9yVWludDhBcnJheShpdGVtKSB8fCB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgLmV2ZXJ5KChpdGVtKSA9PiAhIWl0ZW0pO1xuICAgIGxldCB1cmlzO1xuICAgIGlmIChpc0ZpbGVBcnJheSkge1xuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gYXJyYXkgb2YgZmlsZXMsIHdlIGNhbiBqdXN0IHBhc3MgaXQgdGhyb3VnaFxuICAgICAgICB1cmlzID0gb3B0aW9ucy5maWxlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHByb2Nlc3MgdGhlbSBmaXJzdFxuICAgICAgICBsZXQgY2xlYW5lZCA9IG9wdGlvbnMuZmlsZXM7XG4gICAgICAgIC8vIFJlcGxhY2UgYW55IGdhdGV3YXkgVVJMcyB3aXRoIHRoZWlyIGhhc2hlc1xuICAgICAgICBjbGVhbmVkID0gcmVwbGFjZU9iamVjdEdhdGV3YXlVcmxzV2l0aFNjaGVtZXMoY2xlYW5lZCk7XG4gICAgICAgIC8vIFJlY3Vyc2UgdGhyb3VnaCBkYXRhIGFuZCBleHRyYWN0IGZpbGVzIHRvIHVwbG9hZFxuICAgICAgICBjb25zdCBmaWxlcyA9IGV4dHJhY3RPYmplY3RGaWxlcyhjbGVhbmVkKTtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVXBsb2FkIGFsbCBmaWxlcyB0aGF0IGNhbWUgZnJvbSB0aGUgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCB1cmlzXyA9IGF3YWl0IHVwbG9hZCh7IC4uLm9wdGlvbnMsIGZpbGVzIH0pO1xuICAgICAgICAgICAgLy8gUmVjdXJzZSB0aHJvdWdoIGRhdGEgYW5kIHJlcGxhY2UgZmlsZXMgd2l0aCBoYXNoZXNcbiAgICAgICAgICAgIGNsZWFuZWQgPSByZXBsYWNlT2JqZWN0RmlsZXNXaXRoVXJpcyhjbGVhbmVkLCBcbiAgICAgICAgICAgIC8vIGFsd2F5cyBwYXNzIGFuIGFycmF5IGV2ZW4gaWYgdGhlIHVuZGVybHlpbmcgdXBsb2FkIHJldHVybnMgYSBzaW5nbGUgdXJpXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHVyaXNfKSA/IHVyaXNfIDogW3VyaXNfXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXJpcyA9IGNsZWFuZWQubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlbmQgZGVhbCB3aXRoIHRoZSBkaWZmZXJudCBmaWxlIHR5cGVzXG4gICAgY29uc3QgZm9ybV8gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBjb25zdCB7IGZpbGVOYW1lcywgZm9ybSB9ID0gYnVpbGRGb3JtRGF0YShmb3JtXywgdXJpcywgb3B0aW9ucyk7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBkZXRlY3RQbGF0Zm9ybSgpO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gXCJicm93c2VyXCIgfHwgcGxhdGZvcm0gPT09IFwibm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IHsgdXBsb2FkQmF0Y2ggfSA9IGF3YWl0IGltcG9ydChcIi4vdXBsb2FkL3dlYi1ub2RlLmpzXCIpO1xuICAgICAgICBjb25zdCB1cmlzID0gYXdhaXQgdXBsb2FkQmF0Y2gob3B0aW9ucy5jbGllbnQsIGZvcm0sIGZpbGVOYW1lcywgb3B0aW9ucyk7XG4gICAgICAgIC8vIGlmIHdlIG9ubHkgcGFzc2VkIGEgc2luZ2xlIGZpbGUsIHJldHVybiBpdHMgVVJJIGRpcmVjdGx5XG4gICAgICAgIGlmIChvcHRpb25zLmZpbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVyaXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaXM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSwgdXNlIHRoZSB1cGxvYWRNb2JpbGUgZnVuY3Rpb24gaW4gbW9iaWxlIGVudmlyb25tZW50cy5cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGxvYWQuanMubWFwIl0sIm5hbWVzIjpbImRldGVjdFBsYXRmb3JtIiwic3RyaW5naWZ5IiwiYnVpbGRGb3JtRGF0YSIsImV4dHJhY3RPYmplY3RGaWxlcyIsImlzRmlsZU9yVWludDhBcnJheSIsInJlcGxhY2VPYmplY3RGaWxlc1dpdGhVcmlzIiwicmVwbGFjZU9iamVjdEdhdGV3YXlVcmxzV2l0aFNjaGVtZXMiLCJ1cGxvYWQiLCJvcHRpb25zIiwiZmlsZXMiLCJsZW5ndGgiLCJpc0ZpbGVBcnJheSIsIm1hcCIsIml0ZW0iLCJldmVyeSIsInVyaXMiLCJjbGVhbmVkIiwidXJpc18iLCJBcnJheSIsImlzQXJyYXkiLCJmb3JtXyIsIkZvcm1EYXRhIiwiZmlsZU5hbWVzIiwiZm9ybSIsInBsYXRmb3JtIiwidXBsb2FkQmF0Y2giLCJjbGllbnQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/storage/upload.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/storage/upload/helpers.js":
/*!******************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/storage/upload/helpers.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildFormData: function() { return /* binding */ buildFormData; },\n/* harmony export */   extractObjectFiles: function() { return /* binding */ extractObjectFiles; },\n/* harmony export */   isFileBufferOrStringEqual: function() { return /* binding */ isFileBufferOrStringEqual; },\n/* harmony export */   isFileOrUint8Array: function() { return /* binding */ isFileOrUint8Array; },\n/* harmony export */   replaceGatewayUrlWithScheme: function() { return /* binding */ replaceGatewayUrlWithScheme; },\n/* harmony export */   replaceObjectFilesWithUris: function() { return /* binding */ replaceObjectFilesWithUris; },\n/* harmony export */   replaceObjectGatewayUrlsWithSchemes: function() { return /* binding */ replaceObjectGatewayUrlsWithSchemes; }\n/* harmony export */ });\n/* harmony import */ var _utils_type_guards_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/type-guards.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/type-guards.js\");\n/* harmony import */ var _utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/uint8-array.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/uint8-array.js\");\n\n\n/**\n * @internal\n */ function isFileInstance(data) {\n    return globalThis.File && data instanceof File;\n}\n/**\n * @internal\n */ function isBufferOrStringWithName(data) {\n    if (!data) {\n        return false;\n    }\n    if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_0__.isObjectWithKeys)(data, [\n        \"data\",\n        \"name\"\n    ])) {\n        return false;\n    }\n    return !!(typeof data.name === \"string\" && (typeof data.data === \"string\" || (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(data.data)));\n}\nfunction isFileBufferOrStringEqual(input1, input2) {\n    if (isFileInstance(input1) && isFileInstance(input2)) {\n        // if both are File types, compare the name, size, and last modified date (best guess that these are the same files)\n        if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {\n            return true;\n        }\n    } else if ((0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(input1) && (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(input2)) {\n        // buffer gives us an easy way to compare the contents!\n        return (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.areUint8ArraysEqual)(input1, input2);\n    } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {\n        // first check the names\n        if (input1.name === input2.name) {\n            // if the data for both is a string, compare the strings\n            if (typeof input1.data === \"string\" && typeof input2.data === \"string\") {\n                return input1.data === input2.data;\n            }\n            if ((0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(input1.data) && (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(input2.data)) {\n                // otherwise we know it's buffers, so compare the buffers\n                return (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.areUint8ArraysEqual)(input1.data, input2.data);\n            }\n        }\n    }\n    // otherwise if we have not found a match, return false\n    return false;\n}\nfunction buildFormData(form, files, options) {\n    const fileNameToFileMap = new Map();\n    const fileNames = [];\n    for(let i = 0; i < files.length; i++){\n        // biome-ignore lint/style/noNonNullAssertion: we know that files[i] is not null or undefined because we are iterating over the array\n        const file = files[i];\n        let fileName = \"\";\n        let fileData = file;\n        if (isFileInstance(file)) {\n            if (options === null || options === void 0 ? void 0 : options.rewriteFileNames) {\n                let extensions = \"\";\n                if (file.name) {\n                    const extensionStartIndex = file.name.lastIndexOf(\".\");\n                    if (extensionStartIndex > -1) {\n                        extensions = file.name.substring(extensionStartIndex);\n                    }\n                }\n                fileName = \"\".concat(i + options.rewriteFileNames.fileStartNumber).concat(extensions);\n            } else {\n                fileName = \"\".concat(file.name);\n            }\n        } else if (isBufferOrStringWithName(file)) {\n            fileData = file.data;\n            if (options === null || options === void 0 ? void 0 : options.rewriteFileNames) {\n                fileName = \"\".concat(i + options.rewriteFileNames.fileStartNumber);\n            } else {\n                fileName = \"\".concat(file.name);\n            }\n        } else {\n            if (options === null || options === void 0 ? void 0 : options.rewriteFileNames) {\n                fileName = \"\".concat(i + options.rewriteFileNames.fileStartNumber);\n            } else {\n                fileName = \"\".concat(i);\n            }\n        }\n        // If we don't want to wrap with directory, adjust the filepath\n        const filepath = (options === null || options === void 0 ? void 0 : options.uploadWithoutDirectory) ? \"files\" : \"files/\".concat(fileName);\n        if (fileNameToFileMap.has(fileName)) {\n            // if the file in the map is the same as the file we are already looking at then just skip and continue\n            if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {\n                // we add it to the filenames array so that we can return the correct number of urls,\n                fileNames.push(fileName);\n                continue;\n            }\n            // otherwise if file names are the same but they are not the same file then we should throw an error (trying to upload to differnt files but with the same names)\n            throw new Error(\"[DUPLICATE_FILE_NAME_ERROR] File name \".concat(fileName, \" was passed for more than one different file.\"));\n        }\n        // add it to the map so that we can check for duplicates\n        fileNameToFileMap.set(fileName, file);\n        // add it to the filenames array so that we can return the correct number of urls\n        fileNames.push(fileName);\n        form.append(\"file\", new Blob([\n            fileData\n        ]), filepath);\n    }\n    const metadata = {\n        name: \"Storage SDK\",\n        keyvalues: {\n            ...options === null || options === void 0 ? void 0 : options.metadata\n        }\n    };\n    form.append(\"pinataMetadata\", JSON.stringify(metadata));\n    if (options === null || options === void 0 ? void 0 : options.uploadWithoutDirectory) {\n        form.append(\"pinataOptions\", JSON.stringify({\n            wrapWithDirectory: false\n        }));\n    }\n    return {\n        form,\n        // encode the file names on the way out (which is what the upload backend expects)\n        fileNames: fileNames.map((fName)=>encodeURIComponent(fName))\n    };\n}\nfunction isFileOrUint8Array(data) {\n    return isFileInstance(data) || (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(data) || isBufferOrStringWithName(data);\n}\n/**\n * @internal\n */ function extractObjectFiles(data) {\n    let files = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    // If item is a FileOrBuffer add it to our list of files\n    if (isFileOrUint8Array(data)) {\n        files.push(data);\n        return files;\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return files;\n        }\n        if (Array.isArray(data)) {\n            for (const entry of data){\n                extractObjectFiles(entry, files);\n            }\n        } else {\n            Object.keys(data).map((key)=>extractObjectFiles(data[key], files));\n        }\n    }\n    return files;\n}\n/**\n * @internal\n */ function replaceObjectFilesWithUris(data, uris) {\n    if (isFileOrUint8Array(data)) {\n        if (uris.length) {\n            return uris.shift();\n        }\n        console.warn(\"Not enough URIs to replace all files in object.\");\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return data;\n        }\n        if (Array.isArray(data)) {\n            return data.map((entry)=>replaceObjectFilesWithUris(entry, uris));\n        }\n        return Object.fromEntries(Object.entries(data).map((param)=>{\n            let [key, value] = param;\n            return [\n                key,\n                replaceObjectFilesWithUris(value, uris)\n            ];\n        }));\n    }\n    return data;\n}\n/**\n * @internal\n */ function replaceGatewayUrlWithScheme(url) {\n    if (url.includes(\"/ipfs/\")) {\n        const hash = url.split(\"/ipfs/\")[1];\n        return \"ipfs://\".concat(hash);\n    }\n    return url;\n}\n/**\n * @internal\n */ function replaceObjectGatewayUrlsWithSchemes(data) {\n    if (typeof data === \"string\") {\n        return replaceGatewayUrlWithScheme(data);\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return data;\n        }\n        if (isFileOrUint8Array(data)) {\n            return data;\n        }\n        if (Array.isArray(data)) {\n            return data.map((entry)=>replaceObjectGatewayUrlsWithSchemes(entry));\n        }\n        return Object.fromEntries(Object.entries(data).map((param)=>{\n            let [key, value] = param;\n            return [\n                key,\n                replaceObjectGatewayUrlsWithSchemes(value)\n            ];\n        }));\n    }\n    return data;\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9zdG9yYWdlL3VwbG9hZC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4RDtBQUNpQjtBQUMvRTs7Q0FFQyxHQUNELFNBQVNHLGVBQWVDLElBQUk7SUFDeEIsT0FBT0MsV0FBV0MsSUFBSSxJQUFJRixnQkFBZ0JFO0FBQzlDO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQyx5QkFBeUJILElBQUk7SUFDbEMsSUFBSSxDQUFDQSxNQUFNO1FBQ1AsT0FBTztJQUNYO0lBQ0EsSUFBSSxDQUFDSix1RUFBZ0JBLENBQUNJLE1BQU07UUFBQztRQUFRO0tBQU8sR0FBRztRQUMzQyxPQUFPO0lBQ1g7SUFDQSxPQUFPLENBQUMsQ0FBRSxRQUFPQSxLQUFLSSxJQUFJLEtBQUssWUFDMUIsUUFBT0osS0FBS0EsSUFBSSxLQUFLLFlBQVlGLG1FQUFZQSxDQUFDRSxLQUFLQSxJQUFJLEVBQUM7QUFDakU7QUFDTyxTQUFTSywwQkFBMEJDLE1BQU0sRUFBRUMsTUFBTTtJQUNwRCxJQUFJUixlQUFlTyxXQUFXUCxlQUFlUSxTQUFTO1FBQ2xELG9IQUFvSDtRQUNwSCxJQUFJRCxPQUFPRixJQUFJLEtBQUtHLE9BQU9ILElBQUksSUFDM0JFLE9BQU9FLFlBQVksS0FBS0QsT0FBT0MsWUFBWSxJQUMzQ0YsT0FBT0csSUFBSSxLQUFLRixPQUFPRSxJQUFJLEVBQUU7WUFDN0IsT0FBTztRQUNYO0lBQ0osT0FDSyxJQUFJWCxtRUFBWUEsQ0FBQ1EsV0FBV1IsbUVBQVlBLENBQUNTLFNBQVM7UUFDbkQsdURBQXVEO1FBQ3ZELE9BQU9WLDBFQUFtQkEsQ0FBQ1MsUUFBUUM7SUFDdkMsT0FDSyxJQUFJSix5QkFBeUJHLFdBQzlCSCx5QkFBeUJJLFNBQVM7UUFDbEMsd0JBQXdCO1FBQ3hCLElBQUlELE9BQU9GLElBQUksS0FBS0csT0FBT0gsSUFBSSxFQUFFO1lBQzdCLHdEQUF3RDtZQUN4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RDtBQUNYLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9zdG9yYWdlL3VwbG9hZC9oZWxwZXJzLmpzP2ViOWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNPYmplY3RXaXRoS2V5cyB9IGZyb20gXCIuLi8uLi91dGlscy90eXBlLWd1YXJkcy5qc1wiO1xuaW1wb3J0IHsgYXJlVWludDhBcnJheXNFcXVhbCwgaXNVaW50OEFycmF5IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3VpbnQ4LWFycmF5LmpzXCI7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc0ZpbGVJbnN0YW5jZShkYXRhKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuRmlsZSAmJiBkYXRhIGluc3RhbmNlb2YgRmlsZTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyT3JTdHJpbmdXaXRoTmFtZShkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc09iamVjdFdpdGhLZXlzKGRhdGEsIFtcImRhdGFcIiwgXCJuYW1lXCJdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhISh0eXBlb2YgZGF0YS5uYW1lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICh0eXBlb2YgZGF0YS5kYXRhID09PSBcInN0cmluZ1wiIHx8IGlzVWludDhBcnJheShkYXRhLmRhdGEpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlQnVmZmVyT3JTdHJpbmdFcXVhbChpbnB1dDEsIGlucHV0Mikge1xuICAgIGlmIChpc0ZpbGVJbnN0YW5jZShpbnB1dDEpICYmIGlzRmlsZUluc3RhbmNlKGlucHV0MikpIHtcbiAgICAgICAgLy8gaWYgYm90aCBhcmUgRmlsZSB0eXBlcywgY29tcGFyZSB0aGUgbmFtZSwgc2l6ZSwgYW5kIGxhc3QgbW9kaWZpZWQgZGF0ZSAoYmVzdCBndWVzcyB0aGF0IHRoZXNlIGFyZSB0aGUgc2FtZSBmaWxlcylcbiAgICAgICAgaWYgKGlucHV0MS5uYW1lID09PSBpbnB1dDIubmFtZSAmJlxuICAgICAgICAgICAgaW5wdXQxLmxhc3RNb2RpZmllZCA9PT0gaW5wdXQyLmxhc3RNb2RpZmllZCAmJlxuICAgICAgICAgICAgaW5wdXQxLnNpemUgPT09IGlucHV0Mi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1VpbnQ4QXJyYXkoaW5wdXQxKSAmJiBpc1VpbnQ4QXJyYXkoaW5wdXQyKSkge1xuICAgICAgICAvLyBidWZmZXIgZ2l2ZXMgdXMgYW4gZWFzeSB3YXkgdG8gY29tcGFyZSB0aGUgY29udGVudHMhXG4gICAgICAgIHJldHVybiBhcmVVaW50OEFycmF5c0VxdWFsKGlucHV0MSwgaW5wdXQyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCdWZmZXJPclN0cmluZ1dpdGhOYW1lKGlucHV0MSkgJiZcbiAgICAgICAgaXNCdWZmZXJPclN0cmluZ1dpdGhOYW1lKGlucHV0MikpIHtcbiAgICAgICAgLy8gZmlyc3QgY2hlY2sgdGhlIG5hbWVzXG4gICAgICAgIGlmIChpbnB1dDEubmFtZSA9PT0gaW5wdXQyLm5hbWUpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBkYXRhIGZvciBib3RoIGlzIGEgc3RyaW5nLCBjb21wYXJlIHRoZSBzdHJpbmdzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0MS5kYXRhID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpbnB1dDIuZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDEuZGF0YSA9PT0gaW5wdXQyLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNVaW50OEFycmF5KGlucHV0MS5kYXRhKSAmJiBpc1VpbnQ4QXJyYXkoaW5wdXQyLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGtub3cgaXQncyBidWZmZXJzLCBzbyBjb21wYXJlIHRoZSBidWZmZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZVVpbnQ4QXJyYXlzRXF1YWwoaW5wdXQxLmRhdGEsIGlucHV0Mi5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgaWYgd2UgaGF2ZSBub3QgZm91bmQgYSBtYXRjaCwgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRm9ybURhdGEoZm9ybSwgZmlsZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaWxlTmFtZVRvRmlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBmaWxlTmFtZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N0eWxlL25vTm9uTnVsbEFzc2VydGlvbjogd2Uga25vdyB0aGF0IGZpbGVzW2ldIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZCBiZWNhdXNlIHdlIGFyZSBpdGVyYXRpbmcgb3ZlciB0aGUgYXJyYXlcbiAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVzW2ldO1xuICAgICAgICBsZXQgZmlsZU5hbWUgPSBcIlwiO1xuICAgICAgICBsZXQgZmlsZURhdGEgPSBmaWxlO1xuICAgICAgICBpZiAoaXNGaWxlSW5zdGFuY2UoZmlsZSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5yZXdyaXRlRmlsZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4dGVuc2lvbnMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uU3RhcnRJbmRleCA9IGZpbGUubmFtZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25TdGFydEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMgPSBmaWxlLm5hbWUuc3Vic3RyaW5nKGV4dGVuc2lvblN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYCR7aSArIG9wdGlvbnMucmV3cml0ZUZpbGVOYW1lcy5maWxlU3RhcnROdW1iZXJ9JHtleHRlbnNpb25zfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IGAke2ZpbGUubmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQnVmZmVyT3JTdHJpbmdXaXRoTmFtZShmaWxlKSkge1xuICAgICAgICAgICAgZmlsZURhdGEgPSBmaWxlLmRhdGE7XG4gICAgICAgICAgICBpZiAob3B0aW9ucz8ucmV3cml0ZUZpbGVOYW1lcykge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYCR7aSArIG9wdGlvbnMucmV3cml0ZUZpbGVOYW1lcy5maWxlU3RhcnROdW1iZXJ9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYCR7ZmlsZS5uYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucz8ucmV3cml0ZUZpbGVOYW1lcykge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYCR7aSArIG9wdGlvbnMucmV3cml0ZUZpbGVOYW1lcy5maWxlU3RhcnROdW1iZXJ9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYCR7aX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IHdhbnQgdG8gd3JhcCB3aXRoIGRpcmVjdG9yeSwgYWRqdXN0IHRoZSBmaWxlcGF0aFxuICAgICAgICBjb25zdCBmaWxlcGF0aCA9IG9wdGlvbnM/LnVwbG9hZFdpdGhvdXREaXJlY3RvcnlcbiAgICAgICAgICAgID8gXCJmaWxlc1wiXG4gICAgICAgICAgICA6IGBmaWxlcy8ke2ZpbGVOYW1lfWA7XG4gICAgICAgIGlmIChmaWxlTmFtZVRvRmlsZU1hcC5oYXMoZmlsZU5hbWUpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZmlsZSBpbiB0aGUgbWFwIGlzIHRoZSBzYW1lIGFzIHRoZSBmaWxlIHdlIGFyZSBhbHJlYWR5IGxvb2tpbmcgYXQgdGhlbiBqdXN0IHNraXAgYW5kIGNvbnRpbnVlXG4gICAgICAgICAgICBpZiAoaXNGaWxlQnVmZmVyT3JTdHJpbmdFcXVhbChmaWxlTmFtZVRvRmlsZU1hcC5nZXQoZmlsZU5hbWUpLCBmaWxlKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFkZCBpdCB0byB0aGUgZmlsZW5hbWVzIGFycmF5IHNvIHRoYXQgd2UgY2FuIHJldHVybiB0aGUgY29ycmVjdCBudW1iZXIgb2YgdXJscyxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZXMucHVzaChmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoZW4gd2Ugc2tpcCBiZWNhdXNlIHdlIGRvbid0IG5lZWQgdG8gdXBsb2FkIGl0IG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaWYgZmlsZSBuYW1lcyBhcmUgdGhlIHNhbWUgYnV0IHRoZXkgYXJlIG5vdCB0aGUgc2FtZSBmaWxlIHRoZW4gd2Ugc2hvdWxkIHRocm93IGFuIGVycm9yICh0cnlpbmcgdG8gdXBsb2FkIHRvIGRpZmZlcm50IGZpbGVzIGJ1dCB3aXRoIHRoZSBzYW1lIG5hbWVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbRFVQTElDQVRFX0ZJTEVfTkFNRV9FUlJPUl0gRmlsZSBuYW1lICR7ZmlsZU5hbWV9IHdhcyBwYXNzZWQgZm9yIG1vcmUgdGhhbiBvbmUgZGlmZmVyZW50IGZpbGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGl0IHRvIHRoZSBtYXAgc28gdGhhdCB3ZSBjYW4gY2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgICAgICAgZmlsZU5hbWVUb0ZpbGVNYXAuc2V0KGZpbGVOYW1lLCBmaWxlKTtcbiAgICAgICAgLy8gYWRkIGl0IHRvIHRoZSBmaWxlbmFtZXMgYXJyYXkgc28gdGhhdCB3ZSBjYW4gcmV0dXJuIHRoZSBjb3JyZWN0IG51bWJlciBvZiB1cmxzXG4gICAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGVOYW1lKTtcbiAgICAgICAgZm9ybS5hcHBlbmQoXCJmaWxlXCIsIG5ldyBCbG9iKFtmaWxlRGF0YV0pLCBmaWxlcGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICBuYW1lOiBcIlN0b3JhZ2UgU0RLXCIsXG4gICAgICAgIGtleXZhbHVlczogeyAuLi5vcHRpb25zPy5tZXRhZGF0YSB9LFxuICAgIH07XG4gICAgZm9ybS5hcHBlbmQoXCJwaW5hdGFNZXRhZGF0YVwiLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgIGlmIChvcHRpb25zPy51cGxvYWRXaXRob3V0RGlyZWN0b3J5KSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKFwicGluYXRhT3B0aW9uc1wiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB3cmFwV2l0aERpcmVjdG9yeTogZmFsc2UsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybSxcbiAgICAgICAgLy8gZW5jb2RlIHRoZSBmaWxlIG5hbWVzIG9uIHRoZSB3YXkgb3V0ICh3aGljaCBpcyB3aGF0IHRoZSB1cGxvYWQgYmFja2VuZCBleHBlY3RzKVxuICAgICAgICBmaWxlTmFtZXM6IGZpbGVOYW1lcy5tYXAoKGZOYW1lKSA9PiBlbmNvZGVVUklDb21wb25lbnQoZk5hbWUpKSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRmlsZU9yVWludDhBcnJheShkYXRhKSB7XG4gICAgcmV0dXJuIChpc0ZpbGVJbnN0YW5jZShkYXRhKSB8fCBpc1VpbnQ4QXJyYXkoZGF0YSkgfHwgaXNCdWZmZXJPclN0cmluZ1dpdGhOYW1lKGRhdGEpKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0T2JqZWN0RmlsZXMoZGF0YSwgZmlsZXMgPSBbXSkge1xuICAgIC8vIElmIGl0ZW0gaXMgYSBGaWxlT3JCdWZmZXIgYWRkIGl0IHRvIG91ciBsaXN0IG9mIGZpbGVzXG4gICAgaWYgKGlzRmlsZU9yVWludDhBcnJheShkYXRhKSkge1xuICAgICAgICBmaWxlcy5wdXNoKGRhdGEpO1xuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdE9iamVjdEZpbGVzKGVudHJ5LCBmaWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5tYXAoKGtleSkgPT4gZXh0cmFjdE9iamVjdEZpbGVzKGRhdGFba2V5XSwgZmlsZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsZXM7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU9iamVjdEZpbGVzV2l0aFVyaXMoZGF0YSwgdXJpcykge1xuICAgIGlmIChpc0ZpbGVPclVpbnQ4QXJyYXkoZGF0YSkpIHtcbiAgICAgICAgaWYgKHVyaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpcy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIk5vdCBlbm91Z2ggVVJJcyB0byByZXBsYWNlIGFsbCBmaWxlcyBpbiBvYmplY3QuXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKChlbnRyeSkgPT4gcmVwbGFjZU9iamVjdEZpbGVzV2l0aFVyaXMoZW50cnksIHVyaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGRhdGEpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICByZXBsYWNlT2JqZWN0RmlsZXNXaXRoVXJpcyh2YWx1ZSwgdXJpcyksXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUdhdGV3YXlVcmxXaXRoU2NoZW1lKHVybCkge1xuICAgIGlmICh1cmwuaW5jbHVkZXMoXCIvaXBmcy9cIikpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IHVybC5zcGxpdChcIi9pcGZzL1wiKVsxXTtcbiAgICAgICAgcmV0dXJuIGBpcGZzOi8vJHtoYXNofWA7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU9iamVjdEdhdGV3YXlVcmxzV2l0aFNjaGVtZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcmVwbGFjZUdhdGV3YXlVcmxXaXRoU2NoZW1lKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGaWxlT3JVaW50OEFycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubWFwKChlbnRyeSkgPT4gcmVwbGFjZU9iamVjdEdhdGV3YXlVcmxzV2l0aFNjaGVtZXMoZW50cnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGRhdGEpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICByZXBsYWNlT2JqZWN0R2F0ZXdheVVybHNXaXRoU2NoZW1lcyh2YWx1ZSksXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJpc09iamVjdFdpdGhLZXlzIiwiYXJlVWludDhBcnJheXNFcXVhbCIsImlzVWludDhBcnJheSIsImlzRmlsZUluc3RhbmNlIiwiZGF0YSIsImdsb2JhbFRoaXMiLCJGaWxlIiwiaXNCdWZmZXJPclN0cmluZ1dpdGhOYW1lIiwibmFtZSIsImlzRmlsZUJ1ZmZlck9yU3RyaW5nRXF1YWwiLCJpbnB1dDEiLCJpbnB1dDIiLCJsYXN0TW9kaWZpZWQiLCJzaXplIiwiYnVpbGRGb3JtRGF0YSIsImZvcm0iLCJmaWxlcyIsIm9wdGlvbnMiLCJmaWxlTmFtZVRvRmlsZU1hcCIsIk1hcCIsImZpbGVOYW1lcyIsImkiLCJsZW5ndGgiLCJmaWxlIiwiZmlsZU5hbWUiLCJmaWxlRGF0YSIsInJld3JpdGVGaWxlTmFtZXMiLCJleHRlbnNpb25zIiwiZXh0ZW5zaW9uU3RhcnRJbmRleCIsImxhc3RJbmRleE9mIiwic3Vic3RyaW5nIiwiZmlsZVN0YXJ0TnVtYmVyIiwiZmlsZXBhdGgiLCJ1cGxvYWRXaXRob3V0RGlyZWN0b3J5IiwiaGFzIiwiZ2V0IiwicHVzaCIsIkVycm9yIiwic2V0IiwiYXBwZW5kIiwiQmxvYiIsIm1ldGFkYXRhIiwia2V5dmFsdWVzIiwiSlNPTiIsInN0cmluZ2lmeSIsIndyYXBXaXRoRGlyZWN0b3J5IiwibWFwIiwiZk5hbWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJpc0ZpbGVPclVpbnQ4QXJyYXkiLCJleHRyYWN0T2JqZWN0RmlsZXMiLCJBcnJheSIsImlzQXJyYXkiLCJlbnRyeSIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJyZXBsYWNlT2JqZWN0RmlsZXNXaXRoVXJpcyIsInVyaXMiLCJzaGlmdCIsImNvbnNvbGUiLCJ3YXJuIiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwidmFsdWUiLCJyZXBsYWNlR2F0ZXdheVVybFdpdGhTY2hlbWUiLCJ1cmwiLCJpbmNsdWRlcyIsImhhc2giLCJzcGxpdCIsInJlcGxhY2VPYmplY3RHYXRld2F5VXJsc1dpdGhTY2hlbWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/storage/upload/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/uint8-array.js":
/*!*************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/utils/uint8-array.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areUint8ArraysEqual: function() { return /* binding */ areUint8ArraysEqual; },\n/* harmony export */   base64ToString: function() { return /* binding */ base64ToString; },\n/* harmony export */   base64ToUint8Array: function() { return /* binding */ base64ToUint8Array; },\n/* harmony export */   compareUint8Arrays: function() { return /* binding */ compareUint8Arrays; },\n/* harmony export */   concatUint8Arrays: function() { return /* binding */ concatUint8Arrays; },\n/* harmony export */   isUint8Array: function() { return /* binding */ isUint8Array; },\n/* harmony export */   uint8ArrayToBase64: function() { return /* binding */ uint8ArrayToBase64; },\n/* harmony export */   uint8ArrayToString: function() { return /* binding */ uint8ArrayToString; }\n/* harmony export */ });\n/* harmony import */ var _text_decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text-decoder.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/text-decoder.js\");\n\nconst uint8ArrayStringified = \"[object Uint8Array]\";\n/**\n * Throw a `TypeError` if the given value is not an instance of `Uint8Array`.\n * @example\n * ```ts\n * import {assertUint8Array} from 'uint8array-extras';\n *\n * try {\n * assertUint8Array(new ArrayBuffer(10)); // Throws a TypeError\n * } catch (error) {\n * console.error(error.message);\n * }\n * ```\n */ function assertUint8Array(value) {\n    if (!isUint8Array(value)) {\n        throw new TypeError(\"Expected `Uint8Array`, got `\".concat(typeof value, \"`\"));\n    }\n}\n/**\n * Check if the given value is an instance of `Uint8Array`.\n *\n * Replacement for [`Buffer.isBuffer()`](https://nodejs.org/api/buffer.html#static-method-bufferisbufferobj).\n * @example\n * ```ts\n * import {isUint8Array} from 'uint8array-extras';\n *\n * console.log(isUint8Array(new Uint8Array()));\n * //=> true\n *\n * console.log(isUint8Array(Buffer.from('x')));\n * //=> true\n *\n * console.log(isUint8Array(new ArrayBuffer(10)));\n * //=> false\n * ```\n */ function isUint8Array(value) {\n    if (!value) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    return Object.prototype.toString.call(value) === uint8ArrayStringified;\n}\n/**\n * Check if two arrays are identical by verifying that they contain the same bytes in the same sequence.\n *\n * Replacement for [`Buffer#equals()`](https://nodejs.org/api/buffer.html#bufequalsotherbuffer).\n * @example\n * ```ts\n * import {areUint8ArraysEqual} from 'uint8array-extras';\n *\n * const a = new Uint8Array([1, 2, 3]);\n * const b = new Uint8Array([1, 2, 3]);\n * const c = new Uint8Array([4, 5, 6]);\n *\n * console.log(areUint8ArraysEqual(a, b));\n * //=> true\n *\n * console.log(areUint8ArraysEqual(a, c));\n * //=> false\n * ```\n */ function areUint8ArraysEqual(a, b) {\n    assertUint8Array(a);\n    assertUint8Array(b);\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let index = 0; index < a.length; index++){\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Convert a `Uint8Array` (containing a UTF-8 string) to a string.\n *\n * Replacement for [`Buffer#toString()`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end).\n * @example\n * ```ts\n * import {uint8ArrayToString} from 'uint8array-extras';\n *\n * const byteArray = new Uint8Array([72, 101, 108, 108, 111]);\n *\n * console.log(uint8ArrayToString(byteArray));\n * //=> 'Hello'\n * ```\n */ function uint8ArrayToString(array) {\n    assertUint8Array(array);\n    return (0,_text_decoder_js__WEBPACK_IMPORTED_MODULE_0__.cachedTextDecoder)().decode(array);\n}\nfunction assertString(value) {\n    if (typeof value !== \"string\") {\n        throw new TypeError(\"Expected `string`, got `\".concat(typeof value, \"`\"));\n    }\n}\nfunction base64UrlToBase64(base64url) {\n    return base64url.replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\");\n}\n/**\n * Convert a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a `Uint8Array`.\n *\n * Replacement for [`Buffer.from('SGVsbG8=', 'base64')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).\n * @example\n * ```ts\n * import {base64ToUint8Array} from 'uint8array-extras';\n *\n * console.log(base64ToUint8Array('SGVsbG8='));\n * //=> Uint8Array [72, 101, 108, 108, 111]\n * ```\n */ function base64ToUint8Array(base64String) {\n    assertString(base64String);\n    return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), // biome-ignore lint/style/noNonNullAssertion: we know that the code points exist\n    (x)=>x.codePointAt(0));\n}\n/**\n * Decode a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a string.\n *\n * Replacement for `Buffer.from('SGVsbG8=', 'base64').toString()` and [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob).\n * @example\n * ```ts\n * import {base64ToString} from 'uint8array-extras';\n *\n * console.log(base64ToString('SGVsbG8='));\n * //=> 'Hello'\n * ```\n */ function base64ToString(base64String) {\n    assertString(base64String);\n    return uint8ArrayToString(base64ToUint8Array(base64String));\n}\nfunction base64ToBase64Url(base64) {\n    return base64.replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\").replace(/=+$/, \"\");\n}\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\nconst MAX_BLOCK_SIZE = 65535;\nfunction uint8ArrayToBase64(array) {\n    let { urlSafe = false } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    assertUint8Array(array);\n    let base64;\n    if (array.length < MAX_BLOCK_SIZE) {\n        // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n        // @ts-expect-error - TS doesn't know about `String#fromCodePoint`\n        base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));\n    } else {\n        base64 = \"\";\n        for (const value of array){\n            base64 += String.fromCodePoint(value);\n        }\n        base64 = globalThis.btoa(base64);\n    }\n    return urlSafe ? base64ToBase64Url(base64) : base64;\n}\nfunction concatUint8Arrays(arrays, totalLength) {\n    if (arrays.length === 0) {\n        return new Uint8Array(0);\n    }\n    const calculatedTotalLength = totalLength !== null && totalLength !== void 0 ? totalLength : arrays.reduce((accumulator, currentValue)=>accumulator + currentValue.length, 0);\n    const returnValue = new Uint8Array(calculatedTotalLength);\n    let offset = 0;\n    for (const array of arrays){\n        assertUint8Array(array);\n        returnValue.set(array, offset);\n        offset += array.length;\n    }\n    return returnValue;\n}\nfunction compareUint8Arrays(a, b) {\n    assertUint8Array(a);\n    assertUint8Array(b);\n    const length = Math.min(a.length, b.length);\n    for(let index = 0; index < length; index++){\n        // biome-ignore lint/style/noNonNullAssertion: we check the length above so the index is always in bounds\n        const diff = a[index] - b[index];\n        if (diff !== 0) {\n            return Math.sign(diff);\n        }\n    }\n    // At this point, all the compared elements are equal.\n    // The shorter array should come first if the arrays are of different lengths.\n    return Math.sign(a.length - b.length);\n} //# sourceMappingURL=uint8-array.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy91aW50OC1hcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBc0Q7QUFDdEQsTUFBTUMsd0JBQXdCO0FBQzlCOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELFNBQVNDLGlCQUFpQkMsS0FBSztJQUMzQixJQUFJLENBQUNDLGFBQWFELFFBQVE7UUFDdEIsTUFBTSxJQUFJRSxVQUFVLCtCQUErQyxPQUFiLE9BQU9GLE9BQU07SUFDdkU7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNDLGFBQWFELEtBQUs7SUFDOUIsSUFBSSxDQUFDQSxPQUFPO1FBQ1IsT0FBTztJQUNYO0lBQ0EsSUFBSUEsTUFBTUcsV0FBVyxLQUFLQyxZQUFZO1FBQ2xDLE9BQU87SUFDWDtJQUNBLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNSLFdBQVdGO0FBQ3JEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNXLG9CQUFvQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3BDWixpQkFBaUJXO0lBQ2pCWCxpQkFBaUJZO0lBQ2pCLElBQUlELE1BQU1DLEdBQUc7UUFDVCxPQUFPO0lBQ1g7SUFDQSxJQUFJRCxFQUFFRSxNQUFNLEtBQUtELEVBQUVDLE1BQU0sRUFBRTtRQUN2QixPQUFPO0lBQ1g7SUFDQSxJQUFLLElBQUlDLFFBQVEsR0FBR0EsUUFBUUgsRUFBRUUsTUFBTSxFQUFFQyxRQUFTO1FBQzNDLElBQUlILENBQUMsQ0FBQ0csTUFBTSxLQUFLRixDQUFDLENBQUNFLE1BQU0sRUFBRTtZQUN2QixPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTQyxtQkFBbUJDLEtBQUs7SUFDcENoQixpQkFBaUJnQjtJQUNqQixPQUFPbEIsbUVBQWlCQSxHQUFHbUIs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L25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS91dGlscy91aW50OC1hcnJheS5qcz8zY2UzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNhY2hlZFRleHREZWNvZGVyIH0gZnJvbSBcIi4vdGV4dC1kZWNvZGVyLmpzXCI7XG5jb25zdCB1aW50OEFycmF5U3RyaW5naWZpZWQgPSBcIltvYmplY3QgVWludDhBcnJheV1cIjtcbi8qKlxuICogVGhyb3cgYSBgVHlwZUVycm9yYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBVaW50OEFycmF5YC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHthc3NlcnRVaW50OEFycmF5fSBmcm9tICd1aW50OGFycmF5LWV4dHJhcyc7XG4gKlxuICogdHJ5IHtcbiAqIGFzc2VydFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKDEwKSk7IC8vIFRocm93cyBhIFR5cGVFcnJvclxuICogfSBjYXRjaCAoZXJyb3IpIHtcbiAqIGNvbnNvbGUuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VWludDhBcnJheSh2YWx1ZSkge1xuICAgIGlmICghaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBVaW50OEFycmF5XFxgLCBnb3QgXFxgJHt0eXBlb2YgdmFsdWV9XFxgYCk7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIFJlcGxhY2VtZW50IGZvciBbYEJ1ZmZlci5pc0J1ZmZlcigpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNzdGF0aWMtbWV0aG9kLWJ1ZmZlcmlzYnVmZmVyb2JqKS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHtpc1VpbnQ4QXJyYXl9IGZyb20gJ3VpbnQ4YXJyYXktZXh0cmFzJztcbiAqXG4gKiBjb25zb2xlLmxvZyhpc1VpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoKSkpO1xuICogLy89PiB0cnVlXG4gKlxuICogY29uc29sZS5sb2coaXNVaW50OEFycmF5KEJ1ZmZlci5mcm9tKCd4JykpKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGNvbnNvbGUubG9nKGlzVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoMTApKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSB1aW50OEFycmF5U3RyaW5naWZpZWQ7XG59XG4vKipcbiAqIENoZWNrIGlmIHR3byBhcnJheXMgYXJlIGlkZW50aWNhbCBieSB2ZXJpZnlpbmcgdGhhdCB0aGV5IGNvbnRhaW4gdGhlIHNhbWUgYnl0ZXMgaW4gdGhlIHNhbWUgc2VxdWVuY2UuXG4gKlxuICogUmVwbGFjZW1lbnQgZm9yIFtgQnVmZmVyI2VxdWFscygpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZlcXVhbHNvdGhlcmJ1ZmZlcikuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7YXJlVWludDhBcnJheXNFcXVhbH0gZnJvbSAndWludDhhcnJheS1leHRyYXMnO1xuICpcbiAqIGNvbnN0IGEgPSBuZXcgVWludDhBcnJheShbMSwgMiwgM10pO1xuICogY29uc3QgYiA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSk7XG4gKiBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoWzQsIDUsIDZdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcmVVaW50OEFycmF5c0VxdWFsKGEsIGIpKTtcbiAqIC8vPT4gdHJ1ZVxuICpcbiAqIGNvbnNvbGUubG9nKGFyZVVpbnQ4QXJyYXlzRXF1YWwoYSwgYykpO1xuICogLy89PiBmYWxzZVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcmVVaW50OEFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBhc3NlcnRVaW50OEFycmF5KGEpO1xuICAgIGFzc2VydFVpbnQ4QXJyYXkoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKGFbaW5kZXhdICE9PSBiW2luZGV4XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIChjb250YWluaW5nIGEgVVRGLTggc3RyaW5nKSB0byBhIHN0cmluZy5cbiAqXG4gKiBSZXBsYWNlbWVudCBmb3IgW2BCdWZmZXIjdG9TdHJpbmcoKWBdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWwjYnVmdG9zdHJpbmdlbmNvZGluZy1zdGFydC1lbmQpLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge3VpbnQ4QXJyYXlUb1N0cmluZ30gZnJvbSAndWludDhhcnJheS1leHRyYXMnO1xuICpcbiAqIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExXSk7XG4gKlxuICogY29uc29sZS5sb2codWludDhBcnJheVRvU3RyaW5nKGJ5dGVBcnJheSkpO1xuICogLy89PiAnSGVsbG8nXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb1N0cmluZyhhcnJheSkge1xuICAgIGFzc2VydFVpbnQ4QXJyYXkoYXJyYXkpO1xuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2RlcigpLmRlY29kZShhcnJheSk7XG59XG5mdW5jdGlvbiBhc3NlcnRTdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYHN0cmluZ1xcYCwgZ290IFxcYCR7dHlwZW9mIHZhbHVlfVxcYGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2U2NFVybFRvQmFzZTY0KGJhc2U2NHVybCkge1xuICAgIHJldHVybiBiYXNlNjR1cmwucmVwbGFjZUFsbChcIi1cIiwgXCIrXCIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiL1wiKTtcbn1cbi8qKlxuICogQ29udmVydCBhIEJhc2U2NC1lbmNvZGVkIG9yIFtCYXNlNjRVUkxdKGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybCktZW5jb2RlZCBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogUmVwbGFjZW1lbnQgZm9yIFtgQnVmZmVyLmZyb20oJ1NHVnNiRzg9JywgJ2Jhc2U2NCcpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNzdGF0aWMtbWV0aG9kLWJ1ZmZlcmZyb21zdHJpbmctZW5jb2RpbmcpLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge2Jhc2U2NFRvVWludDhBcnJheX0gZnJvbSAndWludDhhcnJheS1leHRyYXMnO1xuICpcbiAqIGNvbnNvbGUubG9nKGJhc2U2NFRvVWludDhBcnJheSgnU0dWc2JHOD0nKSk7XG4gKiAvLz0+IFVpbnQ4QXJyYXkgWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTFdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpIHtcbiAgICBhc3NlcnRTdHJpbmcoYmFzZTY0U3RyaW5nKTtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGdsb2JhbFRoaXMuYXRvYihiYXNlNjRVcmxUb0Jhc2U2NChiYXNlNjRTdHJpbmcpKSwgXG4gICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3R5bGUvbm9Ob25OdWxsQXNzZXJ0aW9uOiB3ZSBrbm93IHRoYXQgdGhlIGNvZGUgcG9pbnRzIGV4aXN0XG4gICAgKHgpID0+IHguY29kZVBvaW50QXQoMCkpO1xufVxuLyoqXG4gKiBEZWNvZGUgYSBCYXNlNjQtZW5jb2RlZCBvciBbQmFzZTY0VVJMXShodHRwczovL2Jhc2U2NC5ndXJ1L3N0YW5kYXJkcy9iYXNlNjR1cmwpLWVuY29kZWQgc3RyaW5nIHRvIGEgc3RyaW5nLlxuICpcbiAqIFJlcGxhY2VtZW50IGZvciBgQnVmZmVyLmZyb20oJ1NHVnNiRzg9JywgJ2Jhc2U2NCcpLnRvU3RyaW5nKClgIGFuZCBbYGF0b2IoKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9hdG9iKS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHtiYXNlNjRUb1N0cmluZ30gZnJvbSAndWludDhhcnJheS1leHRyYXMnO1xuICpcbiAqIGNvbnNvbGUubG9nKGJhc2U2NFRvU3RyaW5nKCdTR1ZzYkc4PScpKTtcbiAqIC8vPT4gJ0hlbGxvJ1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb1N0cmluZyhiYXNlNjRTdHJpbmcpIHtcbiAgICBhc3NlcnRTdHJpbmcoYmFzZTY0U3RyaW5nKTtcbiAgICByZXR1cm4gdWludDhBcnJheVRvU3RyaW5nKGJhc2U2NFRvVWludDhBcnJheShiYXNlNjRTdHJpbmcpKTtcbn1cbmZ1bmN0aW9uIGJhc2U2NFRvQmFzZTY0VXJsKGJhc2U2NCkge1xuICAgIHJldHVybiBiYXNlNjQucmVwbGFjZUFsbChcIitcIiwgXCItXCIpLnJlcGxhY2VBbGwoXCIvXCIsIFwiX1wiKS5yZXBsYWNlKC89KyQvLCBcIlwiKTtcbn1cbi8vIFJlZmVyZW5jZTogaHR0cHM6Ly9waHVvYy5uZy9jb2xsZWN0aW9uL3RoaXMtdnMtdGhhdC9jb25jYXQtdnMtcHVzaC9cbmNvbnN0IE1BWF9CTE9DS19TSVpFID0gNjVfNTM1O1xuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0Jhc2U2NChhcnJheSwgeyB1cmxTYWZlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgYXNzZXJ0VWludDhBcnJheShhcnJheSk7XG4gICAgbGV0IGJhc2U2NDtcbiAgICBpZiAoYXJyYXkubGVuZ3RoIDwgTUFYX0JMT0NLX1NJWkUpIHtcbiAgICAgICAgLy8gUmVxdWlyZWQgYXMgYGJ0b2FgIGFuZCBgYXRvYmAgZG9uJ3QgcHJvcGVybHkgc3VwcG9ydCBVbmljb2RlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0Jhc2U2NCN0aGVfdW5pY29kZV9wcm9ibGVtXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBUUyBkb2Vzbid0IGtub3cgYWJvdXQgYFN0cmluZyNmcm9tQ29kZVBvaW50YFxuICAgICAgICBiYXNlNjQgPSBnbG9iYWxUaGlzLmJ0b2EoU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkodGhpcywgYXJyYXkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJhc2U2NCA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcbiAgICAgICAgICAgIGJhc2U2NCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYmFzZTY0ID0gZ2xvYmFsVGhpcy5idG9hKGJhc2U2NCk7XG4gICAgfVxuICAgIHJldHVybiB1cmxTYWZlID8gYmFzZTY0VG9CYXNlNjRVcmwoYmFzZTY0KSA6IGJhc2U2NDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRVaW50OEFycmF5cyhhcnJheXMsIHRvdGFsTGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICBjb25zdCBjYWxjdWxhdGVkVG90YWxMZW5ndGggPSB0b3RhbExlbmd0aCA/P1xuICAgICAgICBhcnJheXMucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvciArIGN1cnJlbnRWYWx1ZS5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoY2FsY3VsYXRlZFRvdGFsTGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgICAgICBhc3NlcnRVaW50OEFycmF5KGFycmF5KTtcbiAgICAgICAgcmV0dXJuVmFsdWUuc2V0KGFycmF5LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXlzKGEsIGIpIHtcbiAgICBhc3NlcnRVaW50OEFycmF5KGEpO1xuICAgIGFzc2VydFVpbnQ4QXJyYXkoYik7XG4gICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3N0eWxlL25vTm9uTnVsbEFzc2VydGlvbjogd2UgY2hlY2sgdGhlIGxlbmd0aCBhYm92ZSBzbyB0aGUgaW5kZXggaXMgYWx3YXlzIGluIGJvdW5kc1xuICAgICAgICBjb25zdCBkaWZmID0gYVtpbmRleF0gLSBiW2luZGV4XTtcbiAgICAgICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpZ24oZGlmZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgYWxsIHRoZSBjb21wYXJlZCBlbGVtZW50cyBhcmUgZXF1YWwuXG4gICAgLy8gVGhlIHNob3J0ZXIgYXJyYXkgc2hvdWxkIGNvbWUgZmlyc3QgaWYgdGhlIGFycmF5cyBhcmUgb2YgZGlmZmVyZW50IGxlbmd0aHMuXG4gICAgcmV0dXJuIE1hdGguc2lnbihhLmxlbmd0aCAtIGIubGVuZ3RoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpbnQ4LWFycmF5LmpzLm1hcCJdLCJuYW1lcyI6WyJjYWNoZWRUZXh0RGVjb2RlciIsInVpbnQ4QXJyYXlTdHJpbmdpZmllZCIsImFzc2VydFVpbnQ4QXJyYXkiLCJ2YWx1ZSIsImlzVWludDhBcnJheSIsIlR5cGVFcnJvciIsImNvbnN0cnVjdG9yIiwiVWludDhBcnJheSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImFyZVVpbnQ4QXJyYXlzRXF1YWwiLCJhIiwiYiIsImxlbmd0aCIsImluZGV4IiwidWludDhBcnJheVRvU3RyaW5nIiwiYXJyYXkiLCJkZWNvZGUiLCJhc3NlcnRTdHJpbmciLCJiYXNlNjRVcmxUb0Jhc2U2NCIsImJhc2U2NHVybCIsInJlcGxhY2VBbGwiLCJiYXNlNjRUb1VpbnQ4QXJyYXkiLCJiYXNlNjRTdHJpbmciLCJmcm9tIiwiZ2xvYmFsVGhpcyIsImF0b2IiLCJ4IiwiY29kZVBvaW50QXQiLCJiYXNlNjRUb1N0cmluZyIsImJhc2U2NFRvQmFzZTY0VXJsIiwiYmFzZTY0IiwicmVwbGFjZSIsIk1BWF9CTE9DS19TSVpFIiwidWludDhBcnJheVRvQmFzZTY0IiwidXJsU2FmZSIsImJ0b2EiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiYXBwbHkiLCJjb25jYXRVaW50OEFycmF5cyIsImFycmF5cyIsInRvdGFsTGVuZ3RoIiwiY2FsY3VsYXRlZFRvdGFsTGVuZ3RoIiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJjdXJyZW50VmFsdWUiLCJyZXR1cm5WYWx1ZSIsIm9mZnNldCIsInNldCIsImNvbXBhcmVVaW50OEFycmF5cyIsIk1hdGgiLCJtaW4iLCJkaWZmIiwic2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/utils/uint8-array.js\n"));

/***/ })

}]);