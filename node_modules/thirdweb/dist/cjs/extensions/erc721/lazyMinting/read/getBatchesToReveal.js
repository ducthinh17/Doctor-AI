"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBatchesToReveal = void 0;
const utils_1 = require("viem/utils");
const fetchTokenMetadata_js_1 = require("../../../../utils/nft/fetchTokenMetadata.js");
const getBaseURICount_js_1 = require("../../__generated__/IBatchMintMetadata/read/getBaseURICount.js");
const getBatchIdAtIndex_js_1 = require("../../__generated__/IBatchMintMetadata/read/getBatchIdAtIndex.js");
const encryptedData_js_1 = require("../../__generated__/IDelayedReveal/read/encryptedData.js");
const baseURIIndices_js_1 = require("../../__generated__/IDrop/read/baseURIIndices.js");
const tokenURI_js_1 = require("../../__generated__/IERC721A/read/tokenURI.js");
/**
 * Retrieves the batches available to reveal in an NFT contract.
 *
 * @param options {BaseTransactionOptions} - The transaction options.
 * @param options.contract {@link ThirdwebContract} - The NFT contract instance.
 * @returns A promise resolving to an array of unrevealed batches.
 *
 * @note Use the `batchId` and corresponding password for each batch to reveal it with `reveal`. {@see reveal}
 * @extension ERC721
 * @example
 * ```ts
 * import { getBatchesToReveal } from "thirdweb/extensions/erc721";
 *
 * const batches = await getBatchesToReveal({ contract: contract });
 *
 * const { transactionHash } = await sendTransaction({ transaction, account });
 * ```
 */
async function getBatchesToReveal(options) {
    const count = await (0, getBaseURICount_js_1.getBaseURICount)({
        contract: options.contract,
    });
    if (count === 0n) {
        return [];
    }
    const countRangeArray = Array.from(Array(Number(count)).keys());
    const uriIndices = await Promise.all(countRangeArray.map(async (batchId) => {
        try {
            return await (0, getBatchIdAtIndex_js_1.getBatchIdAtIndex)({
                contract: options.contract,
                index: BigInt(batchId),
            });
        }
        catch {
            try {
                return await (0, baseURIIndices_js_1.baseURIIndices)({
                    contract: options.contract,
                    index: BigInt(batchId),
                });
            }
            catch {
                throw new Error("Contract does not have `getBatchIdAtIndex` or `baseURIIndices`, which are required for `getBatchesToReveal`");
            }
        }
    }));
    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array
    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);
    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(async (i) => {
        const uri = await (0, tokenURI_js_1.tokenURI)({
            contract: options.contract,
            tokenId: BigInt(i),
        });
        return await (0, fetchTokenMetadata_js_1.fetchTokenMetadata)({
            tokenId: BigInt(i),
            tokenUri: uri,
            client: options.contract.client,
        });
    }));
    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map((i) => (0, encryptedData_js_1.encryptedData)({
        contract: options.contract,
        index: BigInt(i),
    })));
    const encryptedBaseUris = encryptedUriData.map((data) => {
        const hexDataLength = (data.length - 2) / 2;
        if (hexDataLength > 0) {
            return (0, utils_1.decodeAbiParameters)([
                { name: "baseUri", type: "bytes" },
                { name: "provenanceHash", type: "bytes32" },
            ], data)[0];
        }
        else {
            return data;
        }
    });
    return tokenMetadatas
        .map((metadata, i) => ({
        batchId: BigInt(i),
        batchUri: encryptedBaseUris[i],
        placeholderMetadata: metadata,
    }))
        .filter((_, index) => (encryptedBaseUris[index]?.length || 0) > 0);
}
exports.getBatchesToReveal = getBatchesToReveal;
//# sourceMappingURL=getBatchesToReveal.js.map