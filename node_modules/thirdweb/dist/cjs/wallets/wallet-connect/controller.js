"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoConnectWC = exports.connectWC = exports.isWalletConnect = void 0;
const viem_1 = require("viem");
const utils_js_1 = require("../../chains/utils.js");
const hex_js_1 = require("../../utils/encoding/hex.js");
const json_js_1 = require("../../utils/json.js");
const isMobile_js_1 = require("../../utils/web/isMobile.js");
const openWindow_js_1 = require("../../utils/web/openWindow.js");
const getWalletInfo_js_1 = require("../__generated__/getWalletInfo.js");
const chains_js_1 = require("../utils/chains.js");
const defaultDappMetadata_js_1 = require("../utils/defaultDappMetadata.js");
const normalizeChainId_js_1 = require("../utils/normalizeChainId.js");
const storage_js_1 = require("../../react/core/storage.js");
const address_js_1 = require("../../utils/address.js");
const platform_js_1 = require("../../utils/platform.js");
const parseTypedData_js_1 = require("../../utils/signatures/helpers/parseTypedData.js");
const url_js_1 = require("../../utils/url.js");
const walletStorage_js_1 = require("../storage/walletStorage.js");
const constants_js_1 = require("./constants.js");
const asyncLocalStorage = (0, storage_js_1.getStorage)();
const ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
const defaultShowQrModal = true;
const storageKeys = {
    requestedChains: "tw.wc.requestedChains",
    lastUsedChainId: "tw.wc.lastUsedChainId",
};
/**
 * Checks if the provided wallet is a Wallet Connect wallet.
 *
 * @param wallet - The wallet to check.
 * @returns True if the wallet is a Wallet Connect wallet, false otherwise.
 */
function isWalletConnect(wallet) {
    return wallet.id === "walletConnect";
}
exports.isWalletConnect = isWalletConnect;
/**
 * @internal
 */
async function connectWC(options, emitter, walletId) {
    const provider = await initProvider(options, walletId);
    const wcOptions = options.walletConnect;
    let { onDisplayUri } = wcOptions || {};
    if ((0, platform_js_1.isReactNative)() && !onDisplayUri) {
        const walletInfo = await (0, getWalletInfo_js_1.getWalletInfo)(walletId);
        const nativeCallaback = (uri) => {
            const { Linking } = require("react-native");
            const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;
            if (!appUrl) {
                throw new Error("No app url found for wallet connect to redirect to.");
            }
            const fullUrl = (0, url_js_1.formatWalletConnectUrl)(appUrl, uri).redirect;
            Linking.openURL(fullUrl);
        };
        onDisplayUri = nativeCallaback;
    }
    if (onDisplayUri) {
        provider.events.addListener("display_uri", onDisplayUri);
    }
    const { rpcMap, chainsToRequest } = getChainsToRequest({
        client: options.client,
        chain: options.chain,
        optionalChains: options.walletConnect?.optionalChains,
    });
    if (provider.session) {
        await provider.connect({
            ...(wcOptions?.pairingTopic
                ? { pairingTopic: wcOptions?.pairingTopic }
                : {}),
            optionalChains: chainsToRequest,
            chains: options.chain
                ? [options.chain.id]
                : chainsToRequest.length > 0
                    ? [chainsToRequest[0]]
                    : [1],
            rpcMap: rpcMap,
        });
    }
    setRequestedChainsIds(chainsToRequest);
    // If session exists and chains are authorized, enable provider for required chain
    const addresses = await provider.enable();
    const address = addresses[0];
    if (!address) {
        throw new Error("No accounts found on provider.");
    }
    const providerChainId = (0, normalizeChainId_js_1.normalizeChainId)(provider.chainId);
    const chain = options.chain && options.chain.id === providerChainId
        ? options.chain
        : (0, utils_js_1.getCachedChain)(providerChainId);
    if (options) {
        const savedParams = {
            optionalChains: options.walletConnect?.optionalChains,
            chain: options.chain,
            pairingTopic: options.walletConnect?.pairingTopic,
        };
        if (asyncLocalStorage) {
            (0, walletStorage_js_1.saveConnectParamsToStorage)(asyncLocalStorage, walletId, savedParams);
        }
    }
    if (wcOptions?.onDisplayUri) {
        provider.events.removeListener("display_uri", wcOptions.onDisplayUri);
    }
    return onConnect(address, chain, provider, emitter);
}
exports.connectWC = connectWC;
/**
 * Auto connect to already connected wallet connect session.
 * @internal
 */
async function autoConnectWC(options, emitter, walletId) {
    const savedConnectParams = asyncLocalStorage
        ? await (0, walletStorage_js_1.getSavedConnectParamsFromStorage)(asyncLocalStorage, walletId)
        : null;
    const provider = await initProvider(savedConnectParams
        ? {
            chain: savedConnectParams.chain,
            client: options.client,
            walletConnect: {
                pairingTopic: savedConnectParams.pairingTopic,
                optionalChains: savedConnectParams.optionalChains,
            },
        }
        : {
            client: options.client,
            walletConnect: {},
        }, walletId, true);
    const address = provider.accounts[0];
    if (!address) {
        throw new Error("No accounts found on provider.");
    }
    const providerChainId = (0, normalizeChainId_js_1.normalizeChainId)(provider.chainId);
    const chain = options.chain && options.chain.id === providerChainId
        ? options.chain
        : (0, utils_js_1.getCachedChain)(providerChainId);
    return onConnect(address, chain, provider, emitter);
}
exports.autoConnectWC = autoConnectWC;
// Connection utils -----------------------------------------------------------------------------------------------
async function initProvider(options, walletId, isAutoConnect = false) {
    const walletInfo = await (0, getWalletInfo_js_1.getWalletInfo)(walletId);
    const wcOptions = options.walletConnect;
    const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await Promise.resolve().then(() => require("@walletconnect/ethereum-provider"));
    const { rpcMap, chainsToRequest } = getChainsToRequest({
        client: options.client,
        chain: options.chain,
        optionalChains: options.walletConnect?.optionalChains,
    });
    const provider = await EthereumProvider.init({
        showQrModal: (0, platform_js_1.isReactNative)()
            ? false
            : wcOptions?.showQrModal === undefined
                ? defaultShowQrModal
                : wcOptions.showQrModal,
        projectId: wcOptions?.projectId || constants_js_1.DEFAULT_PROJECT_ID,
        optionalMethods: OPTIONAL_METHODS,
        optionalEvents: OPTIONAL_EVENTS,
        optionalChains: chainsToRequest,
        chains: options.chain
            ? [options.chain.id]
            : chainsToRequest.length > 0
                ? [chainsToRequest[0]]
                : [1],
        metadata: {
            name: wcOptions?.appMetadata?.name || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().name,
            description: wcOptions?.appMetadata?.description ||
                (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().description,
            url: wcOptions?.appMetadata?.url || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().url,
            icons: [
                wcOptions?.appMetadata?.logoUrl || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().logoUrl,
            ],
        },
        rpcMap: rpcMap,
        qrModalOptions: wcOptions?.qrModalOptions,
        disableProviderPing: true,
    });
    provider.events.setMaxListeners(Number.POSITIVE_INFINITY);
    // disconnect the provider if chains are stale when (if not auto connecting)
    if (!isAutoConnect) {
        // const isStale = await isChainsStale(provider, chainsToRequest);
        if (provider.session) {
            await provider.disconnect();
        }
    }
    if (walletId !== "walletConnect") {
        function handleSessionRequest() {
            const preferNative = provider.session?.peer?.metadata?.redirect?.native ||
                walletInfo.mobile.native ||
                walletInfo.mobile.universal;
            if ((0, platform_js_1.isReactNative)()) {
                const { Linking } = require("react-native");
                if (!preferNative) {
                    throw new Error("No app url found for wallet connect to redirect to.");
                }
                Linking.openURL(preferNative);
                return;
            }
            if (!(0, isMobile_js_1.isMobile)()) {
                return;
            }
            if ((0, isMobile_js_1.isAndroid)()) {
                if (preferNative) {
                    (0, openWindow_js_1.openWindow)(preferNative);
                }
            }
            else if ((0, isMobile_js_1.isIOS)()) {
                if (preferNative) {
                    (0, openWindow_js_1.openWindow)(preferNative);
                }
            }
            else {
                const preferUniversal = walletInfo.mobile.universal || walletInfo.mobile.native;
                if (preferUniversal) {
                    (0, openWindow_js_1.openWindow)(preferUniversal);
                }
            }
        }
        provider.signer.client.on("session_request_sent", handleSessionRequest);
        provider.events.addListener("disconnect", () => {
            provider.signer.client.off("session_request_sent", handleSessionRequest);
        });
    }
    return provider;
}
function createAccount(provider, address) {
    const account = {
        address,
        async sendTransaction(tx) {
            const transactionHash = (await provider.request({
                method: "eth_sendTransaction",
                params: [
                    {
                        gas: tx.gas ? (0, hex_js_1.numberToHex)(tx.gas) : undefined,
                        value: tx.value ? (0, hex_js_1.numberToHex)(tx.value) : undefined,
                        from: this.address,
                        to: tx.to,
                        data: tx.data,
                    },
                ],
            }));
            return {
                transactionHash,
            };
        },
        async signMessage({ message }) {
            const messageToSign = (() => {
                if (typeof message === "string") {
                    return (0, hex_js_1.stringToHex)(message);
                }
                if (message.raw instanceof Uint8Array) {
                    return (0, hex_js_1.uint8ArrayToHex)(message.raw);
                }
                return message.raw;
            })();
            return provider.request({
                method: "personal_sign",
                params: [messageToSign, this.address],
            });
        },
        async signTypedData(_data) {
            const data = (0, parseTypedData_js_1.parseTypedData)(_data);
            const { domain, message, primaryType } = data;
            const types = {
                EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({ domain }),
                ...data.types,
            };
            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
            // as we can't statically check this with TypeScript.
            (0, viem_1.validateTypedData)({ domain, message, primaryType, types });
            const typedData = (0, json_js_1.stringify)({ domain: domain ?? {}, message, primaryType, types }, (_, value) => ((0, hex_js_1.isHex)(value) ? value.toLowerCase() : value));
            return await provider.request({
                method: "eth_signTypedData_v4",
                params: [this.address, typedData],
            });
        },
    };
    return account;
}
function onConnect(address, chain, provider, emitter) {
    const account = createAccount(provider, address);
    async function disconnect() {
        provider.removeListener("accountsChanged", onAccountsChanged);
        provider.removeListener("chainChanged", onChainChanged);
        provider.removeListener("disconnect", onDisconnect);
        await provider.disconnect();
    }
    function onDisconnect() {
        setRequestedChainsIds([]);
        asyncLocalStorage?.removeItem(storageKeys.lastUsedChainId);
        disconnect();
        emitter.emit("disconnect", undefined);
    }
    function onAccountsChanged(accounts) {
        if (accounts[0]) {
            const newAccount = createAccount(provider, (0, address_js_1.getAddress)(accounts[0]));
            emitter.emit("accountChanged", newAccount);
            emitter.emit("accountsChanged", accounts);
        }
        else {
            onDisconnect();
        }
    }
    function onChainChanged(newChainId) {
        const newChain = (0, utils_js_1.getCachedChain)((0, normalizeChainId_js_1.normalizeChainId)(newChainId));
        emitter.emit("chainChanged", newChain);
        asyncLocalStorage?.setItem(storageKeys.lastUsedChainId, String(newChainId));
    }
    provider.on("accountsChanged", onAccountsChanged);
    provider.on("chainChanged", onChainChanged);
    provider.on("disconnect", onDisconnect);
    provider.on("session_delete", onDisconnect);
    return [
        account,
        chain,
        disconnect,
        (newChain) => switchChainWC(provider, newChain),
    ];
}
// Storage utils  -----------------------------------------------------------------------------------------------
function getNamespaceMethods(provider) {
    return provider.session?.namespaces[constants_js_1.NAMESPACE]?.methods || [];
}
function getNamespaceChainsIds(provider) {
    const chainIds = provider.session?.namespaces[constants_js_1.NAMESPACE]?.chains?.map((chain) => Number.parseInt(chain.split(":")[1] || ""));
    return chainIds ?? [];
}
async function switchChainWC(provider, chain) {
    const chainId = chain.id;
    try {
        const namespaceChains = getNamespaceChainsIds(provider);
        const namespaceMethods = getNamespaceMethods(provider);
        const isChainApproved = namespaceChains.includes(chainId);
        if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
            const apiChain = await (0, utils_js_1.getChainMetadata)(chain);
            await provider.request({
                method: ADD_ETH_CHAIN_METHOD,
                params: [
                    {
                        chainId: (0, hex_js_1.numberToHex)(apiChain.chainId),
                        chainName: apiChain.name,
                        nativeCurrency: apiChain.nativeCurrency,
                        rpcUrls: (0, chains_js_1.getValidPublicRPCUrl)(apiChain), // no clientId on purpose
                        blockExplorerUrls: chain.blockExplorers?.slice(0, 1) ||
                            apiChain.explorers?.slice(0, 1) ||
                            [],
                    },
                ],
            });
            const requestedChains = await getRequestedChainsIds();
            requestedChains.push(chainId);
            setRequestedChainsIds(requestedChains);
        }
        await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: (0, hex_js_1.numberToHex)(chainId) }],
        });
    }
    catch (error) {
        const message = typeof error === "string" ? error : error?.message;
        if (/user rejected request/i.test(message)) {
            throw new viem_1.UserRejectedRequestError(error);
        }
        throw new viem_1.SwitchChainError(error);
    }
}
/**
 * Set the requested chains to the storage.
 * @internal
 */
function setRequestedChainsIds(chains) {
    asyncLocalStorage?.setItem(storageKeys.requestedChains, JSON.stringify(chains));
}
/**
 * Get the last requested chains from the storage.
 * @internal
 */
async function getRequestedChainsIds() {
    const data = await asyncLocalStorage?.getItem(storageKeys.requestedChains);
    return data ? JSON.parse(data) : [];
}
function getChainsToRequest(options) {
    const rpcMap = {};
    if (options.chain) {
        rpcMap[options.chain.id] = (0, utils_js_1.getRpcUrlForChain)({
            chain: options.chain,
            client: options.client,
        });
    }
    // limit optional chains to 10
    const optionalChains = (options?.optionalChains || []).slice(0, 10);
    for (const chain of optionalChains) {
        rpcMap[chain.id] = (0, utils_js_1.getRpcUrlForChain)({
            chain: chain,
            client: options.client,
        });
    }
    const optionalChainIds = optionalChains.map((c) => c.id) || [];
    const chainsToRequest = options.chain
        ? [options.chain.id, ...optionalChainIds]
        : optionalChainIds.length > 0
            ? optionalChainIds
            : [1];
    if (!options.chain && optionalChains.length === 0) {
        rpcMap[1] = (0, utils_js_1.getCachedChain)(1).rpc;
    }
    return {
        rpcMap,
        chainsToRequest,
    };
}
//# sourceMappingURL=controller.js.map