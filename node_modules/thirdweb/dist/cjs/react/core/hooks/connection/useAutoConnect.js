"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAutoConnect = void 0;
const react_query_1 = require("@tanstack/react-query");
const create_wallet_js_1 = require("../../../../wallets/create-wallet.js");
const mipdStore_js_1 = require("../../../../wallets/injected/mipdStore.js");
const index_js_1 = require("../../../../wallets/manager/index.js");
const connectionManager_js_1 = require("../../connectionManager.js");
const storage_js_1 = require("../../storage.js");
const timeoutPromise_js_1 = require("../../utils/timeoutPromise.js");
const wallet_hooks_js_1 = require("../wallets/wallet-hooks.js");
/**
 * Autoconnect the last previously connected wallet.
 *
 * @example
 * ```tsx
 * import { useAutoConnect } from "thirdweb/react";
 *
 * const { data: autoConnected, isLoading } = useAutoConnect({
 *  client,
 *  accountAbstraction,
 *  wallets,
 *  onConnect,
 *  timeout,
 * });
 * ```
 * @walletConnection
 * @param props - The props for auto connect.
 * @returns whether the auto connect was successful.
 */
function useAutoConnect(props) {
    const setConnectionStatus = (0, wallet_hooks_js_1.useSetActiveWalletConnectionStatus)();
    const { connect } = (0, wallet_hooks_js_1.useConnect)({
        client: props.client,
        accountAbstraction: props.accountAbstraction,
    });
    const { isAutoConnecting } = connectionManager_js_1.connectionManager;
    const { wallets, onConnect } = props;
    const timeout = props.timeout ?? 15000;
    // get the supported wallets from thirdweb provider
    // check the storage for last connected wallets and connect them all
    // check the storage for last active wallet and set it as active
    const autoConnect = async () => {
        let autoConnected = false;
        isAutoConnecting.setValue(true);
        const asyncLocalStorage = (0, storage_js_1.getStorage)();
        const [lastConnectedWalletIds, lastActiveWalletId] = await Promise.all([
            (0, index_js_1.getStoredConnectedWalletIds)(asyncLocalStorage),
            (0, index_js_1.getStoredActiveWalletId)(asyncLocalStorage),
        ]);
        // if no wallets were last connected
        if (!lastConnectedWalletIds) {
            return autoConnected;
        }
        const lastConnectedChain = await (0, index_js_1.getLastConnectedChain)(asyncLocalStorage);
        async function handleWalletConnection(wallet) {
            return wallet.autoConnect({
                client: props.client,
                chain: lastConnectedChain ?? undefined,
            });
        }
        const availableWallets = [
            ...wallets,
            ...(0, mipdStore_js_1.getInstalledWalletProviders)().map((p) => (0, create_wallet_js_1.createWallet)(p.info.rdns)),
        ];
        const activeWallet = lastActiveWalletId &&
            availableWallets.find((w) => w.id === lastActiveWalletId);
        if (activeWallet) {
            try {
                setConnectionStatus("connecting"); // only set connecting status if we are connecting the last active EOA
                await (0, timeoutPromise_js_1.timeoutPromise)(handleWalletConnection(activeWallet), {
                    ms: timeout,
                    message: `AutoConnect timeout : ${timeout}ms limit exceeded.`,
                });
                // connected wallet could be activeWallet or smart wallet
                const connectedWallet = await connect(activeWallet);
                if (connectedWallet) {
                    if (onConnect) {
                        try {
                            onConnect(connectedWallet);
                            autoConnected = true;
                        }
                        catch {
                            // ignore
                        }
                    }
                }
                else {
                    setConnectionStatus("disconnected");
                }
            }
            catch (e) {
                console.error("Failed to auto connect last active wallet");
                console.error(e);
                setConnectionStatus("disconnected");
            }
        }
        else {
            setConnectionStatus("disconnected");
        }
        // then connect wallets that were last connected but were not set as active
        const otherWallets = wallets.filter((w) => w.id !== lastActiveWalletId && lastConnectedWalletIds.includes(w.id));
        for (const wallet of otherWallets) {
            try {
                await handleWalletConnection(wallet);
                connectionManager_js_1.connectionManager.addConnectedWallet(wallet);
            }
            catch (e) {
                console.error("Failed to auto connect a non-active connected wallet");
                console.error(e);
            }
        }
        isAutoConnecting.setValue(false);
        return autoConnected; // useQuery needs a return value
    };
    // trigger the auto connect on first mount only
    const query = (0, react_query_1.useQuery)({
        queryKey: ["autoConnect", props.client.clientId],
        queryFn: autoConnect,
        refetchOnMount: false,
    });
    return query;
}
exports.useAutoConnect = useAutoConnect;
//# sourceMappingURL=useAutoConnect.js.map