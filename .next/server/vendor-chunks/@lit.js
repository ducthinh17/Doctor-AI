"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lit";
exports.ids = ["vendor-chunks/@lit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/css-tag.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/css-tag.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSResult: () => (/* binding */ CSSResult),\n/* harmony export */   adoptStyles: () => (/* binding */ adoptStyles),\n/* harmony export */   css: () => (/* binding */ css),\n/* harmony export */   getCompatibleStyle: () => (/* binding */ getCompatibleStyle),\n/* harmony export */   supportsAdoptingStyleSheets: () => (/* binding */ supportsAdoptingStyleSheets),\n/* harmony export */   unsafeCSS: () => (/* binding */ unsafeCSS)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const global = globalThis;\n/**\n * Whether the current browser supports `adoptedStyleSheets`.\n */ const supportsAdoptingStyleSheets = global.ShadowRoot && (global.ShadyCSS === undefined || global.ShadyCSS.nativeShadow) && \"adoptedStyleSheets\" in Document.prototype && \"replace\" in CSSStyleSheet.prototype;\nconst constructionToken = Symbol();\nconst cssTagCache = new WeakMap();\n/**\n * A container for a string of CSS text, that may be used to create a CSSStyleSheet.\n *\n * CSSResult is the return value of `css`-tagged template literals and\n * `unsafeCSS()`. In order to ensure that CSSResults are only created via the\n * `css` tag and `unsafeCSS()`, CSSResult cannot be constructed directly.\n */ class CSSResult {\n    constructor(cssText, strings, safeToken){\n        // This property needs to remain unminified.\n        this[\"_$cssResult$\"] = true;\n        if (safeToken !== constructionToken) {\n            throw new Error(\"CSSResult is not constructable. Use `unsafeCSS` or `css` instead.\");\n        }\n        this.cssText = cssText;\n        this._strings = strings;\n    }\n    // This is a getter so that it's lazy. In practice, this means stylesheets\n    // are not created until the first element instance is made.\n    get styleSheet() {\n        // If `supportsAdoptingStyleSheets` is true then we assume CSSStyleSheet is\n        // constructable.\n        let styleSheet = this._styleSheet;\n        const strings = this._strings;\n        if (supportsAdoptingStyleSheets && styleSheet === undefined) {\n            const cacheable = strings !== undefined && strings.length === 1;\n            if (cacheable) {\n                styleSheet = cssTagCache.get(strings);\n            }\n            if (styleSheet === undefined) {\n                (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(this.cssText);\n                if (cacheable) {\n                    cssTagCache.set(strings, styleSheet);\n                }\n            }\n        }\n        return styleSheet;\n    }\n    toString() {\n        return this.cssText;\n    }\n}\nconst textFromCSSResult = (value)=>{\n    // This property needs to remain unminified.\n    if (value[\"_$cssResult$\"] === true) {\n        return value.cssText;\n    } else if (typeof value === \"number\") {\n        return value;\n    } else {\n        throw new Error(`Value passed to 'css' function must be a 'css' function result: ` + `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` + `to ensure page security.`);\n    }\n};\n/**\n * Wrap a value for interpolation in a {@linkcode css} tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */ const unsafeCSS = (value)=>new CSSResult(typeof value === \"string\" ? value : String(value), undefined, constructionToken);\n/**\n * A template literal tag which can be used with LitElement's\n * {@linkcode LitElement.styles} property to set element styles.\n *\n * For security reasons, only literal string values and number may be used in\n * embedded expressions. To incorporate non-literal values {@linkcode unsafeCSS}\n * may be used inside an expression.\n */ const css = (strings, ...values)=>{\n    const cssText = strings.length === 1 ? strings[0] : values.reduce((acc, v, idx)=>acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);\n    return new CSSResult(cssText, strings, constructionToken);\n};\n/**\n * Applies the given styles to a `shadowRoot`. When Shadow DOM is\n * available but `adoptedStyleSheets` is not, styles are appended to the\n * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n * Note, when shimming is used, any styles that are subsequently placed into\n * the shadowRoot should be placed *before* any shimmed adopted styles. This\n * will match spec behavior that gives adopted sheets precedence over styles in\n * shadowRoot.\n */ const adoptStyles = (renderRoot, styles)=>{\n    if (supportsAdoptingStyleSheets) {\n        renderRoot.adoptedStyleSheets = styles.map((s)=>s instanceof CSSStyleSheet ? s : s.styleSheet);\n    } else {\n        styles.forEach((s)=>{\n            const style = document.createElement(\"style\");\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const nonce = global[\"litNonce\"];\n            if (nonce !== undefined) {\n                style.setAttribute(\"nonce\", nonce);\n            }\n            style.textContent = s.cssText;\n            renderRoot.appendChild(style);\n        });\n    }\n};\nconst cssResultFromStyleSheet = (sheet)=>{\n    let cssText = \"\";\n    for (const rule of sheet.cssRules){\n        cssText += rule.cssText;\n    }\n    return unsafeCSS(cssText);\n};\nconst getCompatibleStyle = supportsAdoptingStyleSheets || global.CSSStyleSheet === undefined ? (s)=>s : (s)=>s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;\n //# sourceMappingURL=css-tag.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvY3NzLXRhZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0QsTUFBTUEsU0FBU0M7QUFDZjs7Q0FFQyxHQUNELE1BQU1DLDhCQUE4QkYsT0FBT0csVUFBVSxJQUNoREgsQ0FBQUEsT0FBT0ksUUFBUSxLQUFLQyxhQUFhTCxPQUFPSSxRQUFRLENBQUNFLFlBQVksS0FDOUQsd0JBQXdCQyxTQUFTQyxTQUFTLElBQzFDLGFBQWFDLGNBQWNELFNBQVM7QUFDeEMsTUFBTUUsb0JBQW9CQztBQUMxQixNQUFNQyxjQUFjLElBQUlDO0FBQ3hCOzs7Ozs7Q0FNQyxHQUNELE1BQU1DO0lBQ0ZDLFlBQVlDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxTQUFTLENBQUU7UUFDckMsNENBQTRDO1FBQzVDLElBQUksQ0FBQyxlQUFlLEdBQUc7UUFDdkIsSUFBSUEsY0FBY1IsbUJBQW1CO1lBQ2pDLE1BQU0sSUFBSVMsTUFBTTtRQUNwQjtRQUNBLElBQUksQ0FBQ0gsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0ksUUFBUSxHQUFHSDtJQUNwQjtJQUNBLDBFQUEwRTtJQUMxRSw0REFBNEQ7SUFDNUQsSUFBSUksYUFBYTtRQUNiLDJFQUEyRTtRQUMzRSxpQkFBaUI7UUFDakIsSUFBSUEsYUFBYSxJQUFJLENBQUNDLFdBQVc7UUFDakMsTUFBTUwsVUFBVSxJQUFJLENBQUNHLFFBQVE7UUFDN0IsSUFBSWxCLCtCQUErQm1CLGVBQWVoQixXQUFXO1lBQ3pELE1BQU1rQixZQUFZTixZQUFZWixhQUFhWSxRQUFRTyxNQUFNLEtBQUs7WUFDOUQsSUFBSUQsV0FBVztnQkFDWEYsYUFBYVQsWUFBWWEsR0FBRyxDQUFDUjtZQUNqQztZQUNBLElBQUlJLGVBQWVoQixXQUFXO2dCQUN6QixLQUFJLENBQUNpQixXQUFXLEdBQUdELGFBQWEsSUFBSVosZUFBYyxFQUFHaUIsV0FBVyxDQUFDLElBQUksQ0FBQ1YsT0FBTztnQkFDOUUsSUFBSU8sV0FBVztvQkFDWFgsWUFBWWUsR0FBRyxDQUFDVixTQUFTSTtnQkFDN0I7WUFDSjtRQUNKO1FBQ0EsT0FBT0E7SUFDWDtJQUNBTyxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUNaLE9BQU87SUFDdkI7QUFDSjtBQUNBLE1BQU1hLG9CQUFvQixDQUFDQztJQUN2Qiw0Q0FBNEM7SUFDNUMsSUFBSUEsS0FBSyxDQUFDLGVBQWUsS0FBSyxNQUFNO1FBQ2hDLE9BQU9BLE1BQU1kLE9BQU87SUFDeEIsT0FDSyxJQUFJLE9BQU9jLFVBQVUsVUFBVTtRQUNoQyxPQUFPQTtJQUNYLE9BQ0s7UUFDRCxNQUFNLElBQUlYLE1BQU0sQ0FBQyxnRUFBZ0UsQ0FBQyxHQUM5RSxDQUFDLEVBQUVXLE1BQU0sNERBQTRELENBQUMsR0FDdEUsQ0FBQyx3QkFBd0IsQ0FBQztJQUNsQztBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsTUFBTUMsWUFBWSxDQUFDRCxRQUFVLElBQUloQixVQUFVLE9BQU9nQixVQUFVLFdBQVdBLFFBQVFFLE9BQU9GLFFBQVF6QixXQUFXSztBQUN6Rzs7Ozs7OztDQU9DLEdBQ0QsTUFBTXVCLE1BQU0sQ0FBQ2hCLFNBQVMsR0FBR2lCO0lBQ3JCLE1BQU1sQixVQUFVQyxRQUFRTyxNQUFNLEtBQUssSUFDN0JQLE9BQU8sQ0FBQyxFQUFFLEdBQ1ZpQixPQUFPQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsR0FBR0MsTUFBUUYsTUFBTVAsa0JBQWtCUSxLQUFLcEIsT0FBTyxDQUFDcUIsTUFBTSxFQUFFLEVBQUVyQixPQUFPLENBQUMsRUFBRTtJQUM5RixPQUFPLElBQUlILFVBQVVFLFNBQVNDLFNBQVNQO0FBQzNDO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNNkIsY0FBYyxDQUFDQyxZQUFZQztJQUM3QixJQUFJdkMsNkJBQTZCO1FBQzdCc0MsV0FBV0Usa0JBQWtCLEdBQUdELE9BQU9FLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxhQUFhbkMsZ0JBQWdCbUMsSUFBSUEsRUFBRXZCLFVBQVU7SUFDbkcsT0FDSztRQUNEb0IsT0FBT0ksT0FBTyxDQUFDLENBQUNEO1lBQ1osTUFBTUUsUUFBUUMsU0FBU0MsYUFBYSxDQUFDO1lBQ3JDLDhEQUE4RDtZQUM5RCxNQUFNQyxRQUFRakQsTUFBTSxDQUFDLFdBQVc7WUFDaEMsSUFBSWlELFVBQVU1QyxXQUFXO2dCQUNyQnlDLE1BQU1JLFlBQVksQ0FBQyxTQUFTRDtZQUNoQztZQUNBSCxNQUFNSyxXQUFXLEdBQUdQLEVBQUU1QixPQUFPO1lBQzdCd0IsV0FBV1ksV0FBVyxDQUFDTjtRQUMzQjtJQUNKO0FBQ0o7QUFDQSxNQUFNTywwQkFBMEIsQ0FBQ0M7SUFDN0IsSUFBSXRDLFVBQVU7SUFDZCxLQUFLLE1BQU11QyxRQUFRRCxNQUFNRSxRQUFRLENBQUU7UUFDL0J4QyxXQUFXdUMsS0FBS3ZDLE9BQU87SUFDM0I7SUFDQSxPQUFPZSxVQUFVZjtBQUNyQjtBQUNBLE1BQU15QyxxQkFBcUJ2RCwrQkFDdEJGLE9BQU9TLGFBQWEsS0FBS0osWUFDeEIsQ0FBQ3VDLElBQU1BLElBQ1AsQ0FBQ0EsSUFBTUEsYUFBYW5DLGdCQUFnQjRDLHdCQUF3QlQsS0FBS0E7QUFFNEIsQ0FDbkcsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2Nzcy10YWcuanM/MmUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbmNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXMgO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgYGFkb3B0ZWRTdHlsZVNoZWV0c2AuXG4gKi9cbmNvbnN0IHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cyA9IGdsb2JhbC5TaGFkb3dSb290ICYmXG4gICAgKGdsb2JhbC5TaGFkeUNTUyA9PT0gdW5kZWZpbmVkIHx8IGdsb2JhbC5TaGFkeUNTUy5uYXRpdmVTaGFkb3cpICYmXG4gICAgJ2Fkb3B0ZWRTdHlsZVNoZWV0cycgaW4gRG9jdW1lbnQucHJvdG90eXBlICYmXG4gICAgJ3JlcGxhY2UnIGluIENTU1N0eWxlU2hlZXQucHJvdG90eXBlO1xuY29uc3QgY29uc3RydWN0aW9uVG9rZW4gPSBTeW1ib2woKTtcbmNvbnN0IGNzc1RhZ0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQSBjb250YWluZXIgZm9yIGEgc3RyaW5nIG9mIENTUyB0ZXh0LCB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZSBhIENTU1N0eWxlU2hlZXQuXG4gKlxuICogQ1NTUmVzdWx0IGlzIHRoZSByZXR1cm4gdmFsdWUgb2YgYGNzc2AtdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxzIGFuZFxuICogYHVuc2FmZUNTUygpYC4gSW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgQ1NTUmVzdWx0cyBhcmUgb25seSBjcmVhdGVkIHZpYSB0aGVcbiAqIGBjc3NgIHRhZyBhbmQgYHVuc2FmZUNTUygpYCwgQ1NTUmVzdWx0IGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS5cbiAqL1xuY2xhc3MgQ1NTUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcihjc3NUZXh0LCBzdHJpbmdzLCBzYWZlVG9rZW4pIHtcbiAgICAgICAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byByZW1haW4gdW5taW5pZmllZC5cbiAgICAgICAgdGhpc1snXyRjc3NSZXN1bHQkJ10gPSB0cnVlO1xuICAgICAgICBpZiAoc2FmZVRva2VuICE9PSBjb25zdHJ1Y3Rpb25Ub2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1NSZXN1bHQgaXMgbm90IGNvbnN0cnVjdGFibGUuIFVzZSBgdW5zYWZlQ1NTYCBvciBgY3NzYCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIHRoaXMuX3N0cmluZ3MgPSBzdHJpbmdzO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIGEgZ2V0dGVyIHNvIHRoYXQgaXQncyBsYXp5LiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyBzdHlsZXNoZWV0c1xuICAgIC8vIGFyZSBub3QgY3JlYXRlZCB1bnRpbCB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZSBpcyBtYWRlLlxuICAgIGdldCBzdHlsZVNoZWV0KCkge1xuICAgICAgICAvLyBJZiBgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzYCBpcyB0cnVlIHRoZW4gd2UgYXNzdW1lIENTU1N0eWxlU2hlZXQgaXNcbiAgICAgICAgLy8gY29uc3RydWN0YWJsZS5cbiAgICAgICAgbGV0IHN0eWxlU2hlZXQgPSB0aGlzLl9zdHlsZVNoZWV0O1xuICAgICAgICBjb25zdCBzdHJpbmdzID0gdGhpcy5fc3RyaW5ncztcbiAgICAgICAgaWYgKHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cyAmJiBzdHlsZVNoZWV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlYWJsZSA9IHN0cmluZ3MgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmdzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIGlmIChjYWNoZWFibGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0ID0gY3NzVGFnQ2FjaGUuZ2V0KHN0cmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlU2hlZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICh0aGlzLl9zdHlsZVNoZWV0ID0gc3R5bGVTaGVldCA9IG5ldyBDU1NTdHlsZVNoZWV0KCkpLnJlcGxhY2VTeW5jKHRoaXMuY3NzVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBjc3NUYWdDYWNoZS5zZXQoc3RyaW5ncywgc3R5bGVTaGVldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZVNoZWV0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzVGV4dDtcbiAgICB9XG59XG5jb25zdCB0ZXh0RnJvbUNTU1Jlc3VsdCA9ICh2YWx1ZSkgPT4ge1xuICAgIC8vIFRoaXMgcHJvcGVydHkgbmVlZHMgdG8gcmVtYWluIHVubWluaWZpZWQuXG4gICAgaWYgKHZhbHVlWydfJGNzc1Jlc3VsdCQnXSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuY3NzVGV4dDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIHBhc3NlZCB0byAnY3NzJyBmdW5jdGlvbiBtdXN0IGJlIGEgJ2NzcycgZnVuY3Rpb24gcmVzdWx0OiBgICtcbiAgICAgICAgICAgIGAke3ZhbHVlfS4gVXNlICd1bnNhZmVDU1MnIHRvIHBhc3Mgbm9uLWxpdGVyYWwgdmFsdWVzLCBidXQgdGFrZSBjYXJlIGAgK1xuICAgICAgICAgICAgYHRvIGVuc3VyZSBwYWdlIHNlY3VyaXR5LmApO1xuICAgIH1cbn07XG4vKipcbiAqIFdyYXAgYSB2YWx1ZSBmb3IgaW50ZXJwb2xhdGlvbiBpbiBhIHtAbGlua2NvZGUgY3NzfSB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqXG4gKiBUaGlzIGlzIHVuc2FmZSBiZWNhdXNlIHVudHJ1c3RlZCBDU1MgdGV4dCBjYW4gYmUgdXNlZCB0byBwaG9uZSBob21lXG4gKiBvciBleGZpbHRyYXRlIGRhdGEgdG8gYW4gYXR0YWNrZXIgY29udHJvbGxlZCBzaXRlLiBUYWtlIGNhcmUgdG8gb25seSB1c2VcbiAqIHRoaXMgd2l0aCB0cnVzdGVkIGlucHV0LlxuICovXG5jb25zdCB1bnNhZmVDU1MgPSAodmFsdWUpID0+IG5ldyBDU1NSZXN1bHQodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogU3RyaW5nKHZhbHVlKSwgdW5kZWZpbmVkLCBjb25zdHJ1Y3Rpb25Ub2tlbik7XG4vKipcbiAqIEEgdGVtcGxhdGUgbGl0ZXJhbCB0YWcgd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCBMaXRFbGVtZW50J3NcbiAqIHtAbGlua2NvZGUgTGl0RWxlbWVudC5zdHlsZXN9IHByb3BlcnR5IHRvIHNldCBlbGVtZW50IHN0eWxlcy5cbiAqXG4gKiBGb3Igc2VjdXJpdHkgcmVhc29ucywgb25seSBsaXRlcmFsIHN0cmluZyB2YWx1ZXMgYW5kIG51bWJlciBtYXkgYmUgdXNlZCBpblxuICogZW1iZWRkZWQgZXhwcmVzc2lvbnMuIFRvIGluY29ycG9yYXRlIG5vbi1saXRlcmFsIHZhbHVlcyB7QGxpbmtjb2RlIHVuc2FmZUNTU31cbiAqIG1heSBiZSB1c2VkIGluc2lkZSBhbiBleHByZXNzaW9uLlxuICovXG5jb25zdCBjc3MgPSAoc3RyaW5ncywgLi4udmFsdWVzKSA9PiB7XG4gICAgY29uc3QgY3NzVGV4dCA9IHN0cmluZ3MubGVuZ3RoID09PSAxXG4gICAgICAgID8gc3RyaW5nc1swXVxuICAgICAgICA6IHZhbHVlcy5yZWR1Y2UoKGFjYywgdiwgaWR4KSA9PiBhY2MgKyB0ZXh0RnJvbUNTU1Jlc3VsdCh2KSArIHN0cmluZ3NbaWR4ICsgMV0sIHN0cmluZ3NbMF0pO1xuICAgIHJldHVybiBuZXcgQ1NTUmVzdWx0KGNzc1RleHQsIHN0cmluZ3MsIGNvbnN0cnVjdGlvblRva2VuKTtcbn07XG4vKipcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIHN0eWxlcyB0byBhIGBzaGFkb3dSb290YC4gV2hlbiBTaGFkb3cgRE9NIGlzXG4gKiBhdmFpbGFibGUgYnV0IGBhZG9wdGVkU3R5bGVTaGVldHNgIGlzIG5vdCwgc3R5bGVzIGFyZSBhcHBlbmRlZCB0byB0aGVcbiAqIGBzaGFkb3dSb290YCB0byBbbWltaWMgc3BlYyBiZWhhdmlvcl0oaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb25zdHJ1Y3Qtc3R5bGVzaGVldHMvI3VzaW5nLWNvbnN0cnVjdGVkLXN0eWxlc2hlZXRzKS5cbiAqIE5vdGUsIHdoZW4gc2hpbW1pbmcgaXMgdXNlZCwgYW55IHN0eWxlcyB0aGF0IGFyZSBzdWJzZXF1ZW50bHkgcGxhY2VkIGludG9cbiAqIHRoZSBzaGFkb3dSb290IHNob3VsZCBiZSBwbGFjZWQgKmJlZm9yZSogYW55IHNoaW1tZWQgYWRvcHRlZCBzdHlsZXMuIFRoaXNcbiAqIHdpbGwgbWF0Y2ggc3BlYyBiZWhhdmlvciB0aGF0IGdpdmVzIGFkb3B0ZWQgc2hlZXRzIHByZWNlZGVuY2Ugb3ZlciBzdHlsZXMgaW5cbiAqIHNoYWRvd1Jvb3QuXG4gKi9cbmNvbnN0IGFkb3B0U3R5bGVzID0gKHJlbmRlclJvb3QsIHN0eWxlcykgPT4ge1xuICAgIGlmIChzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMpIHtcbiAgICAgICAgcmVuZGVyUm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBzdHlsZXMubWFwKChzKSA9PiBzIGluc3RhbmNlb2YgQ1NTU3R5bGVTaGVldCA/IHMgOiBzLnN0eWxlU2hlZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGdsb2JhbFsnbGl0Tm9uY2UnXTtcbiAgICAgICAgICAgIGlmIChub25jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gcy5jc3NUZXh0O1xuICAgICAgICAgICAgcmVuZGVyUm9vdC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCBjc3NSZXN1bHRGcm9tU3R5bGVTaGVldCA9IChzaGVldCkgPT4ge1xuICAgIGxldCBjc3NUZXh0ID0gJyc7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHNoZWV0LmNzc1J1bGVzKSB7XG4gICAgICAgIGNzc1RleHQgKz0gcnVsZS5jc3NUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdW5zYWZlQ1NTKGNzc1RleHQpO1xufTtcbmNvbnN0IGdldENvbXBhdGlibGVTdHlsZSA9IHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cyB8fFxuICAgIChnbG9iYWwuQ1NTU3R5bGVTaGVldCA9PT0gdW5kZWZpbmVkKVxuICAgID8gKHMpID0+IHNcbiAgICA6IChzKSA9PiBzIGluc3RhbmNlb2YgQ1NTU3R5bGVTaGVldCA/IGNzc1Jlc3VsdEZyb21TdHlsZVNoZWV0KHMpIDogcztcblxuZXhwb3J0IHsgQ1NTUmVzdWx0LCBhZG9wdFN0eWxlcywgY3NzLCBnZXRDb21wYXRpYmxlU3R5bGUsIHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cywgdW5zYWZlQ1NTIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtdGFnLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdsb2JhbCIsImdsb2JhbFRoaXMiLCJzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMiLCJTaGFkb3dSb290IiwiU2hhZHlDU1MiLCJ1bmRlZmluZWQiLCJuYXRpdmVTaGFkb3ciLCJEb2N1bWVudCIsInByb3RvdHlwZSIsIkNTU1N0eWxlU2hlZXQiLCJjb25zdHJ1Y3Rpb25Ub2tlbiIsIlN5bWJvbCIsImNzc1RhZ0NhY2hlIiwiV2Vha01hcCIsIkNTU1Jlc3VsdCIsImNvbnN0cnVjdG9yIiwiY3NzVGV4dCIsInN0cmluZ3MiLCJzYWZlVG9rZW4iLCJFcnJvciIsIl9zdHJpbmdzIiwic3R5bGVTaGVldCIsIl9zdHlsZVNoZWV0IiwiY2FjaGVhYmxlIiwibGVuZ3RoIiwiZ2V0IiwicmVwbGFjZVN5bmMiLCJzZXQiLCJ0b1N0cmluZyIsInRleHRGcm9tQ1NTUmVzdWx0IiwidmFsdWUiLCJ1bnNhZmVDU1MiLCJTdHJpbmciLCJjc3MiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJhY2MiLCJ2IiwiaWR4IiwiYWRvcHRTdHlsZXMiLCJyZW5kZXJSb290Iiwic3R5bGVzIiwiYWRvcHRlZFN0eWxlU2hlZXRzIiwibWFwIiwicyIsImZvckVhY2giLCJzdHlsZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5vbmNlIiwic2V0QXR0cmlidXRlIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsImNzc1Jlc3VsdEZyb21TdHlsZVNoZWV0Iiwic2hlZXQiLCJydWxlIiwiY3NzUnVsZXMiLCJnZXRDb21wYXRpYmxlU3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/css-tag.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/base.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decorateProperty: () => (/* binding */ decorateProperty),\n/* harmony export */   legacyPrototypeMethod: () => (/* binding */ legacyPrototypeMethod),\n/* harmony export */   standardPrototypeMethod: () => (/* binding */ standardPrototypeMethod)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const legacyPrototypeMethod = (descriptor, proto, name)=>{\n    Object.defineProperty(proto, name, descriptor);\n};\nconst standardPrototypeMethod = (descriptor, element)=>({\n        kind: \"method\",\n        placement: \"prototype\",\n        key: element.key,\n        descriptor\n    });\n/**\n * Helper for decorating a property that is compatible with both TypeScript\n * and Babel decorators. The optional `finisher` can be used to perform work on\n * the class. The optional `descriptor` should return a PropertyDescriptor\n * to install for the given property.\n *\n * @param finisher {function} Optional finisher method; receives the element\n * constructor and property key as arguments and has no return value.\n * @param descriptor {function} Optional descriptor method; receives the\n * property key as an argument and returns a property descriptor to define for\n * the given property.\n * @returns {ClassElement|void}\n */ const decorateProperty = ({ finisher, descriptor })=>(protoOrDescriptor, name)=>{\n        var _a;\n        // TypeScript / Babel legacy mode\n        if (name !== undefined) {\n            const ctor = protoOrDescriptor.constructor;\n            if (descriptor !== undefined) {\n                Object.defineProperty(protoOrDescriptor, name, descriptor(name));\n            }\n            finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);\n        // Babel standard mode\n        } else {\n            // Note, the @property decorator saves `key` as `originalKey`\n            // so try to use it here.\n            const key = // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (_a = protoOrDescriptor.originalKey) !== null && _a !== void 0 ? _a : protoOrDescriptor.key;\n            const info = descriptor != undefined ? {\n                kind: \"method\",\n                placement: \"prototype\",\n                key,\n                descriptor: descriptor(protoOrDescriptor.key)\n            } : {\n                ...protoOrDescriptor,\n                key\n            };\n            if (finisher != undefined) {\n                info.finisher = function(ctor) {\n                    finisher(ctor, key);\n                };\n            }\n            return info;\n        }\n    };\n //# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9iYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxNQUFNQSx3QkFBd0IsQ0FBQ0MsWUFBWUMsT0FBT0M7SUFDOUNDLE9BQU9DLGNBQWMsQ0FBQ0gsT0FBT0MsTUFBTUY7QUFDdkM7QUFDQSxNQUFNSywwQkFBMEIsQ0FBQ0wsWUFBWU0sVUFBYTtRQUN0REMsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLEtBQUtILFFBQVFHLEdBQUc7UUFDaEJUO0lBQ0o7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxNQUFNVSxtQkFBbUIsQ0FBQyxFQUFFQyxRQUFRLEVBQUVYLFVBQVUsRUFBRyxHQUFLLENBQUNZLG1CQUFtQlY7UUFJeEUsSUFBSVc7UUFDSixpQ0FBaUM7UUFDakMsSUFBSVgsU0FBU1ksV0FBVztZQUNwQixNQUFNQyxPQUFPSCxrQkFDUkksV0FBVztZQUNoQixJQUFJaEIsZUFBZWMsV0FBVztnQkFDMUJYLE9BQU9DLGNBQWMsQ0FBQ1EsbUJBQW1CVixNQUFNRixXQUFXRTtZQUM5RDtZQUNBUyxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU0ksTUFBTWI7UUFDbkUsc0JBQXNCO1FBQzFCLE9BQ0s7WUFDRCw2REFBNkQ7WUFDN0QseUJBQXlCO1lBQ3pCLE1BQU1PLE1BRU4sOERBRDhEO1lBQzdESSxDQUFBQSxLQUFLRCxrQkFBa0JLLFdBQVcsTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSUEsS0FBS0Qsa0JBQWtCSCxHQUFHO1lBQzNGLE1BQU1TLE9BQU9sQixjQUFjYyxZQUNyQjtnQkFDRVAsTUFBTTtnQkFDTkMsV0FBVztnQkFDWEM7Z0JBQ0FULFlBQVlBLFdBQVdZLGtCQUFrQkgsR0FBRztZQUNoRCxJQUNFO2dCQUFFLEdBQUdHLGlCQUFpQjtnQkFBRUg7WUFBSTtZQUNsQyxJQUFJRSxZQUFZRyxXQUFXO2dCQUN2QkksS0FBS1AsUUFBUSxHQUFHLFNBQVVJLElBQUk7b0JBQzFCSixTQUFTSSxNQUFNTjtnQkFDbkI7WUFDSjtZQUNBLE9BQU9TO1FBQ1g7SUFDSjtBQUU0RSxDQUM1RSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9iYXNlLmpzP2Q0NzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5jb25zdCBsZWdhY3lQcm90b3R5cGVNZXRob2QgPSAoZGVzY3JpcHRvciwgcHJvdG8sIG5hbWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIGRlc2NyaXB0b3IpO1xufTtcbmNvbnN0IHN0YW5kYXJkUHJvdG90eXBlTWV0aG9kID0gKGRlc2NyaXB0b3IsIGVsZW1lbnQpID0+ICh7XG4gICAga2luZDogJ21ldGhvZCcsXG4gICAgcGxhY2VtZW50OiAncHJvdG90eXBlJyxcbiAgICBrZXk6IGVsZW1lbnQua2V5LFxuICAgIGRlc2NyaXB0b3IsXG59KTtcbi8qKlxuICogSGVscGVyIGZvciBkZWNvcmF0aW5nIGEgcHJvcGVydHkgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggYm90aCBUeXBlU2NyaXB0XG4gKiBhbmQgQmFiZWwgZGVjb3JhdG9ycy4gVGhlIG9wdGlvbmFsIGBmaW5pc2hlcmAgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSB3b3JrIG9uXG4gKiB0aGUgY2xhc3MuIFRoZSBvcHRpb25hbCBgZGVzY3JpcHRvcmAgc2hvdWxkIHJldHVybiBhIFByb3BlcnR5RGVzY3JpcHRvclxuICogdG8gaW5zdGFsbCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBmaW5pc2hlciB7ZnVuY3Rpb259IE9wdGlvbmFsIGZpbmlzaGVyIG1ldGhvZDsgcmVjZWl2ZXMgdGhlIGVsZW1lbnRcbiAqIGNvbnN0cnVjdG9yIGFuZCBwcm9wZXJ0eSBrZXkgYXMgYXJndW1lbnRzIGFuZCBoYXMgbm8gcmV0dXJuIHZhbHVlLlxuICogQHBhcmFtIGRlc2NyaXB0b3Ige2Z1bmN0aW9ufSBPcHRpb25hbCBkZXNjcmlwdG9yIG1ldGhvZDsgcmVjZWl2ZXMgdGhlXG4gKiBwcm9wZXJ0eSBrZXkgYXMgYW4gYXJndW1lbnQgYW5kIHJldHVybnMgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGRlZmluZSBmb3JcbiAqIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtDbGFzc0VsZW1lbnR8dm9pZH1cbiAqL1xuY29uc3QgZGVjb3JhdGVQcm9wZXJ0eSA9ICh7IGZpbmlzaGVyLCBkZXNjcmlwdG9yLCB9KSA9PiAocHJvdG9PckRlc2NyaXB0b3IsIG5hbWVcbi8vIE5vdGUgVHlwZVNjcmlwdCByZXF1aXJlcyB0aGUgcmV0dXJuIHR5cGUgdG8gYmUgYHZvaWR8YW55YFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAvLyBUeXBlU2NyaXB0IC8gQmFiZWwgbGVnYWN5IG1vZGVcbiAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGN0b3IgPSBwcm90b09yRGVzY3JpcHRvclxuICAgICAgICAgICAgLmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG9PckRlc2NyaXB0b3IsIG5hbWUsIGRlc2NyaXB0b3IobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaGVyID09PSBudWxsIHx8IGZpbmlzaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaW5pc2hlcihjdG9yLCBuYW1lKTtcbiAgICAgICAgLy8gQmFiZWwgc3RhbmRhcmQgbW9kZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm90ZSwgdGhlIEBwcm9wZXJ0eSBkZWNvcmF0b3Igc2F2ZXMgYGtleWAgYXMgYG9yaWdpbmFsS2V5YFxuICAgICAgICAvLyBzbyB0cnkgdG8gdXNlIGl0IGhlcmUuXG4gICAgICAgIGNvbnN0IGtleSA9IFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAoX2EgPSBwcm90b09yRGVzY3JpcHRvci5vcmlnaW5hbEtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvdG9PckRlc2NyaXB0b3Iua2V5O1xuICAgICAgICBjb25zdCBpbmZvID0gZGVzY3JpcHRvciAhPSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGtpbmQ6ICdtZXRob2QnLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ3Byb3RvdHlwZScsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3I6IGRlc2NyaXB0b3IocHJvdG9PckRlc2NyaXB0b3Iua2V5KSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogeyAuLi5wcm90b09yRGVzY3JpcHRvciwga2V5IH07XG4gICAgICAgIGlmIChmaW5pc2hlciAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluZm8uZmluaXNoZXIgPSBmdW5jdGlvbiAoY3Rvcikge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVyKGN0b3IsIGtleSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGRlY29yYXRlUHJvcGVydHksIGxlZ2FjeVByb3RvdHlwZU1ldGhvZCwgc3RhbmRhcmRQcm90b3R5cGVNZXRob2QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwXG4iXSwibmFtZXMiOlsibGVnYWN5UHJvdG90eXBlTWV0aG9kIiwiZGVzY3JpcHRvciIsInByb3RvIiwibmFtZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwic3RhbmRhcmRQcm90b3R5cGVNZXRob2QiLCJlbGVtZW50Iiwia2luZCIsInBsYWNlbWVudCIsImtleSIsImRlY29yYXRlUHJvcGVydHkiLCJmaW5pc2hlciIsInByb3RvT3JEZXNjcmlwdG9yIiwiX2EiLCJ1bmRlZmluZWQiLCJjdG9yIiwiY29uc3RydWN0b3IiLCJvcmlnaW5hbEtleSIsImluZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/custom-element.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/custom-element.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customElement: () => (/* binding */ customElement)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const legacyCustomElement = (tagName, clazz)=>{\n    customElements.define(tagName, clazz);\n    // Cast as any because TS doesn't recognize the return type as being a\n    // subtype of the decorated class when clazz is typed as\n    // `Constructor<HTMLElement>` for some reason.\n    // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n    // applied to elements however.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return clazz;\n};\nconst standardCustomElement = (tagName, descriptor)=>{\n    const { kind, elements } = descriptor;\n    return {\n        kind,\n        elements,\n        // This callback is called once the class is otherwise fully defined\n        finisher (clazz) {\n            customElements.define(tagName, clazz);\n        }\n    };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```js\n * @customElement('my-element')\n * class MyElement extends LitElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n * @category Decorator\n * @param tagName The tag name of the custom element to define.\n */ const customElement = (tagName)=>(classOrDescriptor)=>typeof classOrDescriptor === \"function\" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);\n //# sourceMappingURL=custom-element.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9jdXN0b20tZWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNELE1BQU1BLHNCQUFzQixDQUFDQyxTQUFTQztJQUNsQ0MsZUFBZUMsTUFBTSxDQUFDSCxTQUFTQztJQUMvQixzRUFBc0U7SUFDdEUsd0RBQXdEO0lBQ3hELDhDQUE4QztJQUM5QyxzRUFBc0U7SUFDdEUsK0JBQStCO0lBQy9CLDhEQUE4RDtJQUM5RCxPQUFPQTtBQUNYO0FBQ0EsTUFBTUcsd0JBQXdCLENBQUNKLFNBQVNLO0lBQ3BDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Y7SUFDM0IsT0FBTztRQUNIQztRQUNBQztRQUNBLG9FQUFvRTtRQUNwRUMsVUFBU1AsS0FBSztZQUNWQyxlQUFlQyxNQUFNLENBQUNILFNBQVNDO1FBQ25DO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxNQUFNUSxnQkFBZ0IsQ0FBQ1QsVUFBWSxDQUFDVSxvQkFBc0IsT0FBT0Esc0JBQXNCLGFBQ2pGWCxvQkFBb0JDLFNBQVNVLHFCQUM3Qk4sc0JBQXNCSixTQUFTVTtBQUVaLENBQ3pCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvbm9kZS9kZXZlbG9wbWVudC9kZWNvcmF0b3JzL2N1c3RvbS1lbGVtZW50LmpzPzllNTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5jb25zdCBsZWdhY3lDdXN0b21FbGVtZW50ID0gKHRhZ05hbWUsIGNsYXp6KSA9PiB7XG4gICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIGNsYXp6KTtcbiAgICAvLyBDYXN0IGFzIGFueSBiZWNhdXNlIFRTIGRvZXNuJ3QgcmVjb2duaXplIHRoZSByZXR1cm4gdHlwZSBhcyBiZWluZyBhXG4gICAgLy8gc3VidHlwZSBvZiB0aGUgZGVjb3JhdGVkIGNsYXNzIHdoZW4gY2xhenogaXMgdHlwZWQgYXNcbiAgICAvLyBgQ29uc3RydWN0b3I8SFRNTEVsZW1lbnQ+YCBmb3Igc29tZSByZWFzb24uXG4gICAgLy8gYENvbnN0cnVjdG9yPEhUTUxFbGVtZW50PmAgaXMgaGVscGZ1bCB0byBtYWtlIHN1cmUgdGhlIGRlY29yYXRvciBpc1xuICAgIC8vIGFwcGxpZWQgdG8gZWxlbWVudHMgaG93ZXZlci5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiBjbGF6ejtcbn07XG5jb25zdCBzdGFuZGFyZEN1c3RvbUVsZW1lbnQgPSAodGFnTmFtZSwgZGVzY3JpcHRvcikgPT4ge1xuICAgIGNvbnN0IHsga2luZCwgZWxlbWVudHMgfSA9IGRlc2NyaXB0b3I7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIG9uY2UgdGhlIGNsYXNzIGlzIG90aGVyd2lzZSBmdWxseSBkZWZpbmVkXG4gICAgICAgIGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgY2xhenopO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuLyoqXG4gKiBDbGFzcyBkZWNvcmF0b3IgZmFjdG9yeSB0aGF0IGRlZmluZXMgdGhlIGRlY29yYXRlZCBjbGFzcyBhcyBhIGN1c3RvbSBlbGVtZW50LlxuICpcbiAqIGBgYGpzXG4gKiBAY3VzdG9tRWxlbWVudCgnbXktZWxlbWVudCcpXG4gKiBjbGFzcyBNeUVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAqICAgcmVuZGVyKCkge1xuICogICAgIHJldHVybiBodG1sYGA7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICogQHBhcmFtIHRhZ05hbWUgVGhlIHRhZyBuYW1lIG9mIHRoZSBjdXN0b20gZWxlbWVudCB0byBkZWZpbmUuXG4gKi9cbmNvbnN0IGN1c3RvbUVsZW1lbnQgPSAodGFnTmFtZSkgPT4gKGNsYXNzT3JEZXNjcmlwdG9yKSA9PiB0eXBlb2YgY2xhc3NPckRlc2NyaXB0b3IgPT09ICdmdW5jdGlvbidcbiAgICA/IGxlZ2FjeUN1c3RvbUVsZW1lbnQodGFnTmFtZSwgY2xhc3NPckRlc2NyaXB0b3IpXG4gICAgOiBzdGFuZGFyZEN1c3RvbUVsZW1lbnQodGFnTmFtZSwgY2xhc3NPckRlc2NyaXB0b3IpO1xuXG5leHBvcnQgeyBjdXN0b21FbGVtZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXN0b20tZWxlbWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJsZWdhY3lDdXN0b21FbGVtZW50IiwidGFnTmFtZSIsImNsYXp6IiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiLCJzdGFuZGFyZEN1c3RvbUVsZW1lbnQiLCJkZXNjcmlwdG9yIiwia2luZCIsImVsZW1lbnRzIiwiZmluaXNoZXIiLCJjdXN0b21FbGVtZW50IiwiY2xhc3NPckRlc2NyaXB0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/custom-element.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/event-options.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/event-options.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventOptions: () => (/* binding */ eventOptions)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifies event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * ```ts\n * class MyElement {\n *   clicked = false;\n *\n *   render() {\n *     return html`\n *       <div @click=${this._onClick}>\n *         <button></button>\n *       </div>\n *     `;\n *   }\n *\n *   @eventOptions({capture: true})\n *   _onClick(e) {\n *     this.clicked = true;\n *   }\n * }\n * ```\n * @category Decorator\n */ function eventOptions(options) {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        finisher: (ctor, name)=>{\n            Object.assign(// eslint-disable-next-line @typescript-eslint/no-explicit-any\n            ctor.prototype[name], options);\n        }\n    });\n}\n //# sourceMappingURL=event-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9ldmVudC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDO0FBRTdDOzs7O0NBSUMsR0FDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkMsR0FDRCxTQUFTQyxhQUFhQyxPQUFPO0lBQ3pCLE9BQU9GLDBEQUFnQkEsQ0FBQztRQUNwQkcsVUFBVSxDQUFDQyxNQUFNQztZQUNiQyxPQUFPQyxNQUFNLENBQ2IsOERBQThEO1lBQzlESCxLQUFLSSxTQUFTLENBQUNILEtBQUssRUFBRUg7UUFDMUI7SUFDSjtBQUNKO0FBRXdCLENBQ3hCLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvbm9kZS9kZXZlbG9wbWVudC9kZWNvcmF0b3JzL2V2ZW50LW9wdGlvbnMuanM/ZjgwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWNvcmF0ZVByb3BlcnR5IH0gZnJvbSAnLi9iYXNlLmpzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgb3B0aW9ucyB0byBhIG1ldGhvZCB1c2VkIGFzIGFuIGV2ZW50IGxpc3RlbmVyIGluIGFcbiAqIGxpdC1odG1sIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCB0aGF0IHNwZWNpZmllcyBldmVudCBsaXN0ZW5lciBvcHRpb25zIGFzIGFjY2VwdGVkIGJ5XG4gKiBgRXZlbnRUYXJnZXQjYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGBFdmVudFRhcmdldCNyZW1vdmVFdmVudExpc3RlbmVyYC5cbiAqXG4gKiBDdXJyZW50IGJyb3dzZXJzIHN1cHBvcnQgdGhlIGBjYXB0dXJlYCwgYHBhc3NpdmVgLCBhbmQgYG9uY2VgIG9wdGlvbnMuIFNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1BhcmFtZXRlcnNcbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgTXlFbGVtZW50IHtcbiAqICAgY2xpY2tlZCA9IGZhbHNlO1xuICpcbiAqICAgcmVuZGVyKCkge1xuICogICAgIHJldHVybiBodG1sYFxuICogICAgICAgPGRpdiBAY2xpY2s9JHt0aGlzLl9vbkNsaWNrfT5cbiAqICAgICAgICAgPGJ1dHRvbj48L2J1dHRvbj5cbiAqICAgICAgIDwvZGl2PlxuICogICAgIGA7XG4gKiAgIH1cbiAqXG4gKiAgIEBldmVudE9wdGlvbnMoe2NhcHR1cmU6IHRydWV9KVxuICogICBfb25DbGljayhlKSB7XG4gKiAgICAgdGhpcy5jbGlja2VkID0gdHJ1ZTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKiBAY2F0ZWdvcnkgRGVjb3JhdG9yXG4gKi9cbmZ1bmN0aW9uIGV2ZW50T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlY29yYXRlUHJvcGVydHkoe1xuICAgICAgICBmaW5pc2hlcjogKGN0b3IsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGVbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBldmVudE9wdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LW9wdGlvbnMuanMubWFwXG4iXSwibmFtZXMiOlsiZGVjb3JhdGVQcm9wZXJ0eSIsImV2ZW50T3B0aW9ucyIsIm9wdGlvbnMiLCJmaW5pc2hlciIsImN0b3IiLCJuYW1lIiwiT2JqZWN0IiwiYXNzaWduIiwicHJvdG90eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/event-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/property.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/property.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   property: () => (/* binding */ property)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ const standardProperty = (options, element)=>{\n    // When decorating an accessor, pass it through and add property metadata.\n    // Note, the `hasOwnProperty` check in `createProperty` ensures we don't\n    // stomp over the user's accessor.\n    if (element.kind === \"method\" && element.descriptor && !(\"value\" in element.descriptor)) {\n        return {\n            ...element,\n            finisher (clazz) {\n                clazz.createProperty(element.key, options);\n            }\n        };\n    } else {\n        // createProperty() takes care of defining the property, but we still\n        // must return some kind of descriptor, so return a descriptor for an\n        // unused prototype field. The finisher calls createProperty().\n        return {\n            kind: \"field\",\n            key: Symbol(),\n            placement: \"own\",\n            descriptor: {},\n            // store the original key so subsequent decorators have access to it.\n            originalKey: element.key,\n            // When @babel/plugin-proposal-decorators implements initializers,\n            // do this instead of the initializer below. See:\n            // https://github.com/babel/babel/issues/9260 extras: [\n            //   {\n            //     kind: 'initializer',\n            //     placement: 'own',\n            //     initializer: descriptor.initializer,\n            //   }\n            // ],\n            initializer () {\n                if (typeof element.initializer === \"function\") {\n                    this[element.key] = element.initializer.call(this);\n                }\n            },\n            finisher (clazz) {\n                clazz.createProperty(element.key, options);\n            }\n        };\n    }\n};\nconst legacyProperty = (options, proto, name)=>{\n    proto.constructor.createProperty(name, options);\n};\n/**\n * A property decorator which creates a reactive property that reflects a\n * corresponding attribute value. When a decorated property is set\n * the element will update and render. A {@linkcode PropertyDeclaration} may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the {@linkcode state} decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the {@linkcode state} decorator should be used. When\n * needed, state properties can be initialized via public properties to\n * facilitate complex interactions.\n *\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */ function property(options) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (protoOrDescriptor, name)=>name !== undefined ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);\n}\n //# sourceMappingURL=property.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9wcm9wZXJ0eS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Q0FJQyxHQUNELE1BQU1BLG1CQUFtQixDQUFDQyxTQUFTQztJQUMvQiwwRUFBMEU7SUFDMUUsd0VBQXdFO0lBQ3hFLGtDQUFrQztJQUNsQyxJQUFJQSxRQUFRQyxJQUFJLEtBQUssWUFDakJELFFBQVFFLFVBQVUsSUFDbEIsQ0FBRSxZQUFXRixRQUFRRSxVQUFVLEdBQUc7UUFDbEMsT0FBTztZQUNILEdBQUdGLE9BQU87WUFDVkcsVUFBU0MsS0FBSztnQkFDVkEsTUFBTUMsY0FBYyxDQUFDTCxRQUFRTSxHQUFHLEVBQUVQO1lBQ3RDO1FBQ0o7SUFDSixPQUNLO1FBQ0QscUVBQXFFO1FBQ3JFLHFFQUFxRTtRQUNyRSwrREFBK0Q7UUFDL0QsT0FBTztZQUNIRSxNQUFNO1lBQ05LLEtBQUtDO1lBQ0xDLFdBQVc7WUFDWE4sWUFBWSxDQUFDO1lBQ2IscUVBQXFFO1lBQ3JFTyxhQUFhVCxRQUFRTSxHQUFHO1lBQ3hCLGtFQUFrRTtZQUNsRSxpREFBaUQ7WUFDakQsdURBQXVEO1lBQ3ZELE1BQU07WUFDTiwyQkFBMkI7WUFDM0Isd0JBQXdCO1lBQ3hCLDJDQUEyQztZQUMzQyxNQUFNO1lBQ04sS0FBSztZQUNMSTtnQkFDSSxJQUFJLE9BQU9WLFFBQVFVLFdBQVcsS0FBSyxZQUFZO29CQUMzQyxJQUFJLENBQUNWLFFBQVFNLEdBQUcsQ0FBQyxHQUFHTixRQUFRVSxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO2dCQUNyRDtZQUNKO1lBQ0FSLFVBQVNDLEtBQUs7Z0JBQ1ZBLE1BQU1DLGNBQWMsQ0FBQ0wsUUFBUU0sR0FBRyxFQUFFUDtZQUN0QztRQUNKO0lBQ0o7QUFDSjtBQUNBLE1BQU1hLGlCQUFpQixDQUFDYixTQUFTYyxPQUFPQztJQUNwQ0QsTUFBTUUsV0FBVyxDQUFDVixjQUFjLENBQUNTLE1BQU1mO0FBQzNDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0ErQkMsR0FDRCxTQUFTaUIsU0FBU2pCLE9BQU87SUFDckIsOERBQThEO0lBQzlELE9BQU8sQ0FBQ2tCLG1CQUFtQkgsT0FBU0EsU0FBU0ksWUFDdkNOLGVBQWViLFNBQVNrQixtQkFBbUJILFFBQzNDaEIsaUJBQWlCQyxTQUFTa0I7QUFDcEM7QUFFb0IsQ0FDcEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvcHJvcGVydHkuanM/OGZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbmNvbnN0IHN0YW5kYXJkUHJvcGVydHkgPSAob3B0aW9ucywgZWxlbWVudCkgPT4ge1xuICAgIC8vIFdoZW4gZGVjb3JhdGluZyBhbiBhY2Nlc3NvciwgcGFzcyBpdCB0aHJvdWdoIGFuZCBhZGQgcHJvcGVydHkgbWV0YWRhdGEuXG4gICAgLy8gTm90ZSwgdGhlIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2sgaW4gYGNyZWF0ZVByb3BlcnR5YCBlbnN1cmVzIHdlIGRvbid0XG4gICAgLy8gc3RvbXAgb3ZlciB0aGUgdXNlcidzIGFjY2Vzc29yLlxuICAgIGlmIChlbGVtZW50LmtpbmQgPT09ICdtZXRob2QnICYmXG4gICAgICAgIGVsZW1lbnQuZGVzY3JpcHRvciAmJlxuICAgICAgICAhKCd2YWx1ZScgaW4gZWxlbWVudC5kZXNjcmlwdG9yKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZWxlbWVudCxcbiAgICAgICAgICAgIGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICAgICAgY2xhenouY3JlYXRlUHJvcGVydHkoZWxlbWVudC5rZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZVByb3BlcnR5KCkgdGFrZXMgY2FyZSBvZiBkZWZpbmluZyB0aGUgcHJvcGVydHksIGJ1dCB3ZSBzdGlsbFxuICAgICAgICAvLyBtdXN0IHJldHVybiBzb21lIGtpbmQgb2YgZGVzY3JpcHRvciwgc28gcmV0dXJuIGEgZGVzY3JpcHRvciBmb3IgYW5cbiAgICAgICAgLy8gdW51c2VkIHByb3RvdHlwZSBmaWVsZC4gVGhlIGZpbmlzaGVyIGNhbGxzIGNyZWF0ZVByb3BlcnR5KCkuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAnZmllbGQnLFxuICAgICAgICAgICAga2V5OiBTeW1ib2woKSxcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ293bicsXG4gICAgICAgICAgICBkZXNjcmlwdG9yOiB7fSxcbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCBrZXkgc28gc3Vic2VxdWVudCBkZWNvcmF0b3JzIGhhdmUgYWNjZXNzIHRvIGl0LlxuICAgICAgICAgICAgb3JpZ2luYWxLZXk6IGVsZW1lbnQua2V5LFxuICAgICAgICAgICAgLy8gV2hlbiBAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLWRlY29yYXRvcnMgaW1wbGVtZW50cyBpbml0aWFsaXplcnMsXG4gICAgICAgICAgICAvLyBkbyB0aGlzIGluc3RlYWQgb2YgdGhlIGluaXRpYWxpemVyIGJlbG93LiBTZWU6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzkyNjAgZXh0cmFzOiBbXG4gICAgICAgICAgICAvLyAgIHtcbiAgICAgICAgICAgIC8vICAgICBraW5kOiAnaW5pdGlhbGl6ZXInLFxuICAgICAgICAgICAgLy8gICAgIHBsYWNlbWVudDogJ293bicsXG4gICAgICAgICAgICAvLyAgICAgaW5pdGlhbGl6ZXI6IGRlc2NyaXB0b3IuaW5pdGlhbGl6ZXIsXG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIF0sXG4gICAgICAgICAgICBpbml0aWFsaXplcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQuaW5pdGlhbGl6ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tlbGVtZW50LmtleV0gPSBlbGVtZW50LmluaXRpYWxpemVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICAgICAgY2xhenouY3JlYXRlUHJvcGVydHkoZWxlbWVudC5rZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgbGVnYWN5UHJvcGVydHkgPSAob3B0aW9ucywgcHJvdG8sIG5hbWUpID0+IHtcbiAgICBwcm90by5jb25zdHJ1Y3Rvci5jcmVhdGVQcm9wZXJ0eShuYW1lLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIEEgcHJvcGVydHkgZGVjb3JhdG9yIHdoaWNoIGNyZWF0ZXMgYSByZWFjdGl2ZSBwcm9wZXJ0eSB0aGF0IHJlZmxlY3RzIGFcbiAqIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIHZhbHVlLiBXaGVuIGEgZGVjb3JhdGVkIHByb3BlcnR5IGlzIHNldFxuICogdGhlIGVsZW1lbnQgd2lsbCB1cGRhdGUgYW5kIHJlbmRlci4gQSB7QGxpbmtjb2RlIFByb3BlcnR5RGVjbGFyYXRpb259IG1heVxuICogb3B0aW9uYWxseSBiZSBzdXBwbGllZCB0byBjb25maWd1cmUgcHJvcGVydHkgZmVhdHVyZXMuXG4gKlxuICogVGhpcyBkZWNvcmF0b3Igc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgcHVibGljIGZpZWxkcy4gQXMgcHVibGljIGZpZWxkcyxcbiAqIHByb3BlcnRpZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgcHJpbWFyaWx5IHNldHRhYmxlIGJ5IGVsZW1lbnQgdXNlcnMsXG4gKiBlaXRoZXIgdmlhIGF0dHJpYnV0ZSBvciB0aGUgcHJvcGVydHkgaXRzZWxmLlxuICpcbiAqIEdlbmVyYWxseSwgcHJvcGVydGllcyB0aGF0IGFyZSBjaGFuZ2VkIGJ5IHRoZSBlbGVtZW50IHNob3VsZCBiZSBwcml2YXRlIG9yXG4gKiBwcm90ZWN0ZWQgZmllbGRzIGFuZCBzaG91bGQgdXNlIHRoZSB7QGxpbmtjb2RlIHN0YXRlfSBkZWNvcmF0b3IuXG4gKlxuICogSG93ZXZlciwgc29tZXRpbWVzIGVsZW1lbnQgY29kZSBkb2VzIG5lZWQgdG8gc2V0IGEgcHVibGljIHByb3BlcnR5LiBUaGlzXG4gKiBzaG91bGQgdHlwaWNhbGx5IG9ubHkgYmUgZG9uZSBpbiByZXNwb25zZSB0byB1c2VyIGludGVyYWN0aW9uLCBhbmQgYW4gZXZlbnRcbiAqIHNob3VsZCBiZSBmaXJlZCBpbmZvcm1pbmcgdGhlIHVzZXI7IGZvciBleGFtcGxlLCBhIGNoZWNrYm94IHNldHMgaXRzXG4gKiBgY2hlY2tlZGAgcHJvcGVydHkgd2hlbiBjbGlja2VkIGFuZCBmaXJlcyBhIGBjaGFuZ2VkYCBldmVudC4gTXV0YXRpbmcgcHVibGljXG4gKiBwcm9wZXJ0aWVzIHNob3VsZCB0eXBpY2FsbHkgbm90IGJlIGRvbmUgZm9yIG5vbi1wcmltaXRpdmUgKG9iamVjdCBvciBhcnJheSlcbiAqIHByb3BlcnRpZXMuIEluIG90aGVyIGNhc2VzIHdoZW4gYW4gZWxlbWVudCBuZWVkcyB0byBtYW5hZ2Ugc3RhdGUsIGEgcHJpdmF0ZVxuICogcHJvcGVydHkgZGVjb3JhdGVkIHZpYSB0aGUge0BsaW5rY29kZSBzdGF0ZX0gZGVjb3JhdG9yIHNob3VsZCBiZSB1c2VkLiBXaGVuXG4gKiBuZWVkZWQsIHN0YXRlIHByb3BlcnRpZXMgY2FuIGJlIGluaXRpYWxpemVkIHZpYSBwdWJsaWMgcHJvcGVydGllcyB0b1xuICogZmFjaWxpdGF0ZSBjb21wbGV4IGludGVyYWN0aW9ucy5cbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgTXlFbGVtZW50IHtcbiAqICAgQHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KVxuICogICBjbGlja2VkID0gZmFsc2U7XG4gKiB9XG4gKiBgYGBcbiAqIEBjYXRlZ29yeSBEZWNvcmF0b3JcbiAqIEBFeHBvcnREZWNvcmF0ZWRJdGVtc1xuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gKHByb3RvT3JEZXNjcmlwdG9yLCBuYW1lKSA9PiBuYW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZWdhY3lQcm9wZXJ0eShvcHRpb25zLCBwcm90b09yRGVzY3JpcHRvciwgbmFtZSlcbiAgICAgICAgOiBzdGFuZGFyZFByb3BlcnR5KG9wdGlvbnMsIHByb3RvT3JEZXNjcmlwdG9yKTtcbn1cblxuZXhwb3J0IHsgcHJvcGVydHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5LmpzLm1hcFxuIl0sIm5hbWVzIjpbInN0YW5kYXJkUHJvcGVydHkiLCJvcHRpb25zIiwiZWxlbWVudCIsImtpbmQiLCJkZXNjcmlwdG9yIiwiZmluaXNoZXIiLCJjbGF6eiIsImNyZWF0ZVByb3BlcnR5Iiwia2V5IiwiU3ltYm9sIiwicGxhY2VtZW50Iiwib3JpZ2luYWxLZXkiLCJpbml0aWFsaXplciIsImNhbGwiLCJsZWdhY3lQcm9wZXJ0eSIsInByb3RvIiwibmFtZSIsImNvbnN0cnVjdG9yIiwicHJvcGVydHkiLCJwcm90b09yRGVzY3JpcHRvciIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/property.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-all.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query-all.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryAll: () => (/* binding */ queryAll)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * ```ts\n * class MyElement {\n *   @queryAll('div')\n *   divs: NodeListOf<HTMLDivElement>;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */ function queryAll(selector) {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (_name)=>({\n                get () {\n                    var _a, _b;\n                    return (_b = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector)) !== null && _b !== void 0 ? _b : [];\n                },\n                enumerable: true,\n                configurable: true\n            })\n    });\n}\n //# sourceMappingURL=query-all.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkM7QUFFN0M7Ozs7Q0FJQyxHQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVCQyxHQUNELFNBQVNDLFNBQVNDLFFBQVE7SUFDdEIsT0FBT0YsMERBQWdCQSxDQUFDO1FBQ3BCRyxZQUFZLENBQUNDLFFBQVc7Z0JBQ3BCQztvQkFDSSxJQUFJQyxJQUFJQztvQkFDUixPQUFPLENBQUNBLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNFLFVBQVUsTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdHLGdCQUFnQixDQUFDUCxTQUFRLE1BQU8sUUFBUUssT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtnQkFDL0k7Z0JBQ0FHLFlBQVk7Z0JBQ1pDLGNBQWM7WUFDbEI7SUFDSjtBQUNKO0FBRW9CLENBQ3BCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvbm9kZS9kZXZlbG9wbWVudC9kZWNvcmF0b3JzL3F1ZXJ5LWFsbC5qcz8zZGJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29yYXRlUHJvcGVydHkgfSBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXJcbiAqIHRoYXQgZXhlY3V0ZXMgYSBxdWVyeVNlbGVjdG9yQWxsIG9uIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdC5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgQSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2guXG4gKlxuICogU2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L3F1ZXJ5U2VsZWN0b3JBbGxcbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgTXlFbGVtZW50IHtcbiAqICAgQHF1ZXJ5QWxsKCdkaXYnKVxuICogICBkaXZzOiBOb2RlTGlzdE9mPEhUTUxEaXZFbGVtZW50PjtcbiAqXG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgIDxkaXYgaWQ9XCJmaXJzdFwiPjwvZGl2PlxuICogICAgICAgPGRpdiBpZD1cInNlY29uZFwiPjwvZGl2PlxuICogICAgIGA7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBxdWVyeUFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiBkZWNvcmF0ZVByb3BlcnR5KHtcbiAgICAgICAgZGVzY3JpcHRvcjogKF9uYW1lKSA9PiAoe1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucmVuZGVyUm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgcXVlcnlBbGwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWFsbC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWNvcmF0ZVByb3BlcnR5IiwicXVlcnlBbGwiLCJzZWxlY3RvciIsImRlc2NyaXB0b3IiLCJfbmFtZSIsImdldCIsIl9hIiwiX2IiLCJyZW5kZXJSb290IiwicXVlcnlTZWxlY3RvckFsbCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-all.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-elements.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-elements.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryAssignedElements: () => (/* binding */ queryAssignedElements)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ var _a;\nconst global = globalThis;\n/**\n * A tiny module scoped polyfill for HTMLSlotElement.assignedElements.\n */ const slotAssignedElements = ((_a = global.HTMLSlotElement) === null || _a === void 0 ? void 0 : _a.prototype.assignedElements) != null ? (slot, opts)=>slot.assignedElements(opts) : (slot, opts)=>slot.assignedNodes(opts).filter((node)=>node.nodeType === Node.ELEMENT_NODE);\n/**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedElements` of the given `slot`. Provides a declarative\n * way to use\n * [`HTMLSlotElement.assignedElements`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedElements).\n *\n * Can be passed an optional {@linkcode QueryAssignedElementsOptions} object.\n *\n * Example usage:\n * ```ts\n * class MyElement {\n *   @queryAssignedElements({ slot: 'list' })\n *   listItems!: Array<HTMLElement>;\n *   @queryAssignedElements()\n *   unnamedSlotEls!: Array<HTMLElement>;\n *\n *   render() {\n *     return html`\n *       <slot name=\"list\"></slot>\n *       <slot></slot>\n *     `;\n *   }\n * }\n * ```\n *\n * Note, the type of this property should be annotated as `Array<HTMLElement>`.\n *\n * @category Decorator\n */ function queryAssignedElements(options) {\n    const { slot, selector } = options !== null && options !== void 0 ? options : {};\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (_name)=>({\n                get () {\n                    var _a;\n                    const slotSelector = `slot${slot ? `[name=${slot}]` : \":not([name])\"}`;\n                    const slotEl = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(slotSelector);\n                    const elements = slotEl != null ? slotAssignedElements(slotEl, options) : [];\n                    if (selector) {\n                        return elements.filter((node)=>node.matches(selector));\n                    }\n                    return elements;\n                },\n                enumerable: true,\n                configurable: true\n            })\n    });\n}\n //# sourceMappingURL=query-assigned-elements.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hc3NpZ25lZC1lbGVtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2QztBQUU3Qzs7OztDQUlDLEdBQ0QsSUFBSUM7QUFDSixNQUFNQyxTQUFTQztBQUNmOztDQUVDLEdBQ0QsTUFBTUMsdUJBQXVCLENBQUMsQ0FBQ0gsS0FBS0MsT0FBT0csZUFBZSxNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ssU0FBUyxDQUFDQyxnQkFBZ0IsS0FBSyxPQUM3SCxDQUFDQyxNQUFNQyxPQUFTRCxLQUFLRCxnQkFBZ0IsQ0FBQ0UsUUFDdEMsQ0FBQ0QsTUFBTUMsT0FBU0QsS0FDYkUsYUFBYSxDQUFDRCxNQUNkRSxNQUFNLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS0MsUUFBUSxLQUFLQyxLQUFLQyxZQUFZO0FBQzdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEJDLEdBQ0QsU0FBU0Msc0JBQXNCQyxPQUFPO0lBQ2xDLE1BQU0sRUFBRVQsSUFBSSxFQUFFVSxRQUFRLEVBQUUsR0FBR0QsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSUEsVUFBVSxDQUFDO0lBQy9FLE9BQU9qQiwwREFBZ0JBLENBQUM7UUFDcEJtQixZQUFZLENBQUNDLFFBQVc7Z0JBQ3BCQztvQkFDSSxJQUFJcEI7b0JBQ0osTUFBTXFCLGVBQWUsQ0FBQyxJQUFJLEVBQUVkLE9BQU8sQ0FBQyxNQUFNLEVBQUVBLEtBQUssQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDO29CQUN0RSxNQUFNZSxTQUFTLENBQUN0QixLQUFLLElBQUksQ0FBQ3VCLFVBQVUsTUFBTSxRQUFRdkIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd0IsYUFBYSxDQUFDSDtvQkFDNUYsTUFBTUksV0FBV0gsVUFBVSxPQUFPbkIscUJBQXFCbUIsUUFBUU4sV0FBVyxFQUFFO29CQUM1RSxJQUFJQyxVQUFVO3dCQUNWLE9BQU9RLFNBQVNmLE1BQU0sQ0FBQyxDQUFDQyxPQUFTQSxLQUFLZSxPQUFPLENBQUNUO29CQUNsRDtvQkFDQSxPQUFPUTtnQkFDWDtnQkFDQUUsWUFBWTtnQkFDWkMsY0FBYztZQUNsQjtJQUNKO0FBQ0o7QUFFaUMsQ0FDakMsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvcXVlcnktYXNzaWduZWQtZWxlbWVudHMuanM/ZWNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWNvcmF0ZVByb3BlcnR5IH0gZnJvbSAnLi9iYXNlLmpzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG52YXIgX2E7XG5jb25zdCBnbG9iYWwgPSBnbG9iYWxUaGlzIDtcbi8qKlxuICogQSB0aW55IG1vZHVsZSBzY29wZWQgcG9seWZpbGwgZm9yIEhUTUxTbG90RWxlbWVudC5hc3NpZ25lZEVsZW1lbnRzLlxuICovXG5jb25zdCBzbG90QXNzaWduZWRFbGVtZW50cyA9ICgoX2EgPSBnbG9iYWwuSFRNTFNsb3RFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvdG90eXBlLmFzc2lnbmVkRWxlbWVudHMpICE9IG51bGxcbiAgICA/IChzbG90LCBvcHRzKSA9PiBzbG90LmFzc2lnbmVkRWxlbWVudHMob3B0cylcbiAgICA6IChzbG90LCBvcHRzKSA9PiBzbG90XG4gICAgICAgIC5hc3NpZ25lZE5vZGVzKG9wdHMpXG4gICAgICAgIC5maWx0ZXIoKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXIgdGhhdFxuICogcmV0dXJucyB0aGUgYGFzc2lnbmVkRWxlbWVudHNgIG9mIHRoZSBnaXZlbiBgc2xvdGAuIFByb3ZpZGVzIGEgZGVjbGFyYXRpdmVcbiAqIHdheSB0byB1c2VcbiAqIFtgSFRNTFNsb3RFbGVtZW50LmFzc2lnbmVkRWxlbWVudHNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTFNsb3RFbGVtZW50L2Fzc2lnbmVkRWxlbWVudHMpLlxuICpcbiAqIENhbiBiZSBwYXNzZWQgYW4gb3B0aW9uYWwge0BsaW5rY29kZSBRdWVyeUFzc2lnbmVkRWxlbWVudHNPcHRpb25zfSBvYmplY3QuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqIGBgYHRzXG4gKiBjbGFzcyBNeUVsZW1lbnQge1xuICogICBAcXVlcnlBc3NpZ25lZEVsZW1lbnRzKHsgc2xvdDogJ2xpc3QnIH0pXG4gKiAgIGxpc3RJdGVtcyE6IEFycmF5PEhUTUxFbGVtZW50PjtcbiAqICAgQHF1ZXJ5QXNzaWduZWRFbGVtZW50cygpXG4gKiAgIHVubmFtZWRTbG90RWxzITogQXJyYXk8SFRNTEVsZW1lbnQ+O1xuICpcbiAqICAgcmVuZGVyKCkge1xuICogICAgIHJldHVybiBodG1sYFxuICogICAgICAgPHNsb3QgbmFtZT1cImxpc3RcIj48L3Nsb3Q+XG4gKiAgICAgICA8c2xvdD48L3Nsb3Q+XG4gKiAgICAgYDtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogTm90ZSwgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBzaG91bGQgYmUgYW5ub3RhdGVkIGFzIGBBcnJheTxIVE1MRWxlbWVudD5gLlxuICpcbiAqIEBjYXRlZ29yeSBEZWNvcmF0b3JcbiAqL1xuZnVuY3Rpb24gcXVlcnlBc3NpZ25lZEVsZW1lbnRzKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNsb3QsIHNlbGVjdG9yIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICByZXR1cm4gZGVjb3JhdGVQcm9wZXJ0eSh7XG4gICAgICAgIGRlc2NyaXB0b3I6IChfbmFtZSkgPT4gKHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdFNlbGVjdG9yID0gYHNsb3Qke3Nsb3QgPyBgW25hbWU9JHtzbG90fV1gIDogJzpub3QoW25hbWVdKSd9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90RWwgPSAoX2EgPSB0aGlzLnJlbmRlclJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yKHNsb3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBzbG90RWwgIT0gbnVsbCA/IHNsb3RBc3NpZ25lZEVsZW1lbnRzKHNsb3RFbCwgb3B0aW9ucykgOiBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgcXVlcnlBc3NpZ25lZEVsZW1lbnRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1hc3NpZ25lZC1lbGVtZW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWNvcmF0ZVByb3BlcnR5IiwiX2EiLCJnbG9iYWwiLCJnbG9iYWxUaGlzIiwic2xvdEFzc2lnbmVkRWxlbWVudHMiLCJIVE1MU2xvdEVsZW1lbnQiLCJwcm90b3R5cGUiLCJhc3NpZ25lZEVsZW1lbnRzIiwic2xvdCIsIm9wdHMiLCJhc3NpZ25lZE5vZGVzIiwiZmlsdGVyIiwibm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsInF1ZXJ5QXNzaWduZWRFbGVtZW50cyIsIm9wdGlvbnMiLCJzZWxlY3RvciIsImRlc2NyaXB0b3IiLCJfbmFtZSIsImdldCIsInNsb3RTZWxlY3RvciIsInNsb3RFbCIsInJlbmRlclJvb3QiLCJxdWVyeVNlbGVjdG9yIiwiZWxlbWVudHMiLCJtYXRjaGVzIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-elements.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-nodes.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-nodes.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryAssignedNodes: () => (/* binding */ queryAssignedNodes)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n/* harmony import */ var _query_assigned_elements_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./query-assigned-elements.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-elements.js\");\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ function queryAssignedNodes(slotOrOptions, flatten, selector) {\n    // Normalize the overloaded arguments.\n    let slot = slotOrOptions;\n    let assignedNodesOptions;\n    if (typeof slotOrOptions === \"object\") {\n        slot = slotOrOptions.slot;\n        assignedNodesOptions = slotOrOptions;\n    } else {\n        assignedNodesOptions = {\n            flatten\n        };\n    }\n    // For backwards compatibility, queryAssignedNodes with a selector behaves\n    // exactly like queryAssignedElements with a selector.\n    if (selector) {\n        return (0,_query_assigned_elements_js__WEBPACK_IMPORTED_MODULE_1__.queryAssignedElements)({\n            slot: slot,\n            flatten,\n            selector\n        });\n    }\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (_name)=>({\n                get () {\n                    var _a, _b;\n                    const slotSelector = `slot${slot ? `[name=${slot}]` : \":not([name])\"}`;\n                    const slotEl = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(slotSelector);\n                    return (_b = slotEl === null || slotEl === void 0 ? void 0 : slotEl.assignedNodes(assignedNodesOptions)) !== null && _b !== void 0 ? _b : [];\n                },\n                enumerable: true,\n                configurable: true\n            })\n    });\n}\n //# sourceMappingURL=query-assigned-nodes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hc3NpZ25lZC1ub2Rlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkM7QUFDd0I7QUFFckU7Ozs7Q0FJQyxHQUNELFNBQVNFLG1CQUFtQkMsYUFBYSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFDeEQsc0NBQXNDO0lBQ3RDLElBQUlDLE9BQU9IO0lBQ1gsSUFBSUk7SUFDSixJQUFJLE9BQU9KLGtCQUFrQixVQUFVO1FBQ25DRyxPQUFPSCxjQUFjRyxJQUFJO1FBQ3pCQyx1QkFBdUJKO0lBQzNCLE9BQ0s7UUFDREksdUJBQXVCO1lBQUVIO1FBQVE7SUFDckM7SUFDQSwwRUFBMEU7SUFDMUUsc0RBQXNEO0lBQ3RELElBQUlDLFVBQVU7UUFDVixPQUFPSixrRkFBcUJBLENBQUM7WUFDekJLLE1BQU1BO1lBQ05GO1lBQ0FDO1FBQ0o7SUFDSjtJQUNBLE9BQU9MLDBEQUFnQkEsQ0FBQztRQUNwQlEsWUFBWSxDQUFDQyxRQUFXO2dCQUNwQkM7b0JBQ0ksSUFBSUMsSUFBSUM7b0JBQ1IsTUFBTUMsZUFBZSxDQUFDLElBQUksRUFBRVAsT0FBTyxDQUFDLE1BQU0sRUFBRUEsS0FBSyxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUM7b0JBQ3RFLE1BQU1RLFNBQVMsQ0FBQ0gsS0FBSyxJQUFJLENBQUNJLFVBQVUsTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdLLGFBQWEsQ0FBQ0g7b0JBQzVGLE9BQU8sQ0FBQ0QsS0FBS0UsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU9HLGFBQWEsQ0FBQ1YscUJBQW9CLE1BQU8sUUFBUUssT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtnQkFDaEo7Z0JBQ0FNLFlBQVk7Z0JBQ1pDLGNBQWM7WUFDbEI7SUFDSjtBQUNKO0FBRThCLENBQzlCLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9AbGl0L3JlYWN0aXZlLWVsZW1lbnQvbm9kZS9kZXZlbG9wbWVudC9kZWNvcmF0b3JzL3F1ZXJ5LWFzc2lnbmVkLW5vZGVzLmpzPzhhOGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVjb3JhdGVQcm9wZXJ0eSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBxdWVyeUFzc2lnbmVkRWxlbWVudHMgfSBmcm9tICcuL3F1ZXJ5LWFzc2lnbmVkLWVsZW1lbnRzLmpzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5mdW5jdGlvbiBxdWVyeUFzc2lnbmVkTm9kZXMoc2xvdE9yT3B0aW9ucywgZmxhdHRlbiwgc2VsZWN0b3IpIHtcbiAgICAvLyBOb3JtYWxpemUgdGhlIG92ZXJsb2FkZWQgYXJndW1lbnRzLlxuICAgIGxldCBzbG90ID0gc2xvdE9yT3B0aW9ucztcbiAgICBsZXQgYXNzaWduZWROb2Rlc09wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzbG90T3JPcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzbG90ID0gc2xvdE9yT3B0aW9ucy5zbG90O1xuICAgICAgICBhc3NpZ25lZE5vZGVzT3B0aW9ucyA9IHNsb3RPck9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NpZ25lZE5vZGVzT3B0aW9ucyA9IHsgZmxhdHRlbiB9O1xuICAgIH1cbiAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHF1ZXJ5QXNzaWduZWROb2RlcyB3aXRoIGEgc2VsZWN0b3IgYmVoYXZlc1xuICAgIC8vIGV4YWN0bHkgbGlrZSBxdWVyeUFzc2lnbmVkRWxlbWVudHMgd2l0aCBhIHNlbGVjdG9yLlxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gcXVlcnlBc3NpZ25lZEVsZW1lbnRzKHtcbiAgICAgICAgICAgIHNsb3Q6IHNsb3QsXG4gICAgICAgICAgICBmbGF0dGVuLFxuICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb3JhdGVQcm9wZXJ0eSh7XG4gICAgICAgIGRlc2NyaXB0b3I6IChfbmFtZSkgPT4gKHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3RTZWxlY3RvciA9IGBzbG90JHtzbG90ID8gYFtuYW1lPSR7c2xvdH1dYCA6ICc6bm90KFtuYW1lXSknfWA7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdEVsID0gKF9hID0gdGhpcy5yZW5kZXJSb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcihzbG90U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSBzbG90RWwgPT09IG51bGwgfHwgc2xvdEVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbG90RWwuYXNzaWduZWROb2Rlcyhhc3NpZ25lZE5vZGVzT3B0aW9ucykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pLFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBxdWVyeUFzc2lnbmVkTm9kZXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWFzc2lnbmVkLW5vZGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbImRlY29yYXRlUHJvcGVydHkiLCJxdWVyeUFzc2lnbmVkRWxlbWVudHMiLCJxdWVyeUFzc2lnbmVkTm9kZXMiLCJzbG90T3JPcHRpb25zIiwiZmxhdHRlbiIsInNlbGVjdG9yIiwic2xvdCIsImFzc2lnbmVkTm9kZXNPcHRpb25zIiwiZGVzY3JpcHRvciIsIl9uYW1lIiwiZ2V0IiwiX2EiLCJfYiIsInNsb3RTZWxlY3RvciIsInNsb3RFbCIsInJlbmRlclJvb3QiLCJxdWVyeVNlbGVjdG9yIiwiYXNzaWduZWROb2RlcyIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-assigned-nodes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-async.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query-async.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   queryAsync: () => (/* binding */ queryAsync)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ // Note, in the future, we may extend this decorator to support the use case\n// where the queried element may need to do work to become ready to interact\n// with (e.g. load some implementation code). If so, we might elect to\n// add a second argument defining a function that can be run to make the\n// queried element loaded/updated/ready.\n/**\n * A property decorator that converts a class property into a getter that\n * returns a promise that resolves to the result of a querySelector on the\n * element's renderRoot done after the element's `updateComplete` promise\n * resolves. When the queried property may change with element state, this\n * decorator can be used instead of requiring users to await the\n * `updateComplete` before accessing the property.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @queryAsync('#first')\n *   first: Promise<HTMLDivElement>;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n *\n * // external usage\n * async doSomethingWithFirst() {\n *  (await aMyElement.first).doSomething();\n * }\n * ```\n * @category Decorator\n */ function queryAsync(selector) {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (_name)=>({\n                async get () {\n                    var _a;\n                    await this.updateComplete;\n                    return (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);\n                },\n                enumerable: true,\n                configurable: true\n            })\n    });\n}\n //# sourceMappingURL=query-async.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS1hc3luYy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2QztBQUU3Qzs7OztDQUlDLEdBQ0QsNEVBQTRFO0FBQzVFLDRFQUE0RTtBQUM1RSxzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFLHdDQUF3QztBQUN4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUNELFNBQVNDLFdBQVdDLFFBQVE7SUFDeEIsT0FBT0YsMERBQWdCQSxDQUFDO1FBQ3BCRyxZQUFZLENBQUNDLFFBQVc7Z0JBQ3BCLE1BQU1DO29CQUNGLElBQUlDO29CQUNKLE1BQU0sSUFBSSxDQUFDQyxjQUFjO29CQUN6QixPQUFPLENBQUNELEtBQUssSUFBSSxDQUFDRSxVQUFVLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRyxhQUFhLENBQUNQO2dCQUN4RjtnQkFDQVEsWUFBWTtnQkFDWkMsY0FBYztZQUNsQjtJQUNKO0FBQ0o7QUFFc0IsQ0FDdEIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvcXVlcnktYXN5bmMuanM/NzU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWNvcmF0ZVByb3BlcnR5IH0gZnJvbSAnLi9iYXNlLmpzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG4vLyBOb3RlLCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgZXh0ZW5kIHRoaXMgZGVjb3JhdG9yIHRvIHN1cHBvcnQgdGhlIHVzZSBjYXNlXG4vLyB3aGVyZSB0aGUgcXVlcmllZCBlbGVtZW50IG1heSBuZWVkIHRvIGRvIHdvcmsgdG8gYmVjb21lIHJlYWR5IHRvIGludGVyYWN0XG4vLyB3aXRoIChlLmcuIGxvYWQgc29tZSBpbXBsZW1lbnRhdGlvbiBjb2RlKS4gSWYgc28sIHdlIG1pZ2h0IGVsZWN0IHRvXG4vLyBhZGQgYSBzZWNvbmQgYXJndW1lbnQgZGVmaW5pbmcgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG8gbWFrZSB0aGVcbi8vIHF1ZXJpZWQgZWxlbWVudCBsb2FkZWQvdXBkYXRlZC9yZWFkeS5cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXIgdGhhdFxuICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzdWx0IG9mIGEgcXVlcnlTZWxlY3RvciBvbiB0aGVcbiAqIGVsZW1lbnQncyByZW5kZXJSb290IGRvbmUgYWZ0ZXIgdGhlIGVsZW1lbnQncyBgdXBkYXRlQ29tcGxldGVgIHByb21pc2VcbiAqIHJlc29sdmVzLiBXaGVuIHRoZSBxdWVyaWVkIHByb3BlcnR5IG1heSBjaGFuZ2Ugd2l0aCBlbGVtZW50IHN0YXRlLCB0aGlzXG4gKiBkZWNvcmF0b3IgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiByZXF1aXJpbmcgdXNlcnMgdG8gYXdhaXQgdGhlXG4gKiBgdXBkYXRlQ29tcGxldGVgIGJlZm9yZSBhY2Nlc3NpbmcgdGhlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciBBIERPTVN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHNlbGVjdG9ycyB0byBtYXRjaC5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9xdWVyeVNlbGVjdG9yXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIE15RWxlbWVudCB7XG4gKiAgIEBxdWVyeUFzeW5jKCcjZmlyc3QnKVxuICogICBmaXJzdDogUHJvbWlzZTxIVE1MRGl2RWxlbWVudD47XG4gKlxuICogICByZW5kZXIoKSB7XG4gKiAgICAgcmV0dXJuIGh0bWxgXG4gKiAgICAgICA8ZGl2IGlkPVwiZmlyc3RcIj48L2Rpdj5cbiAqICAgICAgIDxkaXYgaWQ9XCJzZWNvbmRcIj48L2Rpdj5cbiAqICAgICBgO1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gZXh0ZXJuYWwgdXNhZ2VcbiAqIGFzeW5jIGRvU29tZXRoaW5nV2l0aEZpcnN0KCkge1xuICogIChhd2FpdCBhTXlFbGVtZW50LmZpcnN0KS5kb1NvbWV0aGluZygpO1xuICogfVxuICogYGBgXG4gKiBAY2F0ZWdvcnkgRGVjb3JhdG9yXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5QXN5bmMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZGVjb3JhdGVQcm9wZXJ0eSh7XG4gICAgICAgIGRlc2NyaXB0b3I6IChfbmFtZSkgPT4gKHtcbiAgICAgICAgICAgIGFzeW5jIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVDb21wbGV0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5yZW5kZXJSb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHF1ZXJ5QXN5bmMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWFzeW5jLmpzLm1hcFxuIl0sIm5hbWVzIjpbImRlY29yYXRlUHJvcGVydHkiLCJxdWVyeUFzeW5jIiwic2VsZWN0b3IiLCJkZXNjcmlwdG9yIiwiX25hbWUiLCJnZXQiLCJfYSIsInVwZGF0ZUNvbXBsZXRlIiwicmVuZGVyUm9vdCIsInF1ZXJ5U2VsZWN0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query-async.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/query.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   query: () => (/* binding */ query)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/base.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n * @param cache An optional boolean which when true performs the DOM query only\n *     once and caches the result.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @query('#first')\n *   first: HTMLDivElement;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */ function query(selector, cache) {\n    return (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.decorateProperty)({\n        descriptor: (name)=>{\n            const descriptor = {\n                get () {\n                    var _a, _b;\n                    return (_b = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector)) !== null && _b !== void 0 ? _b : null;\n                },\n                enumerable: true,\n                configurable: true\n            };\n            if (cache) {\n                const key = typeof name === \"symbol\" ? Symbol() : `__${name}`;\n                descriptor.get = function() {\n                    var _a, _b;\n                    if (this[key] === undefined) {\n                        this[key] = (_b = (_a = this.renderRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector)) !== null && _b !== void 0 ? _b : null;\n                    }\n                    return this[key];\n                };\n            }\n            return descriptor;\n        }\n    });\n}\n //# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2QztBQUU3Qzs7OztDQUlDLEdBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXdCQyxHQUNELFNBQVNDLE1BQU1DLFFBQVEsRUFBRUMsS0FBSztJQUMxQixPQUFPSCwwREFBZ0JBLENBQUM7UUFDcEJJLFlBQVksQ0FBQ0M7WUFDVCxNQUFNRCxhQUFhO2dCQUNmRTtvQkFDSSxJQUFJQyxJQUFJQztvQkFDUixPQUFPLENBQUNBLEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNFLFVBQVUsTUFBTSxRQUFRRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdHLGFBQWEsQ0FBQ1IsU0FBUSxNQUFPLFFBQVFNLE9BQU8sS0FBSyxJQUFJQSxLQUFLO2dCQUMxSTtnQkFDQUcsWUFBWTtnQkFDWkMsY0FBYztZQUNsQjtZQUNBLElBQUlULE9BQU87Z0JBQ1AsTUFBTVUsTUFBTSxPQUFPUixTQUFTLFdBQVdTLFdBQVcsQ0FBQyxFQUFFLEVBQUVULEtBQUssQ0FBQztnQkFDN0RELFdBQVdFLEdBQUcsR0FBRztvQkFDYixJQUFJQyxJQUFJQztvQkFDUixJQUFJLElBQUksQ0FBQ0ssSUFBSSxLQUFLRSxXQUFXO3dCQUN6QixJQUFJLENBQUNGLElBQUksR0FBRyxDQUFDTCxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDRSxVQUFVLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRyxhQUFhLENBQUNSLFNBQVEsTUFBTyxRQUFRTSxPQUFPLEtBQUssSUFBSUEsS0FBSztvQkFDL0k7b0JBQ0EsT0FBTyxJQUFJLENBQUNLLElBQUk7Z0JBQ3BCO1lBQ0o7WUFDQSxPQUFPVDtRQUNYO0lBQ0o7QUFDSjtBQUVpQixDQUNqQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9xdWVyeS5qcz9hNWM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29yYXRlUHJvcGVydHkgfSBmcm9tICcuL2Jhc2UuanMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXIgdGhhdFxuICogZXhlY3V0ZXMgYSBxdWVyeVNlbGVjdG9yIG9uIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdC5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgQSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2guXG4gKiBAcGFyYW0gY2FjaGUgQW4gb3B0aW9uYWwgYm9vbGVhbiB3aGljaCB3aGVuIHRydWUgcGVyZm9ybXMgdGhlIERPTSBxdWVyeSBvbmx5XG4gKiAgICAgb25jZSBhbmQgY2FjaGVzIHRoZSByZXN1bHQuXG4gKlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvclxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBNeUVsZW1lbnQge1xuICogICBAcXVlcnkoJyNmaXJzdCcpXG4gKiAgIGZpcnN0OiBIVE1MRGl2RWxlbWVudDtcbiAqXG4gKiAgIHJlbmRlcigpIHtcbiAqICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgIDxkaXYgaWQ9XCJmaXJzdFwiPjwvZGl2PlxuICogICAgICAgPGRpdiBpZD1cInNlY29uZFwiPjwvZGl2PlxuICogICAgIGA7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBxdWVyeShzZWxlY3RvciwgY2FjaGUpIHtcbiAgICByZXR1cm4gZGVjb3JhdGVQcm9wZXJ0eSh7XG4gICAgICAgIGRlc2NyaXB0b3I6IChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucmVuZGVyUm9vdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG5hbWUgPT09ICdzeW1ib2wnID8gU3ltYm9sKCkgOiBgX18ke25hbWV9YDtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSAoX2IgPSAoX2EgPSB0aGlzLnJlbmRlclJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgcXVlcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbImRlY29yYXRlUHJvcGVydHkiLCJxdWVyeSIsInNlbGVjdG9yIiwiY2FjaGUiLCJkZXNjcmlwdG9yIiwibmFtZSIsImdldCIsIl9hIiwiX2IiLCJyZW5kZXJSb290IiwicXVlcnlTZWxlY3RvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJrZXkiLCJTeW1ib2wiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/query.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/state.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/decorators/state.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   state: () => (/* binding */ state)\n/* harmony export */ });\n/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./property.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/property.js\");\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ /**\n * Declares a private or protected reactive property that still triggers\n * updates to the element when it changes. It does not reflect from the\n * corresponding attribute.\n *\n * Properties declared this way must not be used from HTML or HTML templating\n * systems, they're solely for properties internal to the element. These\n * properties may be renamed by optimization tools like closure compiler.\n * @category Decorator\n */ function state(options) {\n    return (0,_property_js__WEBPACK_IMPORTED_MODULE_0__.property)({\n        ...options,\n        state: true\n    });\n}\n //# sourceMappingURL=state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvZGVjb3JhdG9ycy9zdGF0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUV6Qzs7OztDQUlDLEdBQ0Q7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0MsTUFBTUMsT0FBTztJQUNsQixPQUFPRixzREFBUUEsQ0FBQztRQUNaLEdBQUdFLE9BQU87UUFDVkQsT0FBTztJQUNYO0FBQ0o7QUFFaUIsQ0FDakIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BsaXQvcmVhY3RpdmUtZWxlbWVudC9ub2RlL2RldmVsb3BtZW50L2RlY29yYXRvcnMvc3RhdGUuanM/ZmI5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9wZXJ0eSB9IGZyb20gJy4vcHJvcGVydHkuanMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbi8qKlxuICogRGVjbGFyZXMgYSBwcml2YXRlIG9yIHByb3RlY3RlZCByZWFjdGl2ZSBwcm9wZXJ0eSB0aGF0IHN0aWxsIHRyaWdnZXJzXG4gKiB1cGRhdGVzIHRvIHRoZSBlbGVtZW50IHdoZW4gaXQgY2hhbmdlcy4gSXQgZG9lcyBub3QgcmVmbGVjdCBmcm9tIHRoZVxuICogY29ycmVzcG9uZGluZyBhdHRyaWJ1dGUuXG4gKlxuICogUHJvcGVydGllcyBkZWNsYXJlZCB0aGlzIHdheSBtdXN0IG5vdCBiZSB1c2VkIGZyb20gSFRNTCBvciBIVE1MIHRlbXBsYXRpbmdcbiAqIHN5c3RlbXMsIHRoZXkncmUgc29sZWx5IGZvciBwcm9wZXJ0aWVzIGludGVybmFsIHRvIHRoZSBlbGVtZW50LiBUaGVzZVxuICogcHJvcGVydGllcyBtYXkgYmUgcmVuYW1lZCBieSBvcHRpbWl6YXRpb24gdG9vbHMgbGlrZSBjbG9zdXJlIGNvbXBpbGVyLlxuICogQGNhdGVnb3J5IERlY29yYXRvclxuICovXG5mdW5jdGlvbiBzdGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5KHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc3RhdGU6IHRydWUsXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHN0YXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJwcm9wZXJ0eSIsInN0YXRlIiwib3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/decorators/state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lit/reactive-element/node/development/reactive-element.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lit/reactive-element/node/development/reactive-element.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSSResult: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.CSSResult),\n/* harmony export */   ReactiveElement: () => (/* binding */ ReactiveElement),\n/* harmony export */   adoptStyles: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.adoptStyles),\n/* harmony export */   css: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.css),\n/* harmony export */   defaultConverter: () => (/* binding */ defaultConverter),\n/* harmony export */   getCompatibleStyle: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.getCompatibleStyle),\n/* harmony export */   notEqual: () => (/* binding */ notEqual),\n/* harmony export */   supportsAdoptingStyleSheets: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.supportsAdoptingStyleSheets),\n/* harmony export */   unsafeCSS: () => (/* reexport safe */ _css_tag_js__WEBPACK_IMPORTED_MODULE_1__.unsafeCSS)\n/* harmony export */ });\n/* harmony import */ var _lit_labs_ssr_dom_shim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit-labs/ssr-dom-shim */ \"(ssr)/./node_modules/@lit-labs/ssr-dom-shim/index.js\");\n/* harmony import */ var _css_tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css-tag.js */ \"(ssr)/./node_modules/@lit/reactive-element/node/development/css-tag.js\");\n\n\n\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */ var _a, _b, _c, _d;\nvar _e;\nconst global = globalThis;\n{\n    (_a = global.customElements) !== null && _a !== void 0 ? _a : global.customElements = _lit_labs_ssr_dom_shim__WEBPACK_IMPORTED_MODULE_0__.customElements;\n}let requestUpdateThenable;\nlet issueWarning;\nconst trustedTypes = global.trustedTypes;\n// Temporary workaround for https://crbug.com/993268\n// Currently, any attribute starting with \"on\" is considered to be a\n// TrustedScript source. Such boolean attributes must be set to the equivalent\n// trusted emptyScript value.\nconst emptyStringForBooleanAttribute = trustedTypes ? trustedTypes.emptyScript : \"\";\nconst polyfillSupport = global.reactiveElementPolyfillSupportDevMode;\n{\n    // Ensure warnings are issued only 1x, even if multiple versions of Lit\n    // are loaded.\n    const issuedWarnings = (_b = global.litIssuedWarnings) !== null && _b !== void 0 ? _b : global.litIssuedWarnings = new Set();\n    // Issue a warning, if we haven't already.\n    issueWarning = (code, warning)=>{\n        warning += ` See https://lit.dev/msg/${code} for more information.`;\n        if (!issuedWarnings.has(warning)) {\n            console.warn(warning);\n            issuedWarnings.add(warning);\n        }\n    };\n    issueWarning(\"dev-mode\", `Lit is in dev mode. Not recommended for production!`);\n    // Issue polyfill support warning.\n    if (((_c = global.ShadyDOM) === null || _c === void 0 ? void 0 : _c.inUse) && polyfillSupport === undefined) {\n        issueWarning(\"polyfill-support-missing\", `Shadow DOM is being polyfilled via \\`ShadyDOM\\` but ` + `the \\`polyfill-support\\` module has not been loaded.`);\n    }\n    requestUpdateThenable = (name)=>({\n            then: (onfulfilled, _onrejected)=>{\n                issueWarning(\"request-update-promise\", `The \\`requestUpdate\\` method should no longer return a Promise but ` + `does so on \\`${name}\\`. Use \\`updateComplete\\` instead.`);\n                if (onfulfilled !== undefined) {\n                    onfulfilled(false);\n                }\n            }\n        });\n}/**\n * Useful for visualizing and logging insights into what the Lit template system is doing.\n *\n * Compiled out of prod mode builds.\n */ const debugLogEvent = (event)=>{\n    const shouldEmit = global.emitLitDebugLogEvents;\n    if (!shouldEmit) {\n        return;\n    }\n    global.dispatchEvent(new CustomEvent(\"lit-debug\", {\n        detail: event\n    }));\n};\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */ /*@__INLINE__*/ const JSCompiler_renameProperty = (prop, _obj)=>prop;\nconst defaultConverter = {\n    toAttribute (value, type) {\n        switch(type){\n            case Boolean:\n                value = value ? emptyStringForBooleanAttribute : null;\n                break;\n            case Object:\n            case Array:\n                // if the value is `null` or `undefined` pass this through\n                // to allow removing/no change behavior.\n                value = value == null ? value : JSON.stringify(value);\n                break;\n        }\n        return value;\n    },\n    fromAttribute (value, type) {\n        let fromValue = value;\n        switch(type){\n            case Boolean:\n                fromValue = value !== null;\n                break;\n            case Number:\n                fromValue = value === null ? null : Number(value);\n                break;\n            case Object:\n            case Array:\n                // Do *not* generate exception when invalid JSON is set as elements\n                // don't normally complain on being mis-configured.\n                // TODO(sorvell): Do generate exception in *dev mode*.\n                try {\n                    // Assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n                    fromValue = JSON.parse(value);\n                } catch (e) {\n                    fromValue = null;\n                }\n                break;\n        }\n        return fromValue;\n    }\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */ const notEqual = (value, old)=>{\n    // This ensures (old==NaN, value==NaN) always returns false\n    return old !== value && (old === old || value === value);\n};\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    hasChanged: notEqual\n};\n/**\n * The Closure JS Compiler doesn't currently have good support for static\n * property semantics where \"this\" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */ const finalized = \"finalized\";\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n * @noInheritDoc\n */ class ReactiveElement extends (globalThis.HTMLElement ?? _lit_labs_ssr_dom_shim__WEBPACK_IMPORTED_MODULE_0__.HTMLElement) {\n    constructor(){\n        super();\n        this.__instanceProperties = new Map();\n        /**\n         * True if there is a pending update as a result of calling `requestUpdate()`.\n         * Should only be read.\n         * @category updates\n         */ this.isUpdatePending = false;\n        /**\n         * Is set to `true` after the first update. The element code cannot assume\n         * that `renderRoot` exists before the element `hasUpdated`.\n         * @category updates\n         */ this.hasUpdated = false;\n        /**\n         * Name of currently reflecting property\n         */ this.__reflectingProperty = null;\n        this.__initialize();\n    }\n    /**\n     * Adds an initializer function to the class that is called during instance\n     * construction.\n     *\n     * This is useful for code that runs against a `ReactiveElement`\n     * subclass, such as a decorator, that needs to do work for each\n     * instance, such as setting up a `ReactiveController`.\n     *\n     * ```ts\n     * const myDecorator = (target: typeof ReactiveElement, key: string) => {\n     *   target.addInitializer((instance: ReactiveElement) => {\n     *     // This is run during construction of the element\n     *     new MyController(instance);\n     *   });\n     * }\n     * ```\n     *\n     * Decorating a field will then cause each instance to run an initializer\n     * that adds a controller:\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   @myDecorator foo;\n     * }\n     * ```\n     *\n     * Initializers are stored per-constructor. Adding an initializer to a\n     * subclass does not add it to a superclass. Since initializers are run in\n     * constructors, initializers will run in order of the class hierarchy,\n     * starting with superclasses and progressing to the instance's class.\n     *\n     * @nocollapse\n     */ static addInitializer(initializer) {\n        var _a;\n        this.finalize();\n        ((_a = this._initializers) !== null && _a !== void 0 ? _a : this._initializers = []).push(initializer);\n    }\n    /**\n     * Returns a list of attributes corresponding to the registered properties.\n     * @nocollapse\n     * @category attributes\n     */ static get observedAttributes() {\n        // note: piggy backing on this to ensure we're finalized.\n        this.finalize();\n        const attributes = [];\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.elementProperties.forEach((v, p)=>{\n            const attr = this.__attributeNameForProperty(p, v);\n            if (attr !== undefined) {\n                this.__attributeToPropertyMap.set(attr, p);\n                attributes.push(attr);\n            }\n        });\n        return attributes;\n    }\n    /**\n     * Creates a property accessor on the element prototype if one does not exist\n     * and stores a {@linkcode PropertyDeclaration} for the property with the\n     * given options. The property setter calls the property's `hasChanged`\n     * property option or uses a strict identity check to determine whether or not\n     * to request an update.\n     *\n     * This method may be overridden to customize properties; however,\n     * when doing so, it's important to call `super.createProperty` to ensure\n     * the property is setup correctly. This method calls\n     * `getPropertyDescriptor` internally to get a descriptor to install.\n     * To customize what properties do when they are get or set, override\n     * `getPropertyDescriptor`. To customize the options for a property,\n     * implement `createProperty` like this:\n     *\n     * ```ts\n     * static createProperty(name, options) {\n     *   options = Object.assign(options, {myOption: true});\n     *   super.createProperty(name, options);\n     * }\n     * ```\n     *\n     * @nocollapse\n     * @category properties\n     */ static createProperty(name, options = defaultPropertyDeclaration) {\n        var _a;\n        // if this is a state property, force the attribute to false.\n        if (options.state) {\n            // Cast as any since this is readonly.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            options.attribute = false;\n        }\n        // Note, since this can be called by the `@property` decorator which\n        // is called before `finalize`, we ensure finalization has been kicked off.\n        this.finalize();\n        this.elementProperties.set(name, options);\n        // Do not generate an accessor if the prototype already has one, since\n        // it would be lost otherwise and that would never be the user's intention;\n        // Instead, we expect users to call `requestUpdate` themselves from\n        // user-defined accessors. Note that if the super has an accessor we will\n        // still overwrite it\n        if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {\n            const key = typeof name === \"symbol\" ? Symbol() : `__${name}`;\n            const descriptor = this.getPropertyDescriptor(name, key, options);\n            if (descriptor !== undefined) {\n                Object.defineProperty(this.prototype, name, descriptor);\n                {\n                    // If this class doesn't have its own set, create one and initialize\n                    // with the values in the set from the nearest ancestor class, if any.\n                    if (!this.hasOwnProperty(\"__reactivePropertyKeys\")) {\n                        this.__reactivePropertyKeys = new Set((_a = this.__reactivePropertyKeys) !== null && _a !== void 0 ? _a : []);\n                    }\n                    this.__reactivePropertyKeys.add(name);\n                }\n            }\n        }\n    }\n    /**\n     * Returns a property descriptor to be defined on the given named property.\n     * If no descriptor is returned, the property will not become an accessor.\n     * For example,\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   static getPropertyDescriptor(name, key, options) {\n     *     const defaultDescriptor =\n     *         super.getPropertyDescriptor(name, key, options);\n     *     const setter = defaultDescriptor.set;\n     *     return {\n     *       get: defaultDescriptor.get,\n     *       set(value) {\n     *         setter.call(this, value);\n     *         // custom action.\n     *       },\n     *       configurable: true,\n     *       enumerable: true\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * @nocollapse\n     * @category properties\n     */ static getPropertyDescriptor(name, key, options) {\n        return {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            get () {\n                return this[key];\n            },\n            set (value) {\n                const oldValue = this[name];\n                this[key] = value;\n                this.requestUpdate(name, oldValue, options);\n            },\n            configurable: true,\n            enumerable: true\n        };\n    }\n    /**\n     * Returns the property options associated with the given property.\n     * These options are defined with a `PropertyDeclaration` via the `properties`\n     * object or the `@property` decorator and are registered in\n     * `createProperty(...)`.\n     *\n     * Note, this method should be considered \"final\" and not overridden. To\n     * customize the options for a given property, override\n     * {@linkcode createProperty}.\n     *\n     * @nocollapse\n     * @final\n     * @category properties\n     */ static getPropertyOptions(name) {\n        return this.elementProperties.get(name) || defaultPropertyDeclaration;\n    }\n    /**\n     * Creates property accessors for registered properties, sets up element\n     * styling, and ensures any superclasses are also finalized. Returns true if\n     * the element was finalized.\n     * @nocollapse\n     */ static finalize() {\n        if (this.hasOwnProperty(finalized)) {\n            return false;\n        }\n        this[finalized] = true;\n        // finalize any superclasses\n        const superCtor = Object.getPrototypeOf(this);\n        superCtor.finalize();\n        // Create own set of initializers for this class if any exist on the\n        // superclass and copy them down. Note, for a small perf boost, avoid\n        // creating initializers unless needed.\n        if (superCtor._initializers !== undefined) {\n            this._initializers = [\n                ...superCtor._initializers\n            ];\n        }\n        this.elementProperties = new Map(superCtor.elementProperties);\n        // initialize Map populated in observedAttributes\n        this.__attributeToPropertyMap = new Map();\n        // make any properties\n        // Note, only process \"own\" properties since this element will inherit\n        // any properties defined on the superClass, and finalization ensures\n        // the entire prototype chain is finalized.\n        if (this.hasOwnProperty(JSCompiler_renameProperty(\"properties\"))) {\n            const props = this.properties;\n            // support symbols in properties (IE11 does not support this)\n            const propKeys = [\n                ...Object.getOwnPropertyNames(props),\n                ...Object.getOwnPropertySymbols(props)\n            ];\n            // This for/of is ok because propKeys is an array\n            for (const p of propKeys){\n                // note, use of `any` is due to TypeScript lack of support for symbol in\n                // index types\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                this.createProperty(p, props[p]);\n            }\n        }\n        this.elementStyles = this.finalizeStyles(this.styles);\n        // DEV mode warnings\n        {\n            const warnRemovedOrRenamed = (name, renamed = false)=>{\n                if (this.prototype.hasOwnProperty(name)) {\n                    issueWarning(renamed ? \"renamed-api\" : \"removed-api\", `\\`${name}\\` is implemented on class ${this.name}. It ` + `has been ${renamed ? \"renamed\" : \"removed\"} ` + `in this version of LitElement.`);\n                }\n            };\n            warnRemovedOrRenamed(\"initialize\");\n            warnRemovedOrRenamed(\"requestUpdateInternal\");\n            warnRemovedOrRenamed(\"_getUpdateComplete\", true);\n        }\n        return true;\n    }\n    /**\n     * Takes the styles the user supplied via the `static styles` property and\n     * returns the array of styles to apply to the element.\n     * Override this method to integrate into a style management system.\n     *\n     * Styles are deduplicated preserving the _last_ instance in the list. This\n     * is a performance optimization to avoid duplicated styles that can occur\n     * especially when composing via subclassing. The last item is kept to try\n     * to preserve the cascade order with the assumption that it's most important\n     * that last added styles override previous styles.\n     *\n     * @nocollapse\n     * @category styles\n     */ static finalizeStyles(styles) {\n        const elementStyles = [];\n        if (Array.isArray(styles)) {\n            // Dedupe the flattened array in reverse order to preserve the last items.\n            // Casting to Array<unknown> works around TS error that\n            // appears to come from trying to flatten a type CSSResultArray.\n            const set = new Set(styles.flat(Infinity).reverse());\n            // Then preserve original order by adding the set items in reverse order.\n            for (const s of set){\n                elementStyles.unshift((0,_css_tag_js__WEBPACK_IMPORTED_MODULE_1__.getCompatibleStyle)(s));\n            }\n        } else if (styles !== undefined) {\n            elementStyles.push((0,_css_tag_js__WEBPACK_IMPORTED_MODULE_1__.getCompatibleStyle)(styles));\n        }\n        return elementStyles;\n    }\n    /**\n     * Returns the property name for the given attribute `name`.\n     * @nocollapse\n     */ static __attributeNameForProperty(name, options) {\n        const attribute = options.attribute;\n        return attribute === false ? undefined : typeof attribute === \"string\" ? attribute : typeof name === \"string\" ? name.toLowerCase() : undefined;\n    }\n    /**\n     * Internal only override point for customizing work done when elements\n     * are constructed.\n     */ __initialize() {\n        var _a;\n        this.__updatePromise = new Promise((res)=>this.enableUpdating = res);\n        this._$changedProperties = new Map();\n        this.__saveInstanceProperties();\n        // ensures first update will be caught by an early access of\n        // `updateComplete`\n        this.requestUpdate();\n        (_a = this.constructor._initializers) === null || _a === void 0 ? void 0 : _a.forEach((i)=>i(this));\n    }\n    /**\n     * Registers a `ReactiveController` to participate in the element's reactive\n     * update cycle. The element automatically calls into any registered\n     * controllers during its lifecycle callbacks.\n     *\n     * If the element is connected when `addController()` is called, the\n     * controller's `hostConnected()` callback will be immediately called.\n     * @category controllers\n     */ addController(controller) {\n        var _a, _b;\n        ((_a = this.__controllers) !== null && _a !== void 0 ? _a : this.__controllers = []).push(controller);\n        // If a controller is added after the element has been connected,\n        // call hostConnected. Note, re-using existence of `renderRoot` here\n        // (which is set in connectedCallback) to avoid the need to track a\n        // first connected state.\n        if (this.renderRoot !== undefined && this.isConnected) {\n            (_b = controller.hostConnected) === null || _b === void 0 ? void 0 : _b.call(controller);\n        }\n    }\n    /**\n     * Removes a `ReactiveController` from the element.\n     * @category controllers\n     */ removeController(controller) {\n        var _a;\n        // Note, if the indexOf is -1, the >>> will flip the sign which makes the\n        // splice do nothing.\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);\n    }\n    /**\n     * Fixes any properties set on the instance before upgrade time.\n     * Otherwise these would shadow the accessor and break these properties.\n     * The properties are stored in a Map which is played back after the\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n     * (<=41), properties created for native platform properties like (`id` or\n     * `name`) may not have default values set in the element constructor. On\n     * these browsers native properties appear on instances and therefore their\n     * default value will overwrite any element default (e.g. if the element sets\n     * this.id = 'id' in the constructor, the 'id' will become '' since this is\n     * the native platform default).\n     */ __saveInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.constructor.elementProperties.forEach((_v, p)=>{\n            if (this.hasOwnProperty(p)) {\n                this.__instanceProperties.set(p, this[p]);\n                delete this[p];\n            }\n        });\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element's DOM is rendered. For example, to render into the element's\n     * childNodes, return `this`.\n     *\n     * @return Returns a node into which to render.\n     * @category rendering\n     */ createRenderRoot() {\n        var _a;\n        const renderRoot = (_a = this.shadowRoot) !== null && _a !== void 0 ? _a : this.attachShadow(this.constructor.shadowRootOptions);\n        (0,_css_tag_js__WEBPACK_IMPORTED_MODULE_1__.adoptStyles)(renderRoot, this.constructor.elementStyles);\n        return renderRoot;\n    }\n    /**\n     * On first connection, creates the element's renderRoot, sets up\n     * element styling, and enables updating.\n     * @category lifecycle\n     */ connectedCallback() {\n        var _a;\n        // create renderRoot before first update.\n        if (this.renderRoot === undefined) {\n            this.renderRoot = this.createRenderRoot();\n        }\n        this.enableUpdating(true);\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c)=>{\n            var _a;\n            return (_a = c.hostConnected) === null || _a === void 0 ? void 0 : _a.call(c);\n        });\n    }\n    /**\n     * Note, this method should be considered final and not overridden. It is\n     * overridden on the element instance with a function that triggers the first\n     * update.\n     * @category updates\n     */ enableUpdating(_requestedUpdate) {}\n    /**\n     * Allows for `super.disconnectedCallback()` in extensions while\n     * reserving the possibility of making non-breaking feature additions\n     * when disconnecting at some point in the future.\n     * @category lifecycle\n     */ disconnectedCallback() {\n        var _a;\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c)=>{\n            var _a;\n            return (_a = c.hostDisconnected) === null || _a === void 0 ? void 0 : _a.call(c);\n        });\n    }\n    /**\n     * Synchronizes property values when attributes change.\n     *\n     * Specifically, when an attribute is set, the corresponding property is set.\n     * You should rarely need to implement this callback. If this method is\n     * overridden, `super.attributeChangedCallback(name, _old, value)` must be\n     * called.\n     *\n     * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)\n     * on MDN for more information about the `attributeChangedCallback`.\n     * @category attributes\n     */ attributeChangedCallback(name, _old, value) {\n        this._$attributeToProperty(name, value);\n    }\n    __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\n        var _a;\n        const attr = this.constructor.__attributeNameForProperty(name, options);\n        if (attr !== undefined && options.reflect === true) {\n            const converter = ((_a = options.converter) === null || _a === void 0 ? void 0 : _a.toAttribute) !== undefined ? options.converter : defaultConverter;\n            const attrValue = converter.toAttribute(value, options.type);\n            if (this.constructor.enabledWarnings.indexOf(\"migration\") >= 0 && attrValue === undefined) {\n                issueWarning(\"undefined-attribute-value\", `The attribute value for the ${name} property is ` + `undefined on element ${this.localName}. The attribute will be ` + `removed, but in the previous version of \\`ReactiveElement\\`, ` + `the attribute would not have changed.`);\n            }\n            // Track if the property is being reflected to avoid\n            // setting the property again via `attributeChangedCallback`. Note:\n            // 1. this takes advantage of the fact that the callback is synchronous.\n            // 2. will behave incorrectly if multiple attributes are in the reaction\n            // stack at time of calling. However, since we process attributes\n            // in `update` this should not be possible (or an extreme corner case\n            // that we'd like to discover).\n            // mark state reflecting\n            this.__reflectingProperty = name;\n            if (attrValue == null) {\n                this.removeAttribute(attr);\n            } else {\n                this.setAttribute(attr, attrValue);\n            }\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /** @internal */ _$attributeToProperty(name, value) {\n        var _a;\n        const ctor = this.constructor;\n        // Note, hint this as an `AttributeMap` so closure clearly understands\n        // the type; it has issues with tracking types through statics\n        const propName = ctor.__attributeToPropertyMap.get(name);\n        // Use tracking info to avoid reflecting a property value to an attribute\n        // if it was just set because the attribute changed.\n        if (propName !== undefined && this.__reflectingProperty !== propName) {\n            const options = ctor.getPropertyOptions(propName);\n            const converter = typeof options.converter === \"function\" ? {\n                fromAttribute: options.converter\n            } : ((_a = options.converter) === null || _a === void 0 ? void 0 : _a.fromAttribute) !== undefined ? options.converter : defaultConverter;\n            // mark state reflecting\n            this.__reflectingProperty = propName;\n            this[propName] = converter.fromAttribute(value, options.type);\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /**\n     * Requests an update which is processed asynchronously. This should be called\n     * when an element should update based on some state not triggered by setting\n     * a reactive property. In this case, pass no arguments. It should also be\n     * called when manually implementing a property setter. In this case, pass the\n     * property `name` and `oldValue` to ensure that any configured property\n     * options are honored.\n     *\n     * @param name name of requesting property\n     * @param oldValue old value of requesting property\n     * @param options property options to use instead of the previously\n     *     configured options\n     * @category updates\n     */ requestUpdate(name, oldValue, options) {\n        let shouldRequestUpdate = true;\n        // If we have a property key, perform property update steps.\n        if (name !== undefined) {\n            options = options || this.constructor.getPropertyOptions(name);\n            const hasChanged = options.hasChanged || notEqual;\n            if (hasChanged(this[name], oldValue)) {\n                if (!this._$changedProperties.has(name)) {\n                    this._$changedProperties.set(name, oldValue);\n                }\n                // Add to reflecting properties set.\n                // Note, it's important that every change has a chance to add the\n                // property to `_reflectingProperties`. This ensures setting\n                // attribute + property reflects correctly.\n                if (options.reflect === true && this.__reflectingProperty !== name) {\n                    if (this.__reflectingProperties === undefined) {\n                        this.__reflectingProperties = new Map();\n                    }\n                    this.__reflectingProperties.set(name, options);\n                }\n            } else {\n                // Abort the request if the property should not be considered changed.\n                shouldRequestUpdate = false;\n            }\n        }\n        if (!this.isUpdatePending && shouldRequestUpdate) {\n            this.__updatePromise = this.__enqueueUpdate();\n        }\n        // Note, since this no longer returns a promise, in dev mode we return a\n        // thenable which warns if it's called.\n        return requestUpdateThenable(this.localName);\n    }\n    /**\n     * Sets up the element to asynchronously update.\n     */ async __enqueueUpdate() {\n        this.isUpdatePending = true;\n        try {\n            // Ensure any previous update has resolved before updating.\n            // This `await` also ensures that property changes are batched.\n            await this.__updatePromise;\n        } catch (e) {\n            // Refire any previous errors async so they do not disrupt the update\n            // cycle. Errors are refired so developers have a chance to observe\n            // them, and this can be done by implementing\n            // `window.onunhandledrejection`.\n            Promise.reject(e);\n        }\n        const result = this.scheduleUpdate();\n        // If `scheduleUpdate` returns a Promise, we await it. This is done to\n        // enable coordinating updates with a scheduler. Note, the result is\n        // checked to avoid delaying an additional microtask unless we need to.\n        if (result != null) {\n            await result;\n        }\n        return !this.isUpdatePending;\n    }\n    /**\n     * Schedules an element update. You can override this method to change the\n     * timing of updates by returning a Promise. The update will await the\n     * returned Promise, and you should resolve the Promise to allow the update\n     * to proceed. If this method is overridden, `super.scheduleUpdate()`\n     * must be called.\n     *\n     * For instance, to schedule updates to occur just before the next frame:\n     *\n     * ```ts\n     * override protected async scheduleUpdate(): Promise<unknown> {\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n     *   super.scheduleUpdate();\n     * }\n     * ```\n     * @category updates\n     */ scheduleUpdate() {\n        return this.performUpdate();\n    }\n    /**\n     * Performs an element update. Note, if an exception is thrown during the\n     * update, `firstUpdated` and `updated` will not be called.\n     *\n     * Call `performUpdate()` to immediately process a pending update. This should\n     * generally not be needed, but it can be done in rare cases when you need to\n     * update synchronously.\n     *\n     * Note: To ensure `performUpdate()` synchronously completes a pending update,\n     * it should not be overridden. In LitElement 2.x it was suggested to override\n     * `performUpdate()` to also customizing update scheduling. Instead, you should now\n     * override `scheduleUpdate()`. For backwards compatibility with LitElement 2.x,\n     * scheduling updates via `performUpdate()` continues to work, but will make\n     * also calling `performUpdate()` to synchronously process updates difficult.\n     *\n     * @category updates\n     */ performUpdate() {\n        var _a, _b;\n        // Abort any update if one is not pending when this is called.\n        // This can happen if `performUpdate` is called early to \"flush\"\n        // the update.\n        if (!this.isUpdatePending) {\n            return;\n        }\n        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n            kind: \"update\"\n        });\n        // create renderRoot before first update.\n        if (!this.hasUpdated) {\n            // Produce warning if any class properties are shadowed by class fields\n            {\n                const shadowedProperties = [];\n                (_a = this.constructor.__reactivePropertyKeys) === null || _a === void 0 ? void 0 : _a.forEach((p)=>{\n                    var _a;\n                    if (this.hasOwnProperty(p) && !((_a = this.__instanceProperties) === null || _a === void 0 ? void 0 : _a.has(p))) {\n                        shadowedProperties.push(p);\n                    }\n                });\n                if (shadowedProperties.length) {\n                    throw new Error(`The following properties on element ${this.localName} will not ` + `trigger updates as expected because they are set using class ` + `fields: ${shadowedProperties.join(\", \")}. ` + `Native class fields and some compiled output will overwrite ` + `accessors used for detecting changes. See ` + `https://lit.dev/msg/class-field-shadowing ` + `for more information.`);\n                }\n            }\n        }\n        // Mixin instance properties once, if they exist.\n        if (this.__instanceProperties) {\n            // Use forEach so this works even if for/of loops are compiled to for loops\n            // expecting arrays\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.__instanceProperties.forEach((v, p)=>this[p] = v);\n            this.__instanceProperties = undefined;\n        }\n        let shouldUpdate = false;\n        const changedProperties = this._$changedProperties;\n        try {\n            shouldUpdate = this.shouldUpdate(changedProperties);\n            if (shouldUpdate) {\n                this.willUpdate(changedProperties);\n                (_b = this.__controllers) === null || _b === void 0 ? void 0 : _b.forEach((c)=>{\n                    var _a;\n                    return (_a = c.hostUpdate) === null || _a === void 0 ? void 0 : _a.call(c);\n                });\n                this.update(changedProperties);\n            } else {\n                this.__markUpdated();\n            }\n        } catch (e) {\n            // Prevent `firstUpdated` and `updated` from running when there's an\n            // update exception.\n            shouldUpdate = false;\n            // Ensure element can accept additional updates after an exception.\n            this.__markUpdated();\n            throw e;\n        }\n        // The update is no longer considered pending and further updates are now allowed.\n        if (shouldUpdate) {\n            this._$didUpdate(changedProperties);\n        }\n    }\n    /**\n     * Invoked before `update()` to compute values needed during the update.\n     *\n     * Implement `willUpdate` to compute property values that depend on other\n     * properties and are used in the rest of the update process.\n     *\n     * ```ts\n     * willUpdate(changedProperties) {\n     *   // only need to check changed properties for an expensive computation.\n     *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {\n     *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);\n     *   }\n     * }\n     *\n     * render() {\n     *   return html`SHA: ${this.sha}`;\n     * }\n     * ```\n     *\n     * @category updates\n     */ willUpdate(_changedProperties) {}\n    // Note, this is an override point for polyfill-support.\n    // @internal\n    _$didUpdate(changedProperties) {\n        var _a;\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c)=>{\n            var _a;\n            return (_a = c.hostUpdated) === null || _a === void 0 ? void 0 : _a.call(c);\n        });\n        if (!this.hasUpdated) {\n            this.hasUpdated = true;\n            this.firstUpdated(changedProperties);\n        }\n        this.updated(changedProperties);\n        if (this.isUpdatePending && this.constructor.enabledWarnings.indexOf(\"change-in-update\") >= 0) {\n            issueWarning(\"change-in-update\", `Element ${this.localName} scheduled an update ` + `(generally because a property was set) ` + `after an update completed, causing a new update to be scheduled. ` + `This is inefficient and should be avoided unless the next update ` + `can only be scheduled as a side effect of the previous update.`);\n        }\n    }\n    __markUpdated() {\n        this._$changedProperties = new Map();\n        this.isUpdatePending = false;\n    }\n    /**\n     * Returns a Promise that resolves when the element has completed updating.\n     * The Promise value is a boolean that is `true` if the element completed the\n     * update without triggering another update. The Promise result is `false` if\n     * a property was set inside `updated()`. If the Promise is rejected, an\n     * exception was thrown during the update.\n     *\n     * To await additional asynchronous work, override the `getUpdateComplete`\n     * method. For example, it is sometimes useful to await a rendered element\n     * before fulfilling this Promise. To do this, first await\n     * `super.getUpdateComplete()`, then any subsequent state.\n     *\n     * @return A promise of a boolean that resolves to true if the update completed\n     *     without triggering another update.\n     * @category updates\n     */ get updateComplete() {\n        return this.getUpdateComplete();\n    }\n    /**\n     * Override point for the `updateComplete` promise.\n     *\n     * It is not safe to override the `updateComplete` getter directly due to a\n     * limitation in TypeScript which means it is not possible to call a\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n     * This method should be overridden instead. For example:\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   override async getUpdateComplete() {\n     *     const result = await super.getUpdateComplete();\n     *     await this._myChild.updateComplete;\n     *     return result;\n     *   }\n     * }\n     * ```\n     *\n     * @return A promise of a boolean that resolves to true if the update completed\n     *     without triggering another update.\n     * @category updates\n     */ getUpdateComplete() {\n        return this.__updatePromise;\n    }\n    /**\n     * Controls whether or not `update()` should be called when the element requests\n     * an update. By default, this method always returns `true`, but this can be\n     * customized to control when to update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */ shouldUpdate(_changedProperties) {\n        return true;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes.\n     * It can be overridden to render and keep updated element DOM.\n     * Setting properties inside this method will *not* trigger\n     * another update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */ update(_changedProperties) {\n        if (this.__reflectingProperties !== undefined) {\n            // Use forEach so this works even if for/of loops are compiled to for\n            // loops expecting arrays\n            this.__reflectingProperties.forEach((v, k)=>this.__propertyToAttribute(k, this[k], v));\n            this.__reflectingProperties = undefined;\n        }\n        this.__markUpdated();\n    }\n    /**\n     * Invoked whenever the element is updated. Implement to perform\n     * post-updating tasks via DOM APIs, for example, focusing an element.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */ updated(_changedProperties) {}\n    /**\n     * Invoked when the element is first updated. Implement to perform one time\n     * work on the element after update.\n     *\n     * ```ts\n     * firstUpdated() {\n     *   this.renderRoot.getElementById('my-text-area').focus();\n     * }\n     * ```\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */ firstUpdated(_changedProperties) {}\n}\n_e = finalized;\n/**\n * Marks class as having finished creating properties.\n */ ReactiveElement[_e] = true;\n/**\n * Memoized list of all element properties, including any superclass properties.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category properties\n */ ReactiveElement.elementProperties = new Map();\n/**\n * Memoized list of all element styles.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category styles\n */ ReactiveElement.elementStyles = [];\n/**\n * Options used when calling `attachShadow`. Set this property to customize\n * the options for the shadowRoot; for example, to create a closed\n * shadowRoot: `{mode: 'closed'}`.\n *\n * Note, these options are used in `createRenderRoot`. If this method\n * is customized, options should be respected if possible.\n * @nocollapse\n * @category rendering\n */ ReactiveElement.shadowRootOptions = {\n    mode: \"open\"\n};\n// Apply polyfills if available\npolyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport({\n    ReactiveElement\n});\n// Dev mode warnings...\n{\n    // Default warning set.\n    ReactiveElement.enabledWarnings = [\n        \"change-in-update\"\n    ];\n    const ensureOwnWarnings = function(ctor) {\n        if (!ctor.hasOwnProperty(JSCompiler_renameProperty(\"enabledWarnings\"))) {\n            ctor.enabledWarnings = ctor.enabledWarnings.slice();\n        }\n    };\n    ReactiveElement.enableWarning = function(warning) {\n        ensureOwnWarnings(this);\n        if (this.enabledWarnings.indexOf(warning) < 0) {\n            this.enabledWarnings.push(warning);\n        }\n    };\n    ReactiveElement.disableWarning = function(warning) {\n        ensureOwnWarnings(this);\n        const i = this.enabledWarnings.indexOf(warning);\n        if (i >= 0) {\n            this.enabledWarnings.splice(i, 1);\n        }\n    };\n}// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for ReactiveElement usage.\n((_d = global.reactiveElementVersions) !== null && _d !== void 0 ? _d : global.reactiveElementVersions = []).push(\"1.6.3\");\nif (global.reactiveElementVersions.length > 1) {\n    issueWarning(\"multiple-versions\", `Multiple versions of Lit loaded. Loading multiple versions ` + `is not recommended.`);\n}\n //# sourceMappingURL=reactive-element.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvcmVhY3RpdmUtZWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUNOO0FBQ3dEO0FBRXZIOzs7O0NBSUMsR0FDRCxJQUFJUSxJQUFJQyxJQUFJQyxJQUFJQztBQUNoQixJQUFJQztBQUNKLE1BQU1DLFNBQVNDO0FBQ2Y7SUFDS04sQ0FBQUEsS0FBS0ssT0FBT2IsY0FBYyxNQUFNLFFBQVFRLE9BQU8sS0FBSyxJQUFJQSxLQUFNSyxPQUFPYixjQUFjLEdBQUdBLGtFQUFjQTtBQUN6RyxDQUNBLElBQUllO0FBQ0osSUFBSUM7QUFDSixNQUFNQyxlQUFlSixPQUNoQkksWUFBWTtBQUNqQixvREFBb0Q7QUFDcEQsb0VBQW9FO0FBQ3BFLDhFQUE4RTtBQUM5RSw2QkFBNkI7QUFDN0IsTUFBTUMsaUNBQWlDRCxlQUNqQ0EsYUFBYUUsV0FBVyxHQUN4QjtBQUNOLE1BQU1DLGtCQUFrQlAsT0FBT1EscUNBQXFDO0FBRXBFO0lBQ0ksdUVBQXVFO0lBQ3ZFLGNBQWM7SUFDZCxNQUFNQyxpQkFBa0IsQ0FBQ2IsS0FBS0ksT0FBT1UsaUJBQWlCLE1BQU0sUUFBUWQsT0FBTyxLQUFLLElBQUlBLEtBQU1JLE9BQU9VLGlCQUFpQixHQUFHLElBQUlDO0lBQ3pILDBDQUEwQztJQUMxQ1IsZUFBZSxDQUFDUyxNQUFNQztRQUNsQkEsV0FBVyxDQUFDLHlCQUF5QixFQUFFRCxLQUFLLHNCQUFzQixDQUFDO1FBQ25FLElBQUksQ0FBQ0gsZUFBZUssR0FBRyxDQUFDRCxVQUFVO1lBQzlCRSxRQUFRQyxJQUFJLENBQUNIO1lBQ2JKLGVBQWVRLEdBQUcsQ0FBQ0o7UUFDdkI7SUFDSjtJQUNBVixhQUFhLFlBQVksQ0FBQyxtREFBbUQsQ0FBQztJQUM5RSxrQ0FBa0M7SUFDbEMsSUFBSSxDQUFDLENBQUNOLEtBQUtHLE9BQU9rQixRQUFRLE1BQU0sUUFBUXJC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QUNuQztJQUNKO0FBQ0osQ0FHQSwyRUFGMkU7QUFDM0UseUVBQXlFO0FBQ3hFLEVBQUM5SCxLQUFLRSxPQUFPMkwsdUJBQXVCLE1BQU0sUUFBUTdMLE9BQU8sS0FBSyxJQUFJQSxLQUFNRSxPQUFPMkwsdUJBQXVCLEdBQUcsRUFBRSxFQUFHckgsSUFBSSxDQUFDO0FBQ3BILElBQUl0RSxPQUFPMkwsdUJBQXVCLENBQUN0QixNQUFNLEdBQUcsR0FBRztJQUMzQ2xLLGFBQWEscUJBQXFCLENBQUMsMkRBQTJELENBQUMsR0FDM0YsQ0FBQyxtQkFBbUIsQ0FBQztBQUM3QjtBQUV1RCxDQUN2RCw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvQGxpdC9yZWFjdGl2ZS1lbGVtZW50L25vZGUvZGV2ZWxvcG1lbnQvcmVhY3RpdmUtZWxlbWVudC5qcz84NDU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGN1c3RvbUVsZW1lbnRzLCBIVE1MRWxlbWVudCB9IGZyb20gJ0BsaXQtbGFicy9zc3ItZG9tLXNoaW0nO1xuaW1wb3J0IHsgZ2V0Q29tcGF0aWJsZVN0eWxlLCBhZG9wdFN0eWxlcyB9IGZyb20gJy4vY3NzLXRhZy5qcyc7XG5leHBvcnQgeyBDU1NSZXN1bHQsIGFkb3B0U3R5bGVzLCBjc3MsIGdldENvbXBhdGlibGVTdHlsZSwgc3VwcG9ydHNBZG9wdGluZ1N0eWxlU2hlZXRzLCB1bnNhZmVDU1MgfSBmcm9tICcuL2Nzcy10YWcuanMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cbnZhciBfYSwgX2IsIF9jLCBfZDtcbnZhciBfZTtcbmNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXMgO1xue1xuICAgIChfYSA9IGdsb2JhbC5jdXN0b21FbGVtZW50cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGdsb2JhbC5jdXN0b21FbGVtZW50cyA9IGN1c3RvbUVsZW1lbnRzKTtcbn1cbmxldCByZXF1ZXN0VXBkYXRlVGhlbmFibGU7XG5sZXQgaXNzdWVXYXJuaW5nO1xuY29uc3QgdHJ1c3RlZFR5cGVzID0gZ2xvYmFsXG4gICAgLnRydXN0ZWRUeXBlcztcbi8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBodHRwczovL2NyYnVnLmNvbS85OTMyNjhcbi8vIEN1cnJlbnRseSwgYW55IGF0dHJpYnV0ZSBzdGFydGluZyB3aXRoIFwib25cIiBpcyBjb25zaWRlcmVkIHRvIGJlIGFcbi8vIFRydXN0ZWRTY3JpcHQgc291cmNlLiBTdWNoIGJvb2xlYW4gYXR0cmlidXRlcyBtdXN0IGJlIHNldCB0byB0aGUgZXF1aXZhbGVudFxuLy8gdHJ1c3RlZCBlbXB0eVNjcmlwdCB2YWx1ZS5cbmNvbnN0IGVtcHR5U3RyaW5nRm9yQm9vbGVhbkF0dHJpYnV0ZSA9IHRydXN0ZWRUeXBlc1xuICAgID8gdHJ1c3RlZFR5cGVzLmVtcHR5U2NyaXB0XG4gICAgOiAnJztcbmNvbnN0IHBvbHlmaWxsU3VwcG9ydCA9IGdsb2JhbC5yZWFjdGl2ZUVsZW1lbnRQb2x5ZmlsbFN1cHBvcnREZXZNb2RlXG4gICAgO1xue1xuICAgIC8vIEVuc3VyZSB3YXJuaW5ncyBhcmUgaXNzdWVkIG9ubHkgMXgsIGV2ZW4gaWYgbXVsdGlwbGUgdmVyc2lvbnMgb2YgTGl0XG4gICAgLy8gYXJlIGxvYWRlZC5cbiAgICBjb25zdCBpc3N1ZWRXYXJuaW5ncyA9ICgoX2IgPSBnbG9iYWwubGl0SXNzdWVkV2FybmluZ3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChnbG9iYWwubGl0SXNzdWVkV2FybmluZ3MgPSBuZXcgU2V0KCkpKTtcbiAgICAvLyBJc3N1ZSBhIHdhcm5pbmcsIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeS5cbiAgICBpc3N1ZVdhcm5pbmcgPSAoY29kZSwgd2FybmluZykgPT4ge1xuICAgICAgICB3YXJuaW5nICs9IGAgU2VlIGh0dHBzOi8vbGl0LmRldi9tc2cvJHtjb2RlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gO1xuICAgICAgICBpZiAoIWlzc3VlZFdhcm5pbmdzLmhhcyh3YXJuaW5nKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgICAgICAgICAgaXNzdWVkV2FybmluZ3MuYWRkKHdhcm5pbmcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpc3N1ZVdhcm5pbmcoJ2Rldi1tb2RlJywgYExpdCBpcyBpbiBkZXYgbW9kZS4gTm90IHJlY29tbWVuZGVkIGZvciBwcm9kdWN0aW9uIWApO1xuICAgIC8vIElzc3VlIHBvbHlmaWxsIHN1cHBvcnQgd2FybmluZy5cbiAgICBpZiAoKChfYyA9IGdsb2JhbC5TaGFkeURPTSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmluVXNlKSAmJiBwb2x5ZmlsbFN1cHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpc3N1ZVdhcm5pbmcoJ3BvbHlmaWxsLXN1cHBvcnQtbWlzc2luZycsIGBTaGFkb3cgRE9NIGlzIGJlaW5nIHBvbHlmaWxsZWQgdmlhIFxcYFNoYWR5RE9NXFxgIGJ1dCBgICtcbiAgICAgICAgICAgIGB0aGUgXFxgcG9seWZpbGwtc3VwcG9ydFxcYCBtb2R1bGUgaGFzIG5vdCBiZWVuIGxvYWRlZC5gKTtcbiAgICB9XG4gICAgcmVxdWVzdFVwZGF0ZVRoZW5hYmxlID0gKG5hbWUpID0+ICh7XG4gICAgICAgIHRoZW46IChvbmZ1bGZpbGxlZCwgX29ucmVqZWN0ZWQpID0+IHtcbiAgICAgICAgICAgIGlzc3VlV2FybmluZygncmVxdWVzdC11cGRhdGUtcHJvbWlzZScsIGBUaGUgXFxgcmVxdWVzdFVwZGF0ZVxcYCBtZXRob2Qgc2hvdWxkIG5vIGxvbmdlciByZXR1cm4gYSBQcm9taXNlIGJ1dCBgICtcbiAgICAgICAgICAgICAgICBgZG9lcyBzbyBvbiBcXGAke25hbWV9XFxgLiBVc2UgXFxgdXBkYXRlQ29tcGxldGVcXGAgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgIGlmIChvbmZ1bGZpbGxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb25mdWxmaWxsZWQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBVc2VmdWwgZm9yIHZpc3VhbGl6aW5nIGFuZCBsb2dnaW5nIGluc2lnaHRzIGludG8gd2hhdCB0aGUgTGl0IHRlbXBsYXRlIHN5c3RlbSBpcyBkb2luZy5cbiAqXG4gKiBDb21waWxlZCBvdXQgb2YgcHJvZCBtb2RlIGJ1aWxkcy5cbiAqL1xuY29uc3QgZGVidWdMb2dFdmVudCA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBzaG91bGRFbWl0ID0gZ2xvYmFsXG4gICAgICAgICAgICAuZW1pdExpdERlYnVnTG9nRXZlbnRzO1xuICAgICAgICBpZiAoIXNob3VsZEVtaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2xpdC1kZWJ1ZycsIHtcbiAgICAgICAgICAgIGRldGFpbDogZXZlbnQsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgO1xuLypcbiAqIFdoZW4gdXNpbmcgQ2xvc3VyZSBDb21waWxlciwgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eShwcm9wZXJ0eSwgb2JqZWN0KSBpc1xuICogcmVwbGFjZWQgYXQgY29tcGlsZSB0aW1lIGJ5IHRoZSBtdW5nZWQgbmFtZSBmb3Igb2JqZWN0W3Byb3BlcnR5XS4gV2UgY2Fubm90XG4gKiBhbGlhcyB0aGlzIGZ1bmN0aW9uLCBzbyB3ZSBoYXZlIHRvIHVzZSBhIHNtYWxsIHNoaW0gdGhhdCBoYXMgdGhlIHNhbWVcbiAqIGJlaGF2aW9yIHdoZW4gbm90IGNvbXBpbGluZy5cbiAqL1xuLypAX19JTkxJTkVfXyovXG5jb25zdCBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5ID0gKHByb3AsIF9vYmopID0+IHByb3A7XG5jb25zdCBkZWZhdWx0Q29udmVydGVyID0ge1xuICAgIHRvQXR0cmlidXRlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyBlbXB0eVN0cmluZ0ZvckJvb2xlYW5BdHRyaWJ1dGUgOiBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgcGFzcyB0aGlzIHRocm91Z2hcbiAgICAgICAgICAgICAgICAvLyB0byBhbGxvdyByZW1vdmluZy9ubyBjaGFuZ2UgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZnJvbUF0dHJpYnV0ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBsZXQgZnJvbVZhbHVlID0gdmFsdWU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgICAgIGZyb21WYWx1ZSA9IHZhbHVlICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgICAgICAgZnJvbVZhbHVlID0gdmFsdWUgPT09IG51bGwgPyBudWxsIDogTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgICAgICAvLyBEbyAqbm90KiBnZW5lcmF0ZSBleGNlcHRpb24gd2hlbiBpbnZhbGlkIEpTT04gaXMgc2V0IGFzIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgbm9ybWFsbHkgY29tcGxhaW4gb24gYmVpbmcgbWlzLWNvbmZpZ3VyZWQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogRG8gZ2VuZXJhdGUgZXhjZXB0aW9uIGluICpkZXYgbW9kZSouXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzZXJ0IHRvIGFkaGVyZSB0byBCYXplbCdzIFwibXVzdCB0eXBlIGFzc2VydCBKU09OIHBhcnNlXCIgcnVsZS5cbiAgICAgICAgICAgICAgICAgICAgZnJvbVZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tVmFsdWU7XG4gICAgfSxcbn07XG4vKipcbiAqIENoYW5nZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGRpZmZlcmVudCBmcm9tIGBvbGRWYWx1ZWAuXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IGZvciBhIHByb3BlcnR5J3MgYGhhc0NoYW5nZWRgIGZ1bmN0aW9uLlxuICovXG5jb25zdCBub3RFcXVhbCA9ICh2YWx1ZSwgb2xkKSA9PiB7XG4gICAgLy8gVGhpcyBlbnN1cmVzIChvbGQ9PU5hTiwgdmFsdWU9PU5hTikgYWx3YXlzIHJldHVybnMgZmFsc2VcbiAgICByZXR1cm4gb2xkICE9PSB2YWx1ZSAmJiAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKTtcbn07XG5jb25zdCBkZWZhdWx0UHJvcGVydHlEZWNsYXJhdGlvbiA9IHtcbiAgICBhdHRyaWJ1dGU6IHRydWUsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGNvbnZlcnRlcjogZGVmYXVsdENvbnZlcnRlcixcbiAgICByZWZsZWN0OiBmYWxzZSxcbiAgICBoYXNDaGFuZ2VkOiBub3RFcXVhbCxcbn07XG4vKipcbiAqIFRoZSBDbG9zdXJlIEpTIENvbXBpbGVyIGRvZXNuJ3QgY3VycmVudGx5IGhhdmUgZ29vZCBzdXBwb3J0IGZvciBzdGF0aWNcbiAqIHByb3BlcnR5IHNlbWFudGljcyB3aGVyZSBcInRoaXNcIiBpcyBkeW5hbWljIChlLmcuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvaXNzdWVzLzMxNzcgYW5kIG90aGVycykgc28gd2UgdXNlXG4gKiB0aGlzIGhhY2sgdG8gYnlwYXNzIGFueSByZXdyaXRpbmcgYnkgdGhlIGNvbXBpbGVyLlxuICovXG5jb25zdCBmaW5hbGl6ZWQgPSAnZmluYWxpemVkJztcbi8qKlxuICogQmFzZSBlbGVtZW50IGNsYXNzIHdoaWNoIG1hbmFnZXMgZWxlbWVudCBwcm9wZXJ0aWVzIGFuZCBhdHRyaWJ1dGVzLiBXaGVuXG4gKiBwcm9wZXJ0aWVzIGNoYW5nZSwgdGhlIGB1cGRhdGVgIG1ldGhvZCBpcyBhc3luY2hyb25vdXNseSBjYWxsZWQuIFRoaXMgbWV0aG9kXG4gKiBzaG91bGQgYmUgc3VwcGxpZWQgYnkgc3ViY2xhc3NlcnMgdG8gcmVuZGVyIHVwZGF0ZXMgYXMgZGVzaXJlZC5cbiAqIEBub0luaGVyaXREb2NcbiAqL1xuY2xhc3MgUmVhY3RpdmVFbGVtZW50XG4vLyBJbiB0aGUgTm9kZSBidWlsZCwgdGhpcyBgZXh0ZW5kc2AgY2xhdXNlIHdpbGwgYmUgc3Vic3RpdHV0ZWQgd2l0aFxuLy8gYChnbG9iYWxUaGlzLkhUTUxFbGVtZW50ID8/IEhUTUxFbGVtZW50KWAuXG4vL1xuLy8gVGhpcyB3YXksIHdlIHdpbGwgZmlyc3QgcHJlZmVyIGFueSBnbG9iYWwgYEhUTUxFbGVtZW50YCBwb2x5ZmlsbCB0aGF0IHRoZVxuLy8gdXNlciBoYXMgYXNzaWduZWQsIGFuZCB0aGVuIGZhbGwgYmFjayB0byB0aGUgYEhUTUxFbGVtZW50YCBzaGltIHdoaWNoIGhhc1xuLy8gYmVlbiBpbXBvcnRlZCAoc2VlIG5vdGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUgYWJvdXQgaG93IHRoaXMgaW1wb3J0IGlzXG4vLyBnZW5lcmF0ZWQgYnkgUm9sbHVwKS4gTm90ZSB0aGF0IHRoZSBgSFRNTEVsZW1lbnRgIHZhcmlhYmxlIGhhcyBiZWVuXG4vLyBzaGFkb3dlZCBieSB0aGlzIGltcG9ydCwgc28gaXQgbm8gbG9uZ2VyIHJlZmVycyB0byB0aGUgZ2xvYmFsLlxuIGV4dGVuZHMgKGdsb2JhbFRoaXMuSFRNTEVsZW1lbnQgPz8gSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHVwZGF0ZSBhcyBhIHJlc3VsdCBvZiBjYWxsaW5nIGByZXF1ZXN0VXBkYXRlKClgLlxuICAgICAgICAgKiBTaG91bGQgb25seSBiZSByZWFkLlxuICAgICAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1VwZGF0ZVBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIHNldCB0byBgdHJ1ZWAgYWZ0ZXIgdGhlIGZpcnN0IHVwZGF0ZS4gVGhlIGVsZW1lbnQgY29kZSBjYW5ub3QgYXNzdW1lXG4gICAgICAgICAqIHRoYXQgYHJlbmRlclJvb3RgIGV4aXN0cyBiZWZvcmUgdGhlIGVsZW1lbnQgYGhhc1VwZGF0ZWRgLlxuICAgICAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIGN1cnJlbnRseSByZWZsZWN0aW5nIHByb3BlcnR5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBpbml0aWFsaXplciBmdW5jdGlvbiB0byB0aGUgY2xhc3MgdGhhdCBpcyBjYWxsZWQgZHVyaW5nIGluc3RhbmNlXG4gICAgICogY29uc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvZGUgdGhhdCBydW5zIGFnYWluc3QgYSBgUmVhY3RpdmVFbGVtZW50YFxuICAgICAqIHN1YmNsYXNzLCBzdWNoIGFzIGEgZGVjb3JhdG9yLCB0aGF0IG5lZWRzIHRvIGRvIHdvcmsgZm9yIGVhY2hcbiAgICAgKiBpbnN0YW5jZSwgc3VjaCBhcyBzZXR0aW5nIHVwIGEgYFJlYWN0aXZlQ29udHJvbGxlcmAuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG15RGVjb3JhdG9yID0gKHRhcmdldDogdHlwZW9mIFJlYWN0aXZlRWxlbWVudCwga2V5OiBzdHJpbmcpID0+IHtcbiAgICAgKiAgIHRhcmdldC5hZGRJbml0aWFsaXplcigoaW5zdGFuY2U6IFJlYWN0aXZlRWxlbWVudCkgPT4ge1xuICAgICAqICAgICAvLyBUaGlzIGlzIHJ1biBkdXJpbmcgY29uc3RydWN0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgICogICAgIG5ldyBNeUNvbnRyb2xsZXIoaW5zdGFuY2UpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRGVjb3JhdGluZyBhIGZpZWxkIHdpbGwgdGhlbiBjYXVzZSBlYWNoIGluc3RhbmNlIHRvIHJ1biBhbiBpbml0aWFsaXplclxuICAgICAqIHRoYXQgYWRkcyBhIGNvbnRyb2xsZXI6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xuICAgICAqICAgQG15RGVjb3JhdG9yIGZvbztcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbml0aWFsaXplcnMgYXJlIHN0b3JlZCBwZXItY29uc3RydWN0b3IuIEFkZGluZyBhbiBpbml0aWFsaXplciB0byBhXG4gICAgICogc3ViY2xhc3MgZG9lcyBub3QgYWRkIGl0IHRvIGEgc3VwZXJjbGFzcy4gU2luY2UgaW5pdGlhbGl6ZXJzIGFyZSBydW4gaW5cbiAgICAgKiBjb25zdHJ1Y3RvcnMsIGluaXRpYWxpemVycyB3aWxsIHJ1biBpbiBvcmRlciBvZiB0aGUgY2xhc3MgaGllcmFyY2h5LFxuICAgICAqIHN0YXJ0aW5nIHdpdGggc3VwZXJjbGFzc2VzIGFuZCBwcm9ncmVzc2luZyB0byB0aGUgaW5zdGFuY2UncyBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGFkZEluaXRpYWxpemVyKGluaXRpYWxpemVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICAoKF9hID0gdGhpcy5faW5pdGlhbGl6ZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5faW5pdGlhbGl6ZXJzID0gW10pKS5wdXNoKGluaXRpYWxpemVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXR0cmlidXRlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWdpc3RlcmVkIHByb3BlcnRpZXMuXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKiBAY2F0ZWdvcnkgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgICAgICAvLyBub3RlOiBwaWdneSBiYWNraW5nIG9uIHRoaXMgdG8gZW5zdXJlIHdlJ3JlIGZpbmFsaXplZC5cbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgICAgIC8vIFVzZSBmb3JFYWNoIHNvIHRoaXMgd29ya3MgZXZlbiBpZiBmb3Ivb2YgbG9vcHMgYXJlIGNvbXBpbGVkIHRvIGZvciBsb29wc1xuICAgICAgICAvLyBleHBlY3RpbmcgYXJyYXlzXG4gICAgICAgIHRoaXMuZWxlbWVudFByb3BlcnRpZXMuZm9yRWFjaCgodiwgcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IHRoaXMuX19hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkocCwgdik7XG4gICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAuc2V0KGF0dHIsIHApO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJvcGVydHkgYWNjZXNzb3Igb24gdGhlIGVsZW1lbnQgcHJvdG90eXBlIGlmIG9uZSBkb2VzIG5vdCBleGlzdFxuICAgICAqIGFuZCBzdG9yZXMgYSB7QGxpbmtjb2RlIFByb3BlcnR5RGVjbGFyYXRpb259IGZvciB0aGUgcHJvcGVydHkgd2l0aCB0aGVcbiAgICAgKiBnaXZlbiBvcHRpb25zLiBUaGUgcHJvcGVydHkgc2V0dGVyIGNhbGxzIHRoZSBwcm9wZXJ0eSdzIGBoYXNDaGFuZ2VkYFxuICAgICAqIHByb3BlcnR5IG9wdGlvbiBvciB1c2VzIGEgc3RyaWN0IGlkZW50aXR5IGNoZWNrIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdFxuICAgICAqIHRvIHJlcXVlc3QgYW4gdXBkYXRlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gY3VzdG9taXplIHByb3BlcnRpZXM7IGhvd2V2ZXIsXG4gICAgICogd2hlbiBkb2luZyBzbywgaXQncyBpbXBvcnRhbnQgdG8gY2FsbCBgc3VwZXIuY3JlYXRlUHJvcGVydHlgIHRvIGVuc3VyZVxuICAgICAqIHRoZSBwcm9wZXJ0eSBpcyBzZXR1cCBjb3JyZWN0bHkuIFRoaXMgbWV0aG9kIGNhbGxzXG4gICAgICogYGdldFByb3BlcnR5RGVzY3JpcHRvcmAgaW50ZXJuYWxseSB0byBnZXQgYSBkZXNjcmlwdG9yIHRvIGluc3RhbGwuXG4gICAgICogVG8gY3VzdG9taXplIHdoYXQgcHJvcGVydGllcyBkbyB3aGVuIHRoZXkgYXJlIGdldCBvciBzZXQsIG92ZXJyaWRlXG4gICAgICogYGdldFByb3BlcnR5RGVzY3JpcHRvcmAuIFRvIGN1c3RvbWl6ZSB0aGUgb3B0aW9ucyBmb3IgYSBwcm9wZXJ0eSxcbiAgICAgKiBpbXBsZW1lbnQgYGNyZWF0ZVByb3BlcnR5YCBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eShuYW1lLCBvcHRpb25zKSB7XG4gICAgICogICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7bXlPcHRpb246IHRydWV9KTtcbiAgICAgKiAgIHN1cGVyLmNyZWF0ZVByb3BlcnR5KG5hbWUsIG9wdGlvbnMpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICogQGNhdGVnb3J5IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucyA9IGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHN0YXRlIHByb3BlcnR5LCBmb3JjZSB0aGUgYXR0cmlidXRlIHRvIGZhbHNlLlxuICAgICAgICBpZiAob3B0aW9ucy5zdGF0ZSkge1xuICAgICAgICAgICAgLy8gQ2FzdCBhcyBhbnkgc2luY2UgdGhpcyBpcyByZWFkb25seS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGUsIHNpbmNlIHRoaXMgY2FuIGJlIGNhbGxlZCBieSB0aGUgYEBwcm9wZXJ0eWAgZGVjb3JhdG9yIHdoaWNoXG4gICAgICAgIC8vIGlzIGNhbGxlZCBiZWZvcmUgYGZpbmFsaXplYCwgd2UgZW5zdXJlIGZpbmFsaXphdGlvbiBoYXMgYmVlbiBraWNrZWQgb2ZmLlxuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudFByb3BlcnRpZXMuc2V0KG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAvLyBEbyBub3QgZ2VuZXJhdGUgYW4gYWNjZXNzb3IgaWYgdGhlIHByb3RvdHlwZSBhbHJlYWR5IGhhcyBvbmUsIHNpbmNlXG4gICAgICAgIC8vIGl0IHdvdWxkIGJlIGxvc3Qgb3RoZXJ3aXNlIGFuZCB0aGF0IHdvdWxkIG5ldmVyIGJlIHRoZSB1c2VyJ3MgaW50ZW50aW9uO1xuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBleHBlY3QgdXNlcnMgdG8gY2FsbCBgcmVxdWVzdFVwZGF0ZWAgdGhlbXNlbHZlcyBmcm9tXG4gICAgICAgIC8vIHVzZXItZGVmaW5lZCBhY2Nlc3NvcnMuIE5vdGUgdGhhdCBpZiB0aGUgc3VwZXIgaGFzIGFuIGFjY2Vzc29yIHdlIHdpbGxcbiAgICAgICAgLy8gc3RpbGwgb3ZlcndyaXRlIGl0XG4gICAgICAgIGlmICghb3B0aW9ucy5ub0FjY2Vzc29yICYmICF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG5hbWUgPT09ICdzeW1ib2wnID8gU3ltYm9sKCkgOiBgX18ke25hbWV9YDtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldFByb3BlcnR5RGVzY3JpcHRvcihuYW1lLCBrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGNsYXNzIGRvZXNuJ3QgaGF2ZSBpdHMgb3duIHNldCwgY3JlYXRlIG9uZSBhbmQgaW5pdGlhbGl6ZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSB2YWx1ZXMgaW4gdGhlIHNldCBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGNsYXNzLCBpZiBhbnkuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19yZWFjdGl2ZVByb3BlcnR5S2V5cycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVhY3RpdmVQcm9wZXJ0eUtleXMgPSBuZXcgU2V0KChfYSA9IHRoaXMuX19yZWFjdGl2ZVByb3BlcnR5S2V5cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZWFjdGl2ZVByb3BlcnR5S2V5cy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGJlIGRlZmluZWQgb24gdGhlIGdpdmVuIG5hbWVkIHByb3BlcnR5LlxuICAgICAqIElmIG5vIGRlc2NyaXB0b3IgaXMgcmV0dXJuZWQsIHRoZSBwcm9wZXJ0eSB3aWxsIG5vdCBiZWNvbWUgYW4gYWNjZXNzb3IuXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNsYXNzIE15RWxlbWVudCBleHRlbmRzIExpdEVsZW1lbnQge1xuICAgICAqICAgc3RhdGljIGdldFByb3BlcnR5RGVzY3JpcHRvcihuYW1lLCBrZXksIG9wdGlvbnMpIHtcbiAgICAgKiAgICAgY29uc3QgZGVmYXVsdERlc2NyaXB0b3IgPVxuICAgICAqICAgICAgICAgc3VwZXIuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG5hbWUsIGtleSwgb3B0aW9ucyk7XG4gICAgICogICAgIGNvbnN0IHNldHRlciA9IGRlZmF1bHREZXNjcmlwdG9yLnNldDtcbiAgICAgKiAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICBnZXQ6IGRlZmF1bHREZXNjcmlwdG9yLmdldCxcbiAgICAgKiAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgKiAgICAgICAgIHNldHRlci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgKiAgICAgICAgIC8vIGN1c3RvbSBhY3Rpb24uXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKiBAY2F0ZWdvcnkgcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcm9wZXJ0eURlc2NyaXB0b3IobmFtZSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZShuYW1lLCBvbGRWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvcGVydHkgb3B0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIFRoZXNlIG9wdGlvbnMgYXJlIGRlZmluZWQgd2l0aCBhIGBQcm9wZXJ0eURlY2xhcmF0aW9uYCB2aWEgdGhlIGBwcm9wZXJ0aWVzYFxuICAgICAqIG9iamVjdCBvciB0aGUgYEBwcm9wZXJ0eWAgZGVjb3JhdG9yIGFuZCBhcmUgcmVnaXN0ZXJlZCBpblxuICAgICAqIGBjcmVhdGVQcm9wZXJ0eSguLi4pYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBjb25zaWRlcmVkIFwiZmluYWxcIiBhbmQgbm90IG92ZXJyaWRkZW4uIFRvXG4gICAgICogY3VzdG9taXplIHRoZSBvcHRpb25zIGZvciBhIGdpdmVuIHByb3BlcnR5LCBvdmVycmlkZVxuICAgICAqIHtAbGlua2NvZGUgY3JlYXRlUHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAY2F0ZWdvcnkgcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcm9wZXJ0eU9wdGlvbnMobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UHJvcGVydGllcy5nZXQobmFtZSkgfHwgZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgcHJvcGVydHkgYWNjZXNzb3JzIGZvciByZWdpc3RlcmVkIHByb3BlcnRpZXMsIHNldHMgdXAgZWxlbWVudFxuICAgICAqIHN0eWxpbmcsIGFuZCBlbnN1cmVzIGFueSBzdXBlcmNsYXNzZXMgYXJlIGFsc28gZmluYWxpemVkLiBSZXR1cm5zIHRydWUgaWZcbiAgICAgKiB0aGUgZWxlbWVudCB3YXMgZmluYWxpemVkLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShmaW5hbGl6ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tmaW5hbGl6ZWRdID0gdHJ1ZTtcbiAgICAgICAgLy8gZmluYWxpemUgYW55IHN1cGVyY2xhc3Nlc1xuICAgICAgICBjb25zdCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICAgIHN1cGVyQ3Rvci5maW5hbGl6ZSgpO1xuICAgICAgICAvLyBDcmVhdGUgb3duIHNldCBvZiBpbml0aWFsaXplcnMgZm9yIHRoaXMgY2xhc3MgaWYgYW55IGV4aXN0IG9uIHRoZVxuICAgICAgICAvLyBzdXBlcmNsYXNzIGFuZCBjb3B5IHRoZW0gZG93bi4gTm90ZSwgZm9yIGEgc21hbGwgcGVyZiBib29zdCwgYXZvaWRcbiAgICAgICAgLy8gY3JlYXRpbmcgaW5pdGlhbGl6ZXJzIHVubGVzcyBuZWVkZWQuXG4gICAgICAgIGlmIChzdXBlckN0b3IuX2luaXRpYWxpemVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplcnMgPSBbLi4uc3VwZXJDdG9yLl9pbml0aWFsaXplcnNdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudFByb3BlcnRpZXMgPSBuZXcgTWFwKHN1cGVyQ3Rvci5lbGVtZW50UHJvcGVydGllcyk7XG4gICAgICAgIC8vIGluaXRpYWxpemUgTWFwIHBvcHVsYXRlZCBpbiBvYnNlcnZlZEF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5fX2F0dHJpYnV0ZVRvUHJvcGVydHlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIG1ha2UgYW55IHByb3BlcnRpZXNcbiAgICAgICAgLy8gTm90ZSwgb25seSBwcm9jZXNzIFwib3duXCIgcHJvcGVydGllcyBzaW5jZSB0aGlzIGVsZW1lbnQgd2lsbCBpbmhlcml0XG4gICAgICAgIC8vIGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhlIHN1cGVyQ2xhc3MsIGFuZCBmaW5hbGl6YXRpb24gZW5zdXJlc1xuICAgICAgICAvLyB0aGUgZW50aXJlIHByb3RvdHlwZSBjaGFpbiBpcyBmaW5hbGl6ZWQuXG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgLy8gc3VwcG9ydCBzeW1ib2xzIGluIHByb3BlcnRpZXMgKElFMTEgZG9lcyBub3Qgc3VwcG9ydCB0aGlzKVxuICAgICAgICAgICAgY29uc3QgcHJvcEtleXMgPSBbXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcHMpLFxuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvcHMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIFRoaXMgZm9yL29mIGlzIG9rIGJlY2F1c2UgcHJvcEtleXMgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBwcm9wS2V5cykge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUsIHVzZSBvZiBgYW55YCBpcyBkdWUgdG8gVHlwZVNjcmlwdCBsYWNrIG9mIHN1cHBvcnQgZm9yIHN5bWJvbCBpblxuICAgICAgICAgICAgICAgIC8vIGluZGV4IHR5cGVzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVByb3BlcnR5KHAsIHByb3BzW3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRTdHlsZXMgPSB0aGlzLmZpbmFsaXplU3R5bGVzKHRoaXMuc3R5bGVzKTtcbiAgICAgICAgLy8gREVWIG1vZGUgd2FybmluZ3NcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgd2FyblJlbW92ZWRPclJlbmFtZWQgPSAobmFtZSwgcmVuYW1lZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlV2FybmluZyhyZW5hbWVkID8gJ3JlbmFtZWQtYXBpJyA6ICdyZW1vdmVkLWFwaScsIGBcXGAke25hbWV9XFxgIGlzIGltcGxlbWVudGVkIG9uIGNsYXNzICR7dGhpcy5uYW1lfS4gSXQgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgaGFzIGJlZW4gJHtyZW5hbWVkID8gJ3JlbmFtZWQnIDogJ3JlbW92ZWQnfSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbiB0aGlzIHZlcnNpb24gb2YgTGl0RWxlbWVudC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2FyblJlbW92ZWRPclJlbmFtZWQoJ2luaXRpYWxpemUnKTtcbiAgICAgICAgICAgIHdhcm5SZW1vdmVkT3JSZW5hbWVkKCdyZXF1ZXN0VXBkYXRlSW50ZXJuYWwnKTtcbiAgICAgICAgICAgIHdhcm5SZW1vdmVkT3JSZW5hbWVkKCdfZ2V0VXBkYXRlQ29tcGxldGUnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgdGhlIHN0eWxlcyB0aGUgdXNlciBzdXBwbGllZCB2aWEgdGhlIGBzdGF0aWMgc3R5bGVzYCBwcm9wZXJ0eSBhbmRcbiAgICAgKiByZXR1cm5zIHRoZSBhcnJheSBvZiBzdHlsZXMgdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQuXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW50ZWdyYXRlIGludG8gYSBzdHlsZSBtYW5hZ2VtZW50IHN5c3RlbS5cbiAgICAgKlxuICAgICAqIFN0eWxlcyBhcmUgZGVkdXBsaWNhdGVkIHByZXNlcnZpbmcgdGhlIF9sYXN0XyBpbnN0YW5jZSBpbiB0aGUgbGlzdC4gVGhpc1xuICAgICAqIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGF2b2lkIGR1cGxpY2F0ZWQgc3R5bGVzIHRoYXQgY2FuIG9jY3VyXG4gICAgICogZXNwZWNpYWxseSB3aGVuIGNvbXBvc2luZyB2aWEgc3ViY2xhc3NpbmcuIFRoZSBsYXN0IGl0ZW0gaXMga2VwdCB0byB0cnlcbiAgICAgKiB0byBwcmVzZXJ2ZSB0aGUgY2FzY2FkZSBvcmRlciB3aXRoIHRoZSBhc3N1bXB0aW9uIHRoYXQgaXQncyBtb3N0IGltcG9ydGFudFxuICAgICAqIHRoYXQgbGFzdCBhZGRlZCBzdHlsZXMgb3ZlcnJpZGUgcHJldmlvdXMgc3R5bGVzLlxuICAgICAqXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKiBAY2F0ZWdvcnkgc3R5bGVzXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplU3R5bGVzKHN0eWxlcykge1xuICAgICAgICBjb25zdCBlbGVtZW50U3R5bGVzID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgICAgICAgIC8vIERlZHVwZSB0aGUgZmxhdHRlbmVkIGFycmF5IGluIHJldmVyc2Ugb3JkZXIgdG8gcHJlc2VydmUgdGhlIGxhc3QgaXRlbXMuXG4gICAgICAgICAgICAvLyBDYXN0aW5nIHRvIEFycmF5PHVua25vd24+IHdvcmtzIGFyb3VuZCBUUyBlcnJvciB0aGF0XG4gICAgICAgICAgICAvLyBhcHBlYXJzIHRvIGNvbWUgZnJvbSB0cnlpbmcgdG8gZmxhdHRlbiBhIHR5cGUgQ1NTUmVzdWx0QXJyYXkuXG4gICAgICAgICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KHN0eWxlcy5mbGF0KEluZmluaXR5KS5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgLy8gVGhlbiBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBieSBhZGRpbmcgdGhlIHNldCBpdGVtcyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHNldCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRTdHlsZXMudW5zaGlmdChnZXRDb21wYXRpYmxlU3R5bGUocykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbGVtZW50U3R5bGVzLnB1c2goZ2V0Q29tcGF0aWJsZVN0eWxlKHN0eWxlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50U3R5bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgZ2l2ZW4gYXR0cmlidXRlIGBuYW1lYC5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG9wdGlvbnMuYXR0cmlidXRlO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlID09PSBmYWxzZVxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogdHlwZW9mIGF0dHJpYnV0ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBvbmx5IG92ZXJyaWRlIHBvaW50IGZvciBjdXN0b21pemluZyB3b3JrIGRvbmUgd2hlbiBlbGVtZW50c1xuICAgICAqIGFyZSBjb25zdHJ1Y3RlZC5cbiAgICAgKi9cbiAgICBfX2luaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fX3VwZGF0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzKSA9PiAodGhpcy5lbmFibGVVcGRhdGluZyA9IHJlcykpO1xuICAgICAgICB0aGlzLl8kY2hhbmdlZFByb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX19zYXZlSW5zdGFuY2VQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIGVuc3VyZXMgZmlyc3QgdXBkYXRlIHdpbGwgYmUgY2F1Z2h0IGJ5IGFuIGVhcmx5IGFjY2VzcyBvZlxuICAgICAgICAvLyBgdXBkYXRlQ29tcGxldGVgXG4gICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICAoX2EgPSB0aGlzLmNvbnN0cnVjdG9yLl9pbml0aWFsaXplcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChpKSA9PiBpKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgYFJlYWN0aXZlQ29udHJvbGxlcmAgdG8gcGFydGljaXBhdGUgaW4gdGhlIGVsZW1lbnQncyByZWFjdGl2ZVxuICAgICAqIHVwZGF0ZSBjeWNsZS4gVGhlIGVsZW1lbnQgYXV0b21hdGljYWxseSBjYWxscyBpbnRvIGFueSByZWdpc3RlcmVkXG4gICAgICogY29udHJvbGxlcnMgZHVyaW5nIGl0cyBsaWZlY3ljbGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogSWYgdGhlIGVsZW1lbnQgaXMgY29ubmVjdGVkIHdoZW4gYGFkZENvbnRyb2xsZXIoKWAgaXMgY2FsbGVkLCB0aGVcbiAgICAgKiBjb250cm9sbGVyJ3MgYGhvc3RDb25uZWN0ZWQoKWAgY2FsbGJhY2sgd2lsbCBiZSBpbW1lZGlhdGVseSBjYWxsZWQuXG4gICAgICogQGNhdGVnb3J5IGNvbnRyb2xsZXJzXG4gICAgICovXG4gICAgYWRkQ29udHJvbGxlcihjb250cm9sbGVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICgoX2EgPSB0aGlzLl9fY29udHJvbGxlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICh0aGlzLl9fY29udHJvbGxlcnMgPSBbXSkpLnB1c2goY29udHJvbGxlcik7XG4gICAgICAgIC8vIElmIGEgY29udHJvbGxlciBpcyBhZGRlZCBhZnRlciB0aGUgZWxlbWVudCBoYXMgYmVlbiBjb25uZWN0ZWQsXG4gICAgICAgIC8vIGNhbGwgaG9zdENvbm5lY3RlZC4gTm90ZSwgcmUtdXNpbmcgZXhpc3RlbmNlIG9mIGByZW5kZXJSb290YCBoZXJlXG4gICAgICAgIC8vICh3aGljaCBpcyBzZXQgaW4gY29ubmVjdGVkQ2FsbGJhY2spIHRvIGF2b2lkIHRoZSBuZWVkIHRvIHRyYWNrIGFcbiAgICAgICAgLy8gZmlyc3QgY29ubmVjdGVkIHN0YXRlLlxuICAgICAgICBpZiAodGhpcy5yZW5kZXJSb290ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgKF9iID0gY29udHJvbGxlci5ob3N0Q29ubmVjdGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgYFJlYWN0aXZlQ29udHJvbGxlcmAgZnJvbSB0aGUgZWxlbWVudC5cbiAgICAgKiBAY2F0ZWdvcnkgY29udHJvbGxlcnNcbiAgICAgKi9cbiAgICByZW1vdmVDb250cm9sbGVyKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBOb3RlLCBpZiB0aGUgaW5kZXhPZiBpcyAtMSwgdGhlID4+PiB3aWxsIGZsaXAgdGhlIHNpZ24gd2hpY2ggbWFrZXMgdGhlXG4gICAgICAgIC8vIHNwbGljZSBkbyBub3RoaW5nLlxuICAgICAgICAoX2EgPSB0aGlzLl9fY29udHJvbGxlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpY2UodGhpcy5fX2NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPj4+IDAsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaXhlcyBhbnkgcHJvcGVydGllcyBzZXQgb24gdGhlIGluc3RhbmNlIGJlZm9yZSB1cGdyYWRlIHRpbWUuXG4gICAgICogT3RoZXJ3aXNlIHRoZXNlIHdvdWxkIHNoYWRvdyB0aGUgYWNjZXNzb3IgYW5kIGJyZWFrIHRoZXNlIHByb3BlcnRpZXMuXG4gICAgICogVGhlIHByb3BlcnRpZXMgYXJlIHN0b3JlZCBpbiBhIE1hcCB3aGljaCBpcyBwbGF5ZWQgYmFjayBhZnRlciB0aGVcbiAgICAgKiBjb25zdHJ1Y3RvciBydW5zLiBOb3RlLCBvbiB2ZXJ5IG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkgKDw9OSkgb3IgQ2hyb21lXG4gICAgICogKDw9NDEpLCBwcm9wZXJ0aWVzIGNyZWF0ZWQgZm9yIG5hdGl2ZSBwbGF0Zm9ybSBwcm9wZXJ0aWVzIGxpa2UgKGBpZGAgb3JcbiAgICAgKiBgbmFtZWApIG1heSBub3QgaGF2ZSBkZWZhdWx0IHZhbHVlcyBzZXQgaW4gdGhlIGVsZW1lbnQgY29uc3RydWN0b3IuIE9uXG4gICAgICogdGhlc2UgYnJvd3NlcnMgbmF0aXZlIHByb3BlcnRpZXMgYXBwZWFyIG9uIGluc3RhbmNlcyBhbmQgdGhlcmVmb3JlIHRoZWlyXG4gICAgICogZGVmYXVsdCB2YWx1ZSB3aWxsIG92ZXJ3cml0ZSBhbnkgZWxlbWVudCBkZWZhdWx0IChlLmcuIGlmIHRoZSBlbGVtZW50IHNldHNcbiAgICAgKiB0aGlzLmlkID0gJ2lkJyBpbiB0aGUgY29uc3RydWN0b3IsIHRoZSAnaWQnIHdpbGwgYmVjb21lICcnIHNpbmNlIHRoaXMgaXNcbiAgICAgKiB0aGUgbmF0aXZlIHBsYXRmb3JtIGRlZmF1bHQpLlxuICAgICAqL1xuICAgIF9fc2F2ZUluc3RhbmNlUHJvcGVydGllcygpIHtcbiAgICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yIGxvb3BzXG4gICAgICAgIC8vIGV4cGVjdGluZyBhcnJheXNcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5lbGVtZW50UHJvcGVydGllcy5mb3JFYWNoKChfdiwgcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW5zdGFuY2VQcm9wZXJ0aWVzLnNldChwLCB0aGlzW3BdKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5vZGUgaW50byB3aGljaCB0aGUgZWxlbWVudCBzaG91bGQgcmVuZGVyIGFuZCBieSBkZWZhdWx0XG4gICAgICogY3JlYXRlcyBhbmQgcmV0dXJucyBhbiBvcGVuIHNoYWRvd1Jvb3QuIEltcGxlbWVudCB0byBjdXN0b21pemUgd2hlcmUgdGhlXG4gICAgICogZWxlbWVudCdzIERPTSBpcyByZW5kZXJlZC4gRm9yIGV4YW1wbGUsIHRvIHJlbmRlciBpbnRvIHRoZSBlbGVtZW50J3NcbiAgICAgKiBjaGlsZE5vZGVzLCByZXR1cm4gYHRoaXNgLlxuICAgICAqXG4gICAgICogQHJldHVybiBSZXR1cm5zIGEgbm9kZSBpbnRvIHdoaWNoIHRvIHJlbmRlci5cbiAgICAgKiBAY2F0ZWdvcnkgcmVuZGVyaW5nXG4gICAgICovXG4gICAgY3JlYXRlUmVuZGVyUm9vdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZW5kZXJSb290ID0gKF9hID0gdGhpcy5zaGFkb3dSb290KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmF0dGFjaFNoYWRvdyh0aGlzLmNvbnN0cnVjdG9yLnNoYWRvd1Jvb3RPcHRpb25zKTtcbiAgICAgICAgYWRvcHRTdHlsZXMocmVuZGVyUm9vdCwgdGhpcy5jb25zdHJ1Y3Rvci5lbGVtZW50U3R5bGVzKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlclJvb3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIGZpcnN0IGNvbm5lY3Rpb24sIGNyZWF0ZXMgdGhlIGVsZW1lbnQncyByZW5kZXJSb290LCBzZXRzIHVwXG4gICAgICogZWxlbWVudCBzdHlsaW5nLCBhbmQgZW5hYmxlcyB1cGRhdGluZy5cbiAgICAgKiBAY2F0ZWdvcnkgbGlmZWN5Y2xlXG4gICAgICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gY3JlYXRlIHJlbmRlclJvb3QgYmVmb3JlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJvb3QgPSB0aGlzLmNyZWF0ZVJlbmRlclJvb3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuYWJsZVVwZGF0aW5nKHRydWUpO1xuICAgICAgICAoX2EgPSB0aGlzLl9fY29udHJvbGxlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChjKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGMuaG9zdENvbm5lY3RlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYyk7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RlLCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY29uc2lkZXJlZCBmaW5hbCBhbmQgbm90IG92ZXJyaWRkZW4uIEl0IGlzXG4gICAgICogb3ZlcnJpZGRlbiBvbiB0aGUgZWxlbWVudCBpbnN0YW5jZSB3aXRoIGEgZnVuY3Rpb24gdGhhdCB0cmlnZ2VycyB0aGUgZmlyc3RcbiAgICAgKiB1cGRhdGUuXG4gICAgICogQGNhdGVnb3J5IHVwZGF0ZXNcbiAgICAgKi9cbiAgICBlbmFibGVVcGRhdGluZyhfcmVxdWVzdGVkVXBkYXRlKSB7IH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgZm9yIGBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpYCBpbiBleHRlbnNpb25zIHdoaWxlXG4gICAgICogcmVzZXJ2aW5nIHRoZSBwb3NzaWJpbGl0eSBvZiBtYWtpbmcgbm9uLWJyZWFraW5nIGZlYXR1cmUgYWRkaXRpb25zXG4gICAgICogd2hlbiBkaXNjb25uZWN0aW5nIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBAY2F0ZWdvcnkgbGlmZWN5Y2xlXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fX2NvbnRyb2xsZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoYykgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBjLmhvc3REaXNjb25uZWN0ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGMpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25pemVzIHByb3BlcnR5IHZhbHVlcyB3aGVuIGF0dHJpYnV0ZXMgY2hhbmdlLlxuICAgICAqXG4gICAgICogU3BlY2lmaWNhbGx5LCB3aGVuIGFuIGF0dHJpYnV0ZSBpcyBzZXQsIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IGlzIHNldC5cbiAgICAgKiBZb3Ugc2hvdWxkIHJhcmVseSBuZWVkIHRvIGltcGxlbWVudCB0aGlzIGNhbGxiYWNrLiBJZiB0aGlzIG1ldGhvZCBpc1xuICAgICAqIG92ZXJyaWRkZW4sIGBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgX29sZCwgdmFsdWUpYCBtdXN0IGJlXG4gICAgICogY2FsbGVkLlxuICAgICAqXG4gICAgICogU2VlIFt1c2luZyB0aGUgbGlmZWN5Y2xlIGNhbGxiYWNrc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvV2ViX0NvbXBvbmVudHMvVXNpbmdfY3VzdG9tX2VsZW1lbnRzI3VzaW5nX3RoZV9saWZlY3ljbGVfY2FsbGJhY2tzKVxuICAgICAqIG9uIE1ETiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAgICogQGNhdGVnb3J5IGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgX29sZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fJGF0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBfX3Byb3BlcnR5VG9BdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSBkZWZhdWx0UHJvcGVydHlEZWNsYXJhdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl9fYXR0cmlidXRlTmFtZUZvclByb3BlcnR5KG5hbWUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVmbGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY29udmVydGVyID0gKChfYSA9IG9wdGlvbnMuY29udmVydGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9BdHRyaWJ1dGUpICE9PVxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5jb252ZXJ0ZXJcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRDb252ZXJ0ZXI7XG4gICAgICAgICAgICBjb25zdCBhdHRyVmFsdWUgPSBjb252ZXJ0ZXIudG9BdHRyaWJ1dGUodmFsdWUsIG9wdGlvbnMudHlwZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5lbmFibGVkV2FybmluZ3MuaW5kZXhPZignbWlncmF0aW9uJykgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGF0dHJWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXNzdWVXYXJuaW5nKCd1bmRlZmluZWQtYXR0cmlidXRlLXZhbHVlJywgYFRoZSBhdHRyaWJ1dGUgdmFsdWUgZm9yIHRoZSAke25hbWV9IHByb3BlcnR5IGlzIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdW5kZWZpbmVkIG9uIGVsZW1lbnQgJHt0aGlzLmxvY2FsTmFtZX0uIFRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHJlbW92ZWQsIGJ1dCBpbiB0aGUgcHJldmlvdXMgdmVyc2lvbiBvZiBcXGBSZWFjdGl2ZUVsZW1lbnRcXGAsIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdGhlIGF0dHJpYnV0ZSB3b3VsZCBub3QgaGF2ZSBjaGFuZ2VkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHJhY2sgaWYgdGhlIHByb3BlcnR5IGlzIGJlaW5nIHJlZmxlY3RlZCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgcHJvcGVydHkgYWdhaW4gdmlhIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLiBOb3RlOlxuICAgICAgICAgICAgLy8gMS4gdGhpcyB0YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIGZhY3QgdGhhdCB0aGUgY2FsbGJhY2sgaXMgc3luY2hyb25vdXMuXG4gICAgICAgICAgICAvLyAyLiB3aWxsIGJlaGF2ZSBpbmNvcnJlY3RseSBpZiBtdWx0aXBsZSBhdHRyaWJ1dGVzIGFyZSBpbiB0aGUgcmVhY3Rpb25cbiAgICAgICAgICAgIC8vIHN0YWNrIGF0IHRpbWUgb2YgY2FsbGluZy4gSG93ZXZlciwgc2luY2Ugd2UgcHJvY2VzcyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBpbiBgdXBkYXRlYCB0aGlzIHNob3VsZCBub3QgYmUgcG9zc2libGUgKG9yIGFuIGV4dHJlbWUgY29ybmVyIGNhc2VcbiAgICAgICAgICAgIC8vIHRoYXQgd2UnZCBsaWtlIHRvIGRpc2NvdmVyKS5cbiAgICAgICAgICAgIC8vIG1hcmsgc3RhdGUgcmVmbGVjdGluZ1xuICAgICAgICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0eSA9IG5hbWU7XG4gICAgICAgICAgICBpZiAoYXR0clZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYXJrIHN0YXRlIG5vdCByZWZsZWN0aW5nXG4gICAgICAgICAgICB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgXyRhdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIC8vIE5vdGUsIGhpbnQgdGhpcyBhcyBhbiBgQXR0cmlidXRlTWFwYCBzbyBjbG9zdXJlIGNsZWFybHkgdW5kZXJzdGFuZHNcbiAgICAgICAgLy8gdGhlIHR5cGU7IGl0IGhhcyBpc3N1ZXMgd2l0aCB0cmFja2luZyB0eXBlcyB0aHJvdWdoIHN0YXRpY3NcbiAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBjdG9yLl9fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcC5nZXQobmFtZSk7XG4gICAgICAgIC8vIFVzZSB0cmFja2luZyBpbmZvIHRvIGF2b2lkIHJlZmxlY3RpbmcgYSBwcm9wZXJ0eSB2YWx1ZSB0byBhbiBhdHRyaWJ1dGVcbiAgICAgICAgLy8gaWYgaXQgd2FzIGp1c3Qgc2V0IGJlY2F1c2UgdGhlIGF0dHJpYnV0ZSBjaGFuZ2VkLlxuICAgICAgICBpZiAocHJvcE5hbWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnR5ICE9PSBwcm9wTmFtZSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGN0b3IuZ2V0UHJvcGVydHlPcHRpb25zKHByb3BOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IHR5cGVvZiBvcHRpb25zLmNvbnZlcnRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8geyBmcm9tQXR0cmlidXRlOiBvcHRpb25zLmNvbnZlcnRlciB9XG4gICAgICAgICAgICAgICAgOiAoKF9hID0gb3B0aW9ucy5jb252ZXJ0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tQXR0cmlidXRlKSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5jb252ZXJ0ZXJcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0Q29udmVydGVyO1xuICAgICAgICAgICAgLy8gbWFyayBzdGF0ZSByZWZsZWN0aW5nXG4gICAgICAgICAgICB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnR5ID0gcHJvcE5hbWU7XG4gICAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IGNvbnZlcnRlci5mcm9tQXR0cmlidXRlKHZhbHVlLCBvcHRpb25zLnR5cGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gbWFyayBzdGF0ZSBub3QgcmVmbGVjdGluZ1xuICAgICAgICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYW4gdXBkYXRlIHdoaWNoIGlzIHByb2Nlc3NlZCBhc3luY2hyb25vdXNseS4gVGhpcyBzaG91bGQgYmUgY2FsbGVkXG4gICAgICogd2hlbiBhbiBlbGVtZW50IHNob3VsZCB1cGRhdGUgYmFzZWQgb24gc29tZSBzdGF0ZSBub3QgdHJpZ2dlcmVkIGJ5IHNldHRpbmdcbiAgICAgKiBhIHJlYWN0aXZlIHByb3BlcnR5LiBJbiB0aGlzIGNhc2UsIHBhc3Mgbm8gYXJndW1lbnRzLiBJdCBzaG91bGQgYWxzbyBiZVxuICAgICAqIGNhbGxlZCB3aGVuIG1hbnVhbGx5IGltcGxlbWVudGluZyBhIHByb3BlcnR5IHNldHRlci4gSW4gdGhpcyBjYXNlLCBwYXNzIHRoZVxuICAgICAqIHByb3BlcnR5IGBuYW1lYCBhbmQgYG9sZFZhbHVlYCB0byBlbnN1cmUgdGhhdCBhbnkgY29uZmlndXJlZCBwcm9wZXJ0eVxuICAgICAqIG9wdGlvbnMgYXJlIGhvbm9yZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHJlcXVlc3RpbmcgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWUgb2xkIHZhbHVlIG9mIHJlcXVlc3RpbmcgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBwcm9wZXJ0eSBvcHRpb25zIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBwcmV2aW91c2x5XG4gICAgICogICAgIGNvbmZpZ3VyZWQgb3B0aW9uc1xuICAgICAqIEBjYXRlZ29yeSB1cGRhdGVzXG4gICAgICovXG4gICAgcmVxdWVzdFVwZGF0ZShuYW1lLCBvbGRWYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgc2hvdWxkUmVxdWVzdFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwcm9wZXJ0eSBrZXksIHBlcmZvcm0gcHJvcGVydHkgdXBkYXRlIHN0ZXBzLlxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zID1cbiAgICAgICAgICAgICAgICBvcHRpb25zIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuZ2V0UHJvcGVydHlPcHRpb25zKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgaGFzQ2hhbmdlZCA9IG9wdGlvbnMuaGFzQ2hhbmdlZCB8fCBub3RFcXVhbDtcbiAgICAgICAgICAgIGlmIChoYXNDaGFuZ2VkKHRoaXNbbmFtZV0sIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fJGNoYW5nZWRQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl8kY2hhbmdlZFByb3BlcnRpZXMuc2V0KG5hbWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHJlZmxlY3RpbmcgcHJvcGVydGllcyBzZXQuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSwgaXQncyBpbXBvcnRhbnQgdGhhdCBldmVyeSBjaGFuZ2UgaGFzIGEgY2hhbmNlIHRvIGFkZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSB0byBgX3JlZmxlY3RpbmdQcm9wZXJ0aWVzYC4gVGhpcyBlbnN1cmVzIHNldHRpbmdcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgKyBwcm9wZXJ0eSByZWZsZWN0cyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVmbGVjdCA9PT0gdHJ1ZSAmJiB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnR5ICE9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZWZsZWN0aW5nUHJvcGVydGllcy5zZXQobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgdGhlIHJlcXVlc3QgaWYgdGhlIHByb3BlcnR5IHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIHNob3VsZFJlcXVlc3RVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNVcGRhdGVQZW5kaW5nICYmIHNob3VsZFJlcXVlc3RVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX191cGRhdGVQcm9taXNlID0gdGhpcy5fX2VucXVldWVVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlLCBzaW5jZSB0aGlzIG5vIGxvbmdlciByZXR1cm5zIGEgcHJvbWlzZSwgaW4gZGV2IG1vZGUgd2UgcmV0dXJuIGFcbiAgICAgICAgLy8gdGhlbmFibGUgd2hpY2ggd2FybnMgaWYgaXQncyBjYWxsZWQuXG4gICAgICAgIHJldHVybiByZXF1ZXN0VXBkYXRlVGhlbmFibGUodGhpcy5sb2NhbE5hbWUpXG4gICAgICAgICAgICA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGVsZW1lbnQgdG8gYXN5bmNocm9ub3VzbHkgdXBkYXRlLlxuICAgICAqL1xuICAgIGFzeW5jIF9fZW5xdWV1ZVVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5pc1VwZGF0ZVBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFueSBwcmV2aW91cyB1cGRhdGUgaGFzIHJlc29sdmVkIGJlZm9yZSB1cGRhdGluZy5cbiAgICAgICAgICAgIC8vIFRoaXMgYGF3YWl0YCBhbHNvIGVuc3VyZXMgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VzIGFyZSBiYXRjaGVkLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fX3VwZGF0ZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFJlZmlyZSBhbnkgcHJldmlvdXMgZXJyb3JzIGFzeW5jIHNvIHRoZXkgZG8gbm90IGRpc3J1cHQgdGhlIHVwZGF0ZVxuICAgICAgICAgICAgLy8gY3ljbGUuIEVycm9ycyBhcmUgcmVmaXJlZCBzbyBkZXZlbG9wZXJzIGhhdmUgYSBjaGFuY2UgdG8gb2JzZXJ2ZVxuICAgICAgICAgICAgLy8gdGhlbSwgYW5kIHRoaXMgY2FuIGJlIGRvbmUgYnkgaW1wbGVtZW50aW5nXG4gICAgICAgICAgICAvLyBgd2luZG93Lm9udW5oYW5kbGVkcmVqZWN0aW9uYC5cbiAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAgICAgLy8gSWYgYHNjaGVkdWxlVXBkYXRlYCByZXR1cm5zIGEgUHJvbWlzZSwgd2UgYXdhaXQgaXQuIFRoaXMgaXMgZG9uZSB0b1xuICAgICAgICAvLyBlbmFibGUgY29vcmRpbmF0aW5nIHVwZGF0ZXMgd2l0aCBhIHNjaGVkdWxlci4gTm90ZSwgdGhlIHJlc3VsdCBpc1xuICAgICAgICAvLyBjaGVja2VkIHRvIGF2b2lkIGRlbGF5aW5nIGFuIGFkZGl0aW9uYWwgbWljcm90YXNrIHVubGVzcyB3ZSBuZWVkIHRvLlxuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMuaXNVcGRhdGVQZW5kaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gZWxlbWVudCB1cGRhdGUuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZVxuICAgICAqIHRpbWluZyBvZiB1cGRhdGVzIGJ5IHJldHVybmluZyBhIFByb21pc2UuIFRoZSB1cGRhdGUgd2lsbCBhd2FpdCB0aGVcbiAgICAgKiByZXR1cm5lZCBQcm9taXNlLCBhbmQgeW91IHNob3VsZCByZXNvbHZlIHRoZSBQcm9taXNlIHRvIGFsbG93IHRoZSB1cGRhdGVcbiAgICAgKiB0byBwcm9jZWVkLiBJZiB0aGlzIG1ldGhvZCBpcyBvdmVycmlkZGVuLCBgc3VwZXIuc2NoZWR1bGVVcGRhdGUoKWBcbiAgICAgKiBtdXN0IGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwgdG8gc2NoZWR1bGUgdXBkYXRlcyB0byBvY2N1ciBqdXN0IGJlZm9yZSB0aGUgbmV4dCBmcmFtZTpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogb3ZlcnJpZGUgcHJvdGVjdGVkIGFzeW5jIHNjaGVkdWxlVXBkYXRlKCk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgICAqICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiByZXNvbHZlKCkpKTtcbiAgICAgKiAgIHN1cGVyLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBjYXRlZ29yeSB1cGRhdGVzXG4gICAgICovXG4gICAgc2NoZWR1bGVVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1VcGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYW4gZWxlbWVudCB1cGRhdGUuIE5vdGUsIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZHVyaW5nIHRoZVxuICAgICAqIHVwZGF0ZSwgYGZpcnN0VXBkYXRlZGAgYW5kIGB1cGRhdGVkYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBDYWxsIGBwZXJmb3JtVXBkYXRlKClgIHRvIGltbWVkaWF0ZWx5IHByb2Nlc3MgYSBwZW5kaW5nIHVwZGF0ZS4gVGhpcyBzaG91bGRcbiAgICAgKiBnZW5lcmFsbHkgbm90IGJlIG5lZWRlZCwgYnV0IGl0IGNhbiBiZSBkb25lIGluIHJhcmUgY2FzZXMgd2hlbiB5b3UgbmVlZCB0b1xuICAgICAqIHVwZGF0ZSBzeW5jaHJvbm91c2x5LlxuICAgICAqXG4gICAgICogTm90ZTogVG8gZW5zdXJlIGBwZXJmb3JtVXBkYXRlKClgIHN5bmNocm9ub3VzbHkgY29tcGxldGVzIGEgcGVuZGluZyB1cGRhdGUsXG4gICAgICogaXQgc2hvdWxkIG5vdCBiZSBvdmVycmlkZGVuLiBJbiBMaXRFbGVtZW50IDIueCBpdCB3YXMgc3VnZ2VzdGVkIHRvIG92ZXJyaWRlXG4gICAgICogYHBlcmZvcm1VcGRhdGUoKWAgdG8gYWxzbyBjdXN0b21pemluZyB1cGRhdGUgc2NoZWR1bGluZy4gSW5zdGVhZCwgeW91IHNob3VsZCBub3dcbiAgICAgKiBvdmVycmlkZSBgc2NoZWR1bGVVcGRhdGUoKWAuIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIExpdEVsZW1lbnQgMi54LFxuICAgICAqIHNjaGVkdWxpbmcgdXBkYXRlcyB2aWEgYHBlcmZvcm1VcGRhdGUoKWAgY29udGludWVzIHRvIHdvcmssIGJ1dCB3aWxsIG1ha2VcbiAgICAgKiBhbHNvIGNhbGxpbmcgYHBlcmZvcm1VcGRhdGUoKWAgdG8gc3luY2hyb25vdXNseSBwcm9jZXNzIHVwZGF0ZXMgZGlmZmljdWx0LlxuICAgICAqXG4gICAgICogQGNhdGVnb3J5IHVwZGF0ZXNcbiAgICAgKi9cbiAgICBwZXJmb3JtVXBkYXRlKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBBYm9ydCBhbnkgdXBkYXRlIGlmIG9uZSBpcyBub3QgcGVuZGluZyB3aGVuIHRoaXMgaXMgY2FsbGVkLlxuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgYHBlcmZvcm1VcGRhdGVgIGlzIGNhbGxlZCBlYXJseSB0byBcImZsdXNoXCJcbiAgICAgICAgLy8gdGhlIHVwZGF0ZS5cbiAgICAgICAgaWYgKCF0aGlzLmlzVXBkYXRlUGVuZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnTG9nRXZlbnQgPT09IG51bGwgfHwgZGVidWdMb2dFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVidWdMb2dFdmVudCh7IGtpbmQ6ICd1cGRhdGUnIH0pO1xuICAgICAgICAvLyBjcmVhdGUgcmVuZGVyUm9vdCBiZWZvcmUgZmlyc3QgdXBkYXRlLlxuICAgICAgICBpZiAoIXRoaXMuaGFzVXBkYXRlZCkge1xuICAgICAgICAgICAgLy8gUHJvZHVjZSB3YXJuaW5nIGlmIGFueSBjbGFzcyBwcm9wZXJ0aWVzIGFyZSBzaGFkb3dlZCBieSBjbGFzcyBmaWVsZHNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFkb3dlZFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNvbnN0cnVjdG9yLl9fcmVhY3RpdmVQcm9wZXJ0eUtleXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocCkgJiYgISgoX2EgPSB0aGlzLl9faW5zdGFuY2VQcm9wZXJ0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKHApKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93ZWRQcm9wZXJ0aWVzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhZG93ZWRQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBvbiBlbGVtZW50ICR7dGhpcy5sb2NhbE5hbWV9IHdpbGwgbm90IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHRyaWdnZXIgdXBkYXRlcyBhcyBleHBlY3RlZCBiZWNhdXNlIHRoZXkgYXJlIHNldCB1c2luZyBjbGFzcyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmaWVsZHM6ICR7c2hhZG93ZWRQcm9wZXJ0aWVzLmpvaW4oJywgJyl9LiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOYXRpdmUgY2xhc3MgZmllbGRzIGFuZCBzb21lIGNvbXBpbGVkIG91dHB1dCB3aWxsIG92ZXJ3cml0ZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBhY2Nlc3NvcnMgdXNlZCBmb3IgZGV0ZWN0aW5nIGNoYW5nZXMuIFNlZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBodHRwczovL2xpdC5kZXYvbXNnL2NsYXNzLWZpZWxkLXNoYWRvd2luZyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWl4aW4gaW5zdGFuY2UgcHJvcGVydGllcyBvbmNlLCBpZiB0aGV5IGV4aXN0LlxuICAgICAgICBpZiAodGhpcy5fX2luc3RhbmNlUHJvcGVydGllcykge1xuICAgICAgICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yIGxvb3BzXG4gICAgICAgICAgICAvLyBleHBlY3RpbmcgYXJyYXlzXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5fX2luc3RhbmNlUHJvcGVydGllcy5mb3JFYWNoKCh2LCBwKSA9PiAodGhpc1twXSA9IHYpKTtcbiAgICAgICAgICAgIHRoaXMuX19pbnN0YW5jZVByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjaGFuZ2VkUHJvcGVydGllcyA9IHRoaXMuXyRjaGFuZ2VkUHJvcGVydGllcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IHRoaXMuc2hvdWxkVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpbGxVcGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuX19jb250cm9sbGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKGMpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gYy5ob3N0VXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX21hcmtVcGRhdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgYGZpcnN0VXBkYXRlZGAgYW5kIGB1cGRhdGVkYCBmcm9tIHJ1bm5pbmcgd2hlbiB0aGVyZSdzIGFuXG4gICAgICAgICAgICAvLyB1cGRhdGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBFbnN1cmUgZWxlbWVudCBjYW4gYWNjZXB0IGFkZGl0aW9uYWwgdXBkYXRlcyBhZnRlciBhbiBleGNlcHRpb24uXG4gICAgICAgICAgICB0aGlzLl9fbWFya1VwZGF0ZWQoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHVwZGF0ZSBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBwZW5kaW5nIGFuZCBmdXJ0aGVyIHVwZGF0ZXMgYXJlIG5vdyBhbGxvd2VkLlxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl8kZGlkVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIGJlZm9yZSBgdXBkYXRlKClgIHRvIGNvbXB1dGUgdmFsdWVzIG5lZWRlZCBkdXJpbmcgdGhlIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudCBgd2lsbFVwZGF0ZWAgdG8gY29tcHV0ZSBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBkZXBlbmQgb24gb3RoZXJcbiAgICAgKiBwcm9wZXJ0aWVzIGFuZCBhcmUgdXNlZCBpbiB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHdpbGxVcGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgKiAgIC8vIG9ubHkgbmVlZCB0byBjaGVjayBjaGFuZ2VkIHByb3BlcnRpZXMgZm9yIGFuIGV4cGVuc2l2ZSBjb21wdXRhdGlvbi5cbiAgICAgKiAgIGlmIChjaGFuZ2VkUHJvcGVydGllcy5oYXMoJ2ZpcnN0TmFtZScpIHx8IGNoYW5nZWRQcm9wZXJ0aWVzLmhhcygnbGFzdE5hbWUnKSkge1xuICAgICAqICAgICB0aGlzLnNoYSA9IGNvbXB1dGVTSEEoYCR7dGhpcy5maXJzdE5hbWV9ICR7dGhpcy5sYXN0TmFtZX1gKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiByZW5kZXIoKSB7XG4gICAgICogICByZXR1cm4gaHRtbGBTSEE6ICR7dGhpcy5zaGF9YDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIHdpbGxVcGRhdGUoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7IH1cbiAgICAvLyBOb3RlLCB0aGlzIGlzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwb2x5ZmlsbC1zdXBwb3J0LlxuICAgIC8vIEBpbnRlcm5hbFxuICAgIF8kZGlkVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fX2NvbnRyb2xsZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoYykgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBjLmhvc3RVcGRhdGVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjKTsgfSk7XG4gICAgICAgIGlmICghdGhpcy5oYXNVcGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maXJzdFVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgICAgIGlmICh0aGlzLmlzVXBkYXRlUGVuZGluZyAmJlxuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5lbmFibGVkV2FybmluZ3MuaW5kZXhPZignY2hhbmdlLWluLXVwZGF0ZScpID49IDApIHtcbiAgICAgICAgICAgIGlzc3VlV2FybmluZygnY2hhbmdlLWluLXVwZGF0ZScsIGBFbGVtZW50ICR7dGhpcy5sb2NhbE5hbWV9IHNjaGVkdWxlZCBhbiB1cGRhdGUgYCArXG4gICAgICAgICAgICAgICAgYChnZW5lcmFsbHkgYmVjYXVzZSBhIHByb3BlcnR5IHdhcyBzZXQpIGAgK1xuICAgICAgICAgICAgICAgIGBhZnRlciBhbiB1cGRhdGUgY29tcGxldGVkLCBjYXVzaW5nIGEgbmV3IHVwZGF0ZSB0byBiZSBzY2hlZHVsZWQuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIGlzIGluZWZmaWNpZW50IGFuZCBzaG91bGQgYmUgYXZvaWRlZCB1bmxlc3MgdGhlIG5leHQgdXBkYXRlIGAgK1xuICAgICAgICAgICAgICAgIGBjYW4gb25seSBiZSBzY2hlZHVsZWQgYXMgYSBzaWRlIGVmZmVjdCBvZiB0aGUgcHJldmlvdXMgdXBkYXRlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9fbWFya1VwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuXyRjaGFuZ2VkUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc1VwZGF0ZVBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBlbGVtZW50IGhhcyBjb21wbGV0ZWQgdXBkYXRpbmcuXG4gICAgICogVGhlIFByb21pc2UgdmFsdWUgaXMgYSBib29sZWFuIHRoYXQgaXMgYHRydWVgIGlmIHRoZSBlbGVtZW50IGNvbXBsZXRlZCB0aGVcbiAgICAgKiB1cGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFub3RoZXIgdXBkYXRlLiBUaGUgUHJvbWlzZSByZXN1bHQgaXMgYGZhbHNlYCBpZlxuICAgICAqIGEgcHJvcGVydHkgd2FzIHNldCBpbnNpZGUgYHVwZGF0ZWQoKWAuIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBhblxuICAgICAqIGV4Y2VwdGlvbiB3YXMgdGhyb3duIGR1cmluZyB0aGUgdXBkYXRlLlxuICAgICAqXG4gICAgICogVG8gYXdhaXQgYWRkaXRpb25hbCBhc3luY2hyb25vdXMgd29yaywgb3ZlcnJpZGUgdGhlIGBnZXRVcGRhdGVDb21wbGV0ZWBcbiAgICAgKiBtZXRob2QuIEZvciBleGFtcGxlLCBpdCBpcyBzb21ldGltZXMgdXNlZnVsIHRvIGF3YWl0IGEgcmVuZGVyZWQgZWxlbWVudFxuICAgICAqIGJlZm9yZSBmdWxmaWxsaW5nIHRoaXMgUHJvbWlzZS4gVG8gZG8gdGhpcywgZmlyc3QgYXdhaXRcbiAgICAgKiBgc3VwZXIuZ2V0VXBkYXRlQ29tcGxldGUoKWAsIHRoZW4gYW55IHN1YnNlcXVlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSBvZiBhIGJvb2xlYW4gdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSB1cGRhdGUgY29tcGxldGVkXG4gICAgICogICAgIHdpdGhvdXQgdHJpZ2dlcmluZyBhbm90aGVyIHVwZGF0ZS5cbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIGdldCB1cGRhdGVDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIHRoZSBgdXBkYXRlQ29tcGxldGVgIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBJdCBpcyBub3Qgc2FmZSB0byBvdmVycmlkZSB0aGUgYHVwZGF0ZUNvbXBsZXRlYCBnZXR0ZXIgZGlyZWN0bHkgZHVlIHRvIGFcbiAgICAgKiBsaW1pdGF0aW9uIGluIFR5cGVTY3JpcHQgd2hpY2ggbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGNhbGwgYVxuICAgICAqIHN1cGVyY2xhc3MgZ2V0dGVyIChlLmcuIGBzdXBlci51cGRhdGVDb21wbGV0ZS50aGVuKC4uLilgKSB3aGVuIHRoZSB0YXJnZXRcbiAgICAgKiBsYW5ndWFnZSBpcyBFUzUgKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzM4KS5cbiAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbnN0ZWFkLiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgICogICBvdmVycmlkZSBhc3luYyBnZXRVcGRhdGVDb21wbGV0ZSgpIHtcbiAgICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3VwZXIuZ2V0VXBkYXRlQ29tcGxldGUoKTtcbiAgICAgKiAgICAgYXdhaXQgdGhpcy5fbXlDaGlsZC51cGRhdGVDb21wbGV0ZTtcbiAgICAgKiAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSBvZiBhIGJvb2xlYW4gdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSB1cGRhdGUgY29tcGxldGVkXG4gICAgICogICAgIHdpdGhvdXQgdHJpZ2dlcmluZyBhbm90aGVyIHVwZGF0ZS5cbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIGdldFVwZGF0ZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3VwZGF0ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGB1cGRhdGUoKWAgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZSBlbGVtZW50IHJlcXVlc3RzXG4gICAgICogYW4gdXBkYXRlLiBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAsIGJ1dCB0aGlzIGNhbiBiZVxuICAgICAqIGN1c3RvbWl6ZWQgdG8gY29udHJvbCB3aGVuIHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfY2hhbmdlZFByb3BlcnRpZXMgTWFwIG9mIGNoYW5nZWQgcHJvcGVydGllcyB3aXRoIG9sZCB2YWx1ZXNcbiAgICAgKiBAY2F0ZWdvcnkgdXBkYXRlc1xuICAgICAqL1xuICAgIHNob3VsZFVwZGF0ZShfY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGVsZW1lbnQuIFRoaXMgbWV0aG9kIHJlZmxlY3RzIHByb3BlcnR5IHZhbHVlcyB0byBhdHRyaWJ1dGVzLlxuICAgICAqIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIHJlbmRlciBhbmQga2VlcCB1cGRhdGVkIGVsZW1lbnQgRE9NLlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCAqbm90KiB0cmlnZ2VyXG4gICAgICogYW5vdGhlciB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX2NoYW5nZWRQcm9wZXJ0aWVzIE1hcCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgd2l0aCBvbGQgdmFsdWVzXG4gICAgICogQGNhdGVnb3J5IHVwZGF0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGUoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yXG4gICAgICAgICAgICAvLyBsb29wcyBleHBlY3RpbmcgYXJyYXlzXG4gICAgICAgICAgICB0aGlzLl9fcmVmbGVjdGluZ1Byb3BlcnRpZXMuZm9yRWFjaCgodiwgaykgPT4gdGhpcy5fX3Byb3BlcnR5VG9BdHRyaWJ1dGUoaywgdGhpc1trXSwgdikpO1xuICAgICAgICAgICAgdGhpcy5fX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19tYXJrVXBkYXRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW5ldmVyIHRoZSBlbGVtZW50IGlzIHVwZGF0ZWQuIEltcGxlbWVudCB0byBwZXJmb3JtXG4gICAgICogcG9zdC11cGRhdGluZyB0YXNrcyB2aWEgRE9NIEFQSXMsIGZvciBleGFtcGxlLCBmb2N1c2luZyBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogU2V0dGluZyBwcm9wZXJ0aWVzIGluc2lkZSB0aGlzIG1ldGhvZCB3aWxsIHRyaWdnZXIgdGhlIGVsZW1lbnQgdG8gdXBkYXRlXG4gICAgICogYWdhaW4gYWZ0ZXIgdGhpcyB1cGRhdGUgY3ljbGUgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqIEBjYXRlZ29yeSB1cGRhdGVzXG4gICAgICovXG4gICAgdXBkYXRlZChfY2hhbmdlZFByb3BlcnRpZXMpIHsgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBmaXJzdCB1cGRhdGVkLiBJbXBsZW1lbnQgdG8gcGVyZm9ybSBvbmUgdGltZVxuICAgICAqIHdvcmsgb24gdGhlIGVsZW1lbnQgYWZ0ZXIgdXBkYXRlLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBmaXJzdFVwZGF0ZWQoKSB7XG4gICAgICogICB0aGlzLnJlbmRlclJvb3QuZ2V0RWxlbWVudEJ5SWQoJ215LXRleHQtYXJlYScpLmZvY3VzKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2V0dGluZyBwcm9wZXJ0aWVzIGluc2lkZSB0aGlzIG1ldGhvZCB3aWxsIHRyaWdnZXIgdGhlIGVsZW1lbnQgdG8gdXBkYXRlXG4gICAgICogYWdhaW4gYWZ0ZXIgdGhpcyB1cGRhdGUgY3ljbGUgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqIEBjYXRlZ29yeSB1cGRhdGVzXG4gICAgICovXG4gICAgZmlyc3RVcGRhdGVkKF9jaGFuZ2VkUHJvcGVydGllcykgeyB9XG59XG5fZSA9IGZpbmFsaXplZDtcbi8qKlxuICogTWFya3MgY2xhc3MgYXMgaGF2aW5nIGZpbmlzaGVkIGNyZWF0aW5nIHByb3BlcnRpZXMuXG4gKi9cblJlYWN0aXZlRWxlbWVudFtfZV0gPSB0cnVlO1xuLyoqXG4gKiBNZW1vaXplZCBsaXN0IG9mIGFsbCBlbGVtZW50IHByb3BlcnRpZXMsIGluY2x1ZGluZyBhbnkgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzLlxuICogQ3JlYXRlZCBsYXppbHkgb24gdXNlciBzdWJjbGFzc2VzIHdoZW4gZmluYWxpemluZyB0aGUgY2xhc3MuXG4gKiBAbm9jb2xsYXBzZVxuICogQGNhdGVnb3J5IHByb3BlcnRpZXNcbiAqL1xuUmVhY3RpdmVFbGVtZW50LmVsZW1lbnRQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBNZW1vaXplZCBsaXN0IG9mIGFsbCBlbGVtZW50IHN0eWxlcy5cbiAqIENyZWF0ZWQgbGF6aWx5IG9uIHVzZXIgc3ViY2xhc3NlcyB3aGVuIGZpbmFsaXppbmcgdGhlIGNsYXNzLlxuICogQG5vY29sbGFwc2VcbiAqIEBjYXRlZ29yeSBzdHlsZXNcbiAqL1xuUmVhY3RpdmVFbGVtZW50LmVsZW1lbnRTdHlsZXMgPSBbXTtcbi8qKlxuICogT3B0aW9ucyB1c2VkIHdoZW4gY2FsbGluZyBgYXR0YWNoU2hhZG93YC4gU2V0IHRoaXMgcHJvcGVydHkgdG8gY3VzdG9taXplXG4gKiB0aGUgb3B0aW9ucyBmb3IgdGhlIHNoYWRvd1Jvb3Q7IGZvciBleGFtcGxlLCB0byBjcmVhdGUgYSBjbG9zZWRcbiAqIHNoYWRvd1Jvb3Q6IGB7bW9kZTogJ2Nsb3NlZCd9YC5cbiAqXG4gKiBOb3RlLCB0aGVzZSBvcHRpb25zIGFyZSB1c2VkIGluIGBjcmVhdGVSZW5kZXJSb290YC4gSWYgdGhpcyBtZXRob2RcbiAqIGlzIGN1c3RvbWl6ZWQsIG9wdGlvbnMgc2hvdWxkIGJlIHJlc3BlY3RlZCBpZiBwb3NzaWJsZS5cbiAqIEBub2NvbGxhcHNlXG4gKiBAY2F0ZWdvcnkgcmVuZGVyaW5nXG4gKi9cblJlYWN0aXZlRWxlbWVudC5zaGFkb3dSb290T3B0aW9ucyA9IHsgbW9kZTogJ29wZW4nIH07XG4vLyBBcHBseSBwb2x5ZmlsbHMgaWYgYXZhaWxhYmxlXG5wb2x5ZmlsbFN1cHBvcnQgPT09IG51bGwgfHwgcG9seWZpbGxTdXBwb3J0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwb2x5ZmlsbFN1cHBvcnQoeyBSZWFjdGl2ZUVsZW1lbnQgfSk7XG4vLyBEZXYgbW9kZSB3YXJuaW5ncy4uLlxue1xuICAgIC8vIERlZmF1bHQgd2FybmluZyBzZXQuXG4gICAgUmVhY3RpdmVFbGVtZW50LmVuYWJsZWRXYXJuaW5ncyA9IFsnY2hhbmdlLWluLXVwZGF0ZSddO1xuICAgIGNvbnN0IGVuc3VyZU93bldhcm5pbmdzID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICAgICAgaWYgKCFjdG9yLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ2VuYWJsZWRXYXJuaW5ncycpKSkge1xuICAgICAgICAgICAgY3Rvci5lbmFibGVkV2FybmluZ3MgPSBjdG9yLmVuYWJsZWRXYXJuaW5ncy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdGl2ZUVsZW1lbnQuZW5hYmxlV2FybmluZyA9IGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICAgIGVuc3VyZU93bldhcm5pbmdzKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkV2FybmluZ3MuaW5kZXhPZih3YXJuaW5nKSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZFdhcm5pbmdzLnB1c2god2FybmluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0aXZlRWxlbWVudC5kaXNhYmxlV2FybmluZyA9IGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICAgIGVuc3VyZU93bldhcm5pbmdzKHRoaXMpO1xuICAgICAgICBjb25zdCBpID0gdGhpcy5lbmFibGVkV2FybmluZ3MuaW5kZXhPZih3YXJuaW5nKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkV2FybmluZ3Muc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIElNUE9SVEFOVDogZG8gbm90IGNoYW5nZSB0aGUgcHJvcGVydHkgbmFtZSBvciB0aGUgYXNzaWdubWVudCBleHByZXNzaW9uLlxuLy8gVGhpcyBsaW5lIHdpbGwgYmUgdXNlZCBpbiByZWdleGVzIHRvIHNlYXJjaCBmb3IgUmVhY3RpdmVFbGVtZW50IHVzYWdlLlxuKChfZCA9IGdsb2JhbC5yZWFjdGl2ZUVsZW1lbnRWZXJzaW9ucykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKGdsb2JhbC5yZWFjdGl2ZUVsZW1lbnRWZXJzaW9ucyA9IFtdKSkucHVzaCgnMS42LjMnKTtcbmlmIChnbG9iYWwucmVhY3RpdmVFbGVtZW50VmVyc2lvbnMubGVuZ3RoID4gMSkge1xuICAgIGlzc3VlV2FybmluZygnbXVsdGlwbGUtdmVyc2lvbnMnLCBgTXVsdGlwbGUgdmVyc2lvbnMgb2YgTGl0IGxvYWRlZC4gTG9hZGluZyBtdWx0aXBsZSB2ZXJzaW9ucyBgICtcbiAgICAgICAgYGlzIG5vdCByZWNvbW1lbmRlZC5gKTtcbn1cblxuZXhwb3J0IHsgUmVhY3RpdmVFbGVtZW50LCBkZWZhdWx0Q29udmVydGVyLCBub3RFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3RpdmUtZWxlbWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJjdXN0b21FbGVtZW50cyIsIkhUTUxFbGVtZW50IiwiZ2V0Q29tcGF0aWJsZVN0eWxlIiwiYWRvcHRTdHlsZXMiLCJDU1NSZXN1bHQiLCJjc3MiLCJzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMiLCJ1bnNhZmVDU1MiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsInJlcXVlc3RVcGRhdGVUaGVuYWJsZSIsImlzc3VlV2FybmluZyIsInRydXN0ZWRUeXBlcyIsImVtcHR5U3RyaW5nRm9yQm9vbGVhbkF0dHJpYnV0ZSIsImVtcHR5U2NyaXB0IiwicG9seWZpbGxTdXBwb3J0IiwicmVhY3RpdmVFbGVtZW50UG9seWZpbGxTdXBwb3J0RGV2TW9kZSIsImlzc3VlZFdhcm5pbmdzIiwibGl0SXNzdWVkV2FybmluZ3MiLCJTZXQiLCJjb2RlIiwid2FybmluZyIsImhhcyIsImNvbnNvbGUiLCJ3YXJuIiwiYWRkIiwiU2hhZHlET00iLCJpblVzZSIsInVuZGVmaW5lZCIsIm5hbWUiLCJ0aGVuIiwib25mdWxmaWxsZWQiLCJfb25yZWplY3RlZCIsImRlYnVnTG9nRXZlbnQiLCJldmVudCIsInNob3VsZEVtaXQiLCJlbWl0TGl0RGVidWdMb2dFdmVudHMiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5IiwicHJvcCIsIl9vYmoiLCJkZWZhdWx0Q29udmVydGVyIiwidG9BdHRyaWJ1dGUiLCJ2YWx1ZSIsInR5cGUiLCJCb29sZWFuIiwiT2JqZWN0IiwiQXJyYXkiLCJKU09OIiwic3RyaW5naWZ5IiwiZnJvbUF0dHJpYnV0ZSIsImZyb21WYWx1ZSIsIk51bWJlciIsInBhcnNlIiwiZSIsIm5vdEVxdWFsIiwib2xkIiwiZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb24iLCJhdHRyaWJ1dGUiLCJTdHJpbmciLCJjb252ZXJ0ZXIiLCJyZWZsZWN0IiwiaGFzQ2hhbmdlZCIsImZpbmFsaXplZCIsIlJlYWN0aXZlRWxlbWVudCIsImNvbnN0cnVjdG9yIiwiX19pbnN0YW5jZVByb3BlcnRpZXMiLCJNYXAiLCJpc1VwZGF0ZVBlbmRpbmciLCJoYXNVcGRhdGVkIiwiX19yZWZsZWN0aW5nUHJvcGVydHkiLCJfX2luaXRpYWxpemUiLCJhZGRJbml0aWFsaXplciIsImluaXRpYWxpemVyIiwiZmluYWxpemUiLCJfaW5pdGlhbGl6ZXJzIiwicHVzaCIsIm9ic2VydmVkQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJlbGVtZW50UHJvcGVydGllcyIsImZvckVhY2giLCJ2IiwicCIsImF0dHIiLCJfX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eSIsIl9fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcCIsInNldCIsImNyZWF0ZVByb3BlcnR5Iiwib3B0aW9ucyIsInN0YXRlIiwibm9BY2Nlc3NvciIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5Iiwia2V5IiwiU3ltYm9sIiwiZGVzY3JpcHRvciIsImdldFByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiX19yZWFjdGl2ZVByb3BlcnR5S2V5cyIsImdldCIsIm9sZFZhbHVlIiwicmVxdWVzdFVwZGF0ZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXRQcm9wZXJ0eU9wdGlvbnMiLCJzdXBlckN0b3IiLCJnZXRQcm90b3R5cGVPZiIsInByb3BzIiwicHJvcGVydGllcyIsInByb3BLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImVsZW1lbnRTdHlsZXMiLCJmaW5hbGl6ZVN0eWxlcyIsInN0eWxlcyIsIndhcm5SZW1vdmVkT3JSZW5hbWVkIiwicmVuYW1lZCIsImlzQXJyYXkiLCJmbGF0IiwiSW5maW5pdHkiLCJyZXZlcnNlIiwicyIsInVuc2hpZnQiLCJ0b0xvd2VyQ2FzZSIsIl9fdXBkYXRlUHJvbWlzZSIsIlByb21pc2UiLCJyZXMiLCJlbmFibGVVcGRhdGluZyIsIl8kY2hhbmdlZFByb3BlcnRpZXMiLCJfX3NhdmVJbnN0YW5jZVByb3BlcnRpZXMiLCJpIiwiYWRkQ29udHJvbGxlciIsImNvbnRyb2xsZXIiLCJfX2NvbnRyb2xsZXJzIiwicmVuZGVyUm9vdCIsImlzQ29ubmVjdGVkIiwiaG9zdENvbm5lY3RlZCIsImNhbGwiLCJyZW1vdmVDb250cm9sbGVyIiwic3BsaWNlIiwiaW5kZXhPZiIsIl92IiwiY3JlYXRlUmVuZGVyUm9vdCIsInNoYWRvd1Jvb3QiLCJhdHRhY2hTaGFkb3ciLCJzaGFkb3dSb290T3B0aW9ucyIsImNvbm5lY3RlZENhbGxiYWNrIiwiYyIsIl9yZXF1ZXN0ZWRVcGRhdGUiLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsImhvc3REaXNjb25uZWN0ZWQiLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJfb2xkIiwiXyRhdHRyaWJ1dGVUb1Byb3BlcnR5IiwiX19wcm9wZXJ0eVRvQXR0cmlidXRlIiwiYXR0clZhbHVlIiwiZW5hYmxlZFdhcm5pbmdzIiwibG9jYWxOYW1lIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiY3RvciIsInByb3BOYW1lIiwic2hvdWxkUmVxdWVzdFVwZGF0ZSIsIl9fcmVmbGVjdGluZ1Byb3BlcnRpZXMiLCJfX2VucXVldWVVcGRhdGUiLCJyZWplY3QiLCJyZXN1bHQiLCJzY2hlZHVsZVVwZGF0ZSIsInBlcmZvcm1VcGRhdGUiLCJraW5kIiwic2hhZG93ZWRQcm9wZXJ0aWVzIiwibGVuZ3RoIiwiRXJyb3IiLCJqb2luIiwic2hvdWxkVXBkYXRlIiwiY2hhbmdlZFByb3BlcnRpZXMiLCJ3aWxsVXBkYXRlIiwiaG9zdFVwZGF0ZSIsInVwZGF0ZSIsIl9fbWFya1VwZGF0ZWQiLCJfJGRpZFVwZGF0ZSIsIl9jaGFuZ2VkUHJvcGVydGllcyIsImhvc3RVcGRhdGVkIiwiZmlyc3RVcGRhdGVkIiwidXBkYXRlZCIsInVwZGF0ZUNvbXBsZXRlIiwiZ2V0VXBkYXRlQ29tcGxldGUiLCJrIiwibW9kZSIsImVuc3VyZU93bldhcm5pbmdzIiwic2xpY2UiLCJlbmFibGVXYXJuaW5nIiwiZGlzYWJsZVdhcm5pbmciLCJyZWFjdGl2ZUVsZW1lbnRWZXJzaW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lit/reactive-element/node/development/reactive-element.js\n");

/***/ })

};
;