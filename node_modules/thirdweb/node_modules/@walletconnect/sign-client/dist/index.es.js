import{RELAYER_DEFAULT_PROTOCOL as it,RELAYER_EVENTS as ve,VERIFY_SERVER as st,EXPIRER_EVENTS as rt,PAIRING_EVENTS as Pe,Store as U,Core as nt}from"@walletconnect/core";import{pino as ot,getDefaultLoggerOptions as at,generateChildLogger as ct,getLoggerContext as lt}from"@walletconnect/logger";import{IEngine as ht,ISignClient as pt}from"@walletconnect/types";import{getInternalError as l,calcExpiry as N,createDelayedPromise as G,engineEvent as g,getSdkError as I,getDeepLink as dt,handleDeeplinkRedirect as ut,isSessionCompatible as gt,hashKey as ue,parseChainId as ge,createEncodedRecap as wt,getRecapFromResources as we,mergeEncodedRecaps as mt,validateSignedCacao as Oe,getNamespacedDidChainId as Te,getDidAddress as Ae,getMethodsFromRecap as xe,getChainsFromRecap as De,buildNamespacesFromAuth as Ve,formatMessage as yt,isBrowser as Rt,hashMessage as te,isExpired as k,MemoryStore as Y,isValidParams as x,isUndefined as X,isValidRelays as Et,isValidObject as Ce,isValidRequiredNamespaces as St,isValidNamespaces as me,isConformingNamespaces as be,isValidString as V,isValidErrorReason as _t,isValidRelay as ft,isValidController as It,isValidNamespacesChainId as $e,isValidRequest as qt,isValidNamespacesRequest as Nt,isValidRequestExpiry as vt,isValidResponse as Pt,isValidEvent as Ot,isValidNamespacesEvent as Tt,parseExpirerTarget as At,isValidId as xt,TYPE_1 as ye,getAppMetadata as Dt}from"@walletconnect/utils";import Vt,{EventEmitter as Ct}from"events";import{THIRTY_DAYS as bt,SEVEN_DAYS as Me,FIVE_MINUTES as q,ONE_DAY as C,ONE_HOUR as Le,ONE_SECOND as $t,toMiliseconds as Ke}from"@walletconnect/time";import{payloadId as j,getBigIntRpcId as ie,isJsonRpcResult as b,isJsonRpcError as $,formatJsonRpcRequest as Re,formatJsonRpcResult as Mt,formatJsonRpcError as Lt,isJsonRpcRequest as Kt,isJsonRpcResponse as Ut}from"@walletconnect/jsonrpc-utils";const Ee="wc",Se=2,_e="client",se=`${Ee}@${Se}:${_e}:`,re={name:_e,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},Gt={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},kt={database:":memory:"},fe="WALLETCONNECT_DEEPLINK_CHOICE",jt={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ft="history",Qt="0.3",Ue="proposal",zt=bt,Ge="Proposal expired",ke="session",M=Me,je="engine",R={wc_sessionPropose:{req:{ttl:q,prompt:!0,tag:1100},res:{ttl:q,prompt:!1,tag:1101},reject:{ttl:q,prompt:!1,tag:1120},autoReject:{ttl:q,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:q,prompt:!1,tag:1102},res:{ttl:q,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:C,prompt:!1,tag:1104},res:{ttl:C,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:C,prompt:!1,tag:1106},res:{ttl:C,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:q,prompt:!0,tag:1108},res:{ttl:q,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:q,prompt:!0,tag:1110},res:{ttl:q,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:C,prompt:!1,tag:1112},res:{ttl:C,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:C,prompt:!1,tag:1114},res:{ttl:C,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:Le,prompt:!0,tag:1116},res:{ttl:Le,prompt:!1,tag:1117},reject:{ttl:q,prompt:!1,tag:1118},autoReject:{ttl:q,prompt:!1,tag:1119}}},ne={min:q,max:Me},D={idle:"IDLE",active:"ACTIVE"},Fe="request",Qe=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"],ze="wc",Ht=1.5,He="auth",Ye="authKeys",Xe="pairingTopics",Je="requests",J=`${ze}@${1.5}:${He}:`,B=`${J}:PUB_KEY`;var Yt=Object.defineProperty,Xt=Object.defineProperties,Jt=Object.getOwnPropertyDescriptors,Be=Object.getOwnPropertySymbols,Bt=Object.prototype.hasOwnProperty,Wt=Object.prototype.propertyIsEnumerable,We=(E,n,t)=>n in E?Yt(E,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):E[n]=t,y=(E,n)=>{for(var t in n||(n={}))Bt.call(n,t)&&We(E,t,n[t]);if(Be)for(var t of Be(n))Wt.call(n,t)&&We(E,t,n[t]);return E},L=(E,n)=>Xt(E,Jt(n));class Zt extends ht{constructor(n){super(n),this.name=je,this.events=new Vt,this.initialized=!1,this.requestQueue={state:D.idle,queue:[]},this.sessionRequestQueue={state:D.idle,queue:[]},this.requestQueueDelay=$t,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(R)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},Ke(this.requestQueueDelay)))},this.connect=async t=>{await this.isInitialized();const e=L(y({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(e);const{pairingTopic:i,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:o,relays:a}=e;let c=i,h,d=!1;try{c&&(d=this.client.core.pairing.pairings.get(c).active)}catch(P){throw this.client.logger.error(`connect() -> pairing.get(${c}) failed`),P}if(!c||!d){const{topic:P,uri:O}=await this.client.core.pairing.create();c=P,h=O}if(!c){const{message:P}=l("NO_MATCHING_KEY",`connect() pairing topic: ${c}`);throw new Error(P)}const u=await this.client.core.crypto.generateKeyPair(),p=R.wc_sessionPropose.req.ttl||q,w=N(p),m=y({requiredNamespaces:s,optionalNamespaces:r,relays:a??[{protocol:it}],proposer:{publicKey:u,metadata:this.client.metadata},expiryTimestamp:w,pairingTopic:c},o&&{sessionProperties:o}),{reject:S,resolve:T,done:_}=G(p,Ge);this.events.once(g("session_connect"),async({error:P,session:O})=>{if(P)S(P);else if(O){O.self.publicKey=u;const F=L(y({},O),{pairingTopic:m.pairingTopic,requiredNamespaces:m.requiredNamespaces,optionalNamespaces:m.optionalNamespaces});await this.client.session.set(O.topic,F),await this.setExpiry(O.topic,O.expiry),c&&await this.client.core.pairing.updateMetadata({topic:c,metadata:O.peer.metadata}),this.cleanupDuplicatePairings(F),T(F)}});const v=await this.sendRequest({topic:c,method:"wc_sessionPropose",params:m,throwOnFailedPublish:!0});return await this.setProposal(v,y({id:v},m)),{uri:h,approval:_}},this.pair=async t=>{await this.isInitialized();try{return await this.client.core.pairing.pair(t)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async t=>{await this.isInitialized();try{await this.isValidApprove(t)}catch(_){throw this.client.logger.error("approve() -> isValidApprove() failed"),_}const{id:e,relayProtocol:i,namespaces:s,sessionProperties:r,sessionConfig:o}=t;let a;try{a=this.client.proposal.get(e)}catch(_){throw this.client.logger.error(`approve() -> proposal.get(${e}) failed`),_}const{pairingTopic:c,proposer:h,requiredNamespaces:d,optionalNamespaces:u}=a,p=await this.client.core.crypto.generateKeyPair(),w=h.publicKey,m=await this.client.core.crypto.generateSharedKey(p,w),S=y(y({relay:{protocol:i??"irn"},namespaces:s,controller:{publicKey:p,metadata:this.client.metadata},expiry:N(M)},r&&{sessionProperties:r}),o&&{sessionConfig:o});await this.client.core.relayer.subscribe(m);const T=L(y({},S),{topic:m,requiredNamespaces:d,optionalNamespaces:u,pairingTopic:c,acknowledged:!1,self:S.controller,peer:{publicKey:h.publicKey,metadata:h.metadata},controller:p});await this.client.session.set(m,T);try{await this.sendResult({id:e,topic:c,result:{relay:{protocol:i??"irn"},responderPublicKey:p},throwOnFailedPublish:!0}),await this.sendRequest({topic:m,method:"wc_sessionSettle",params:S,throwOnFailedPublish:!0})}catch(_){throw this.client.logger.error(_),this.client.session.delete(m,I("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(m),_}return await this.client.core.pairing.updateMetadata({topic:c,metadata:h.metadata}),await this.client.proposal.delete(e,I("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:c}),await this.setExpiry(m,N(M)),{topic:m,acknowledged:()=>new Promise(_=>setTimeout(()=>_(this.client.session.get(m)),500))}},this.reject=async t=>{await this.isInitialized();try{await this.isValidReject(t)}catch(r){throw this.client.logger.error("reject() -> isValidReject() failed"),r}const{id:e,reason:i}=t;let s;try{s=this.client.proposal.get(e).pairingTopic}catch(r){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),r}s&&(await this.sendError({id:e,topic:s,error:i,rpcOpts:R.wc_sessionPropose.reject}),await this.client.proposal.delete(e,I("USER_DISCONNECTED")))},this.update=async t=>{await this.isInitialized();try{await this.isValidUpdate(t)}catch(d){throw this.client.logger.error("update() -> isValidUpdate() failed"),d}const{topic:e,namespaces:i}=t,{done:s,resolve:r,reject:o}=G(),a=j(),c=ie().toString(),h=this.client.session.get(e).namespaces;return this.events.once(g("session_update",a),({error:d})=>{d?o(d):r()}),await this.client.session.update(e,{namespaces:i}),await this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:i},throwOnFailedPublish:!0,clientRpcId:a,relayRpcId:c}).catch(d=>{this.client.logger.error(d),this.client.session.update(e,{namespaces:h}),o(d)}),{acknowledged:s}},this.extend=async t=>{await this.isInitialized();try{await this.isValidExtend(t)}catch(a){throw this.client.logger.error("extend() -> isValidExtend() failed"),a}const{topic:e}=t,i=j(),{done:s,resolve:r,reject:o}=G();return this.events.once(g("session_extend",i),({error:a})=>{a?o(a):r()}),await this.setExpiry(e,N(M)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:i,throwOnFailedPublish:!0}).catch(a=>{o(a)}),{acknowledged:s}},this.request=async t=>{await this.isInitialized();try{await this.isValidRequest(t)}catch(p){throw this.client.logger.error("request() -> isValidRequest() failed"),p}const{chainId:e,request:i,topic:s,expiry:r=R.wc_sessionRequest.req.ttl}=t,o=this.client.session.get(s),a=j(),c=ie().toString(),{done:h,resolve:d,reject:u}=G(r,"Request expired. Please try again.");return this.events.once(g("session_request",a),({error:p,result:w})=>{p?u(p):d(w)}),await Promise.all([new Promise(async p=>{await this.sendRequest({clientRpcId:a,relayRpcId:c,topic:s,method:"wc_sessionRequest",params:{request:L(y({},i),{expiryTimestamp:N(r)}),chainId:e},expiry:r,throwOnFailedPublish:!0}).catch(w=>u(w)),this.client.events.emit("session_request_sent",{topic:s,request:i,chainId:e,id:a}),p()}),new Promise(async p=>{var w;if(!((w=o.sessionConfig)!=null&&w.disableDeepLink)){const m=await dt(this.client.core.storage,fe);ut({id:a,topic:s,wcDeepLink:m})}p()}),h()]).then(p=>p[2])},this.respond=async t=>{await this.isInitialized(),await this.isValidRespond(t);const{topic:e,response:i}=t,{id:s}=i;b(i)?await this.sendResult({id:s,topic:e,result:i.result,throwOnFailedPublish:!0}):$(i)&&await this.sendError({id:s,topic:e,error:i.error}),this.cleanupAfterResponse(t)},this.ping=async t=>{await this.isInitialized();try{await this.isValidPing(t)}catch(i){throw this.client.logger.error("ping() -> isValidPing() failed"),i}const{topic:e}=t;if(this.client.session.keys.includes(e)){const i=j(),s=ie().toString(),{done:r,resolve:o,reject:a}=G();this.events.once(g("session_ping",i),({error:c})=>{c?a(c):o()}),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:i,relayRpcId:s}),r()])}else this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.ping({topic:e})},this.emit=async t=>{await this.isInitialized(),await this.isValidEmit(t);const{topic:e,event:i,chainId:s}=t,r=ie().toString();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:i,chainId:s},throwOnFailedPublish:!0,relayRpcId:r})},this.disconnect=async t=>{await this.isInitialized(),await this.isValidDisconnect(t);const{topic:e}=t;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:I("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(e))await this.client.core.pairing.disconnect({topic:e});else{const{message:i}=l("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(i)}},this.find=t=>(this.isInitialized(),this.client.session.getAll().filter(e=>gt(e,t))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async t=>{this.isInitialized(),this.isValidAuthenticate(t);const{chains:e,statement:i="",uri:s,domain:r,nonce:o,type:a,exp:c,nbf:h,methods:d=[],expiry:u}=t,p=[...t.resources||[]],{topic:w,uri:m}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"]});this.client.logger.info({message:"Generated new pairing",pairing:{topic:w,uri:m}});const S=await this.client.core.crypto.generateKeyPair(),T=ue(S);if(await Promise.all([this.client.auth.authKeys.set(B,{responseTopic:T,publicKey:S}),this.client.auth.pairingTopics.set(T,{topic:T,pairingTopic:w})]),await this.client.core.relayer.subscribe(T),this.client.logger.info(`sending request to new pairing topic: ${w}`),d.length>0){const{namespace:A}=ge(e[0]);let f=wt(A,"request",d);we(p)&&(f=mt(f,p.pop())),p.push(f)}const _=u&&u>R.wc_sessionAuthenticate.req.ttl?u:R.wc_sessionAuthenticate.req.ttl,v={authPayload:{type:a??"caip122",chains:e,statement:i,aud:s,domain:r,version:"1",nonce:o,iat:new Date().toISOString(),exp:c,nbf:h,resources:p},requester:{publicKey:S,metadata:this.client.metadata},expiryTimestamp:N(_)},P={eip155:{chains:e,methods:[...new Set(["personal_sign",...d])],events:["chainChanged","accountsChanged"]}},O={requiredNamespaces:{},optionalNamespaces:P,relays:[{protocol:"irn"}],pairingTopic:w,proposer:{publicKey:S,metadata:this.client.metadata},expiryTimestamp:N(R.wc_sessionPropose.req.ttl)},{done:F,resolve:Ie,reject:ae}=G(_,"Request expired"),W=async({error:A,session:f})=>{if(this.events.off(g("session_request",K),ce),A)ae(A);else if(f){f.self.publicKey=S,await this.client.session.set(f.topic,f),await this.setExpiry(f.topic,f.expiry),w&&await this.client.core.pairing.updateMetadata({topic:w,metadata:f.peer.metadata});const z=this.client.session.get(f.topic);await this.deleteProposal(Q),Ie({session:z})}},ce=async A=>{if(await this.deletePendingAuthRequest(K,{message:"fulfilled",code:0}),A.error){const H=I("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return A.error.code===H.code?void 0:(this.events.off(g("session_connect"),W),ae(A.error.message))}await this.deleteProposal(Q),this.events.off(g("session_connect"),W);const{cacaos:f,responder:z}=A.result,le=[],qe=[];for(const H of f){await Oe({cacao:H,projectId:this.client.core.projectId})||(this.client.logger.error(H,"Signature verification failed"),ae(I("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:he}=H,pe=we(he.resources),Ne=[Te(he.iss)],et=Ae(he.iss);if(pe){const de=xe(pe),tt=De(pe);le.push(...de),Ne.push(...tt)}for(const de of Ne)qe.push(`${de}:${et}`)}const Z=await this.client.core.crypto.generateSharedKey(S,z.publicKey);let ee;le.length>0&&(ee={topic:Z,acknowledged:!0,self:{publicKey:S,metadata:this.client.metadata},peer:z,controller:z.publicKey,expiry:N(M),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:w,namespaces:Ve([...new Set(le)],[...new Set(qe)])},await this.client.core.relayer.subscribe(Z),await this.client.session.set(Z,ee),ee=this.client.session.get(Z)),Ie({auths:f,session:ee})},K=j(),Q=j();this.events.once(g("session_connect"),W),this.events.once(g("session_request",K),ce);try{await Promise.all([this.sendRequest({topic:w,method:"wc_sessionAuthenticate",params:v,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:K}),this.sendRequest({topic:w,method:"wc_sessionPropose",params:O,expiry:R.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:Q})])}catch(A){throw this.events.off(g("session_connect"),W),this.events.off(g("session_request",K),ce),A}return await this.setProposal(Q,y({id:Q},O)),await this.setAuthRequest(K,{request:L(y({},v),{verifyContext:{}}),pairingTopic:w}),{uri:m,response:F}},this.approveSessionAuthenticate=async t=>{this.isInitialized();const{id:e,auths:i}=t,s=this.getPendingAuthRequest(e);if(!s)throw new Error(`Could not find pending auth request with id ${e}`);const r=s.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),a=ue(r),c={type:ye,receiverPublicKey:r,senderPublicKey:o},h=[],d=[];for(const w of i){if(!await Oe({cacao:w,projectId:this.client.core.projectId})){const v=I("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:e,topic:a,error:v,encodeOpts:c}),new Error(v.message)}const{p:m}=w,S=we(m.resources),T=[Te(m.iss)],_=Ae(m.iss);if(S){const v=xe(S),P=De(S);h.push(...v),T.push(...P)}for(const v of T)d.push(`${v}:${_}`)}const u=await this.client.core.crypto.generateSharedKey(o,r);let p;return h?.length>0&&(p={topic:u,acknowledged:!0,self:{publicKey:o,metadata:this.client.metadata},peer:{publicKey:r,metadata:s.requester.metadata},controller:r,expiry:N(M),authentication:i,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:"",namespaces:Ve([...new Set(h)],[...new Set(d)])},await this.client.core.relayer.subscribe(u),await this.client.session.set(u,p)),await this.sendResult({topic:a,id:e,result:{cacaos:i,responder:{publicKey:o,metadata:this.client.metadata}},encodeOpts:c,throwOnFailedPublish:!0}),await this.client.auth.requests.delete(e,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:s.pairingTopic}),{session:p}},this.rejectSessionAuthenticate=async t=>{await this.isInitialized();const{id:e,reason:i}=t,s=this.getPendingAuthRequest(e);if(!s)throw new Error(`Could not find pending auth request with id ${e}`);const r=s.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),a=ue(r),c={type:ye,receiverPublicKey:r,senderPublicKey:o};await this.sendError({id:e,topic:a,error:i,encodeOpts:c,rpcOpts:R.wc_sessionAuthenticate.reject}),await this.client.auth.requests.delete(e,{message:"rejected",code:0}),await this.client.proposal.delete(e,I("USER_DISCONNECTED"))},this.formatAuthMessage=t=>{this.isInitialized();const{request:e,iss:i}=t;return yt(e,i)},this.cleanupDuplicatePairings=async t=>{if(t.pairingTopic)try{const e=this.client.core.pairing.pairings.get(t.pairingTopic),i=this.client.core.pairing.pairings.getAll().filter(s=>{var r,o;return((r=s.peerMetadata)==null?void 0:r.url)&&((o=s.peerMetadata)==null?void 0:o.url)===t.peer.metadata.url&&s.topic&&s.topic!==e.topic});if(i.length===0)return;this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`),await Promise.all(i.map(s=>this.client.core.pairing.disconnect({topic:s.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async t=>{var e;const{topic:i,expirerHasDeleted:s=!1,emitEvent:r=!0,id:o=0}=t,{self:a}=this.client.session.get(i);await this.client.core.relayer.unsubscribe(i),await this.client.session.delete(i,I("USER_DISCONNECTED")),this.addToRecentlyDeleted(i,"session"),this.client.core.crypto.keychain.has(a.publicKey)&&await this.client.core.crypto.deleteKeyPair(a.publicKey),this.client.core.crypto.keychain.has(i)&&await this.client.core.crypto.deleteSymKey(i),s||this.client.core.expirer.del(i),this.client.core.storage.removeItem(fe).catch(c=>this.client.logger.warn(c)),this.getPendingSessionRequests().forEach(c=>{c.topic===i&&this.deletePendingSessionRequest(c.id,I("USER_DISCONNECTED"))}),i===((e=this.sessionRequestQueue.queue[0])==null?void 0:e.topic)&&(this.sessionRequestQueue.state=D.idle),r&&this.client.events.emit("session_delete",{id:o,topic:i})},this.deleteProposal=async(t,e)=>{await Promise.all([this.client.proposal.delete(t,I("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")},this.deletePendingSessionRequest=async(t,e,i=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,e),i?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(s=>s.id!==t),i&&(this.sessionRequestQueue.state=D.idle,this.client.events.emit("session_request_expire",{id:t}))},this.deletePendingAuthRequest=async(t,e,i=!1)=>{await Promise.all([this.client.auth.requests.delete(t,e),i?Promise.resolve():this.client.core.expirer.del(t)])},this.setExpiry=async(t,e)=>{this.client.session.keys.includes(t)&&(this.client.core.expirer.set(t,e),await this.client.session.update(t,{expiry:e}))},this.setProposal=async(t,e)=>{this.client.core.expirer.set(t,N(R.wc_sessionPropose.req.ttl)),await this.client.proposal.set(t,e)},this.setAuthRequest=async(t,e)=>{const{request:i,pairingTopic:s}=e;this.client.core.expirer.set(t,i.expiryTimestamp),await this.client.auth.requests.set(t,{authPayload:i.authPayload,requester:i.requester,expiryTimestamp:i.expiryTimestamp,id:t,pairingTopic:s,verifyContext:i.verifyContext})},this.setPendingSessionRequest=async t=>{const{id:e,topic:i,params:s,verifyContext:r}=t,o=s.request.expiryTimestamp||N(R.wc_sessionRequest.req.ttl);this.client.core.expirer.set(e,o),await this.client.pendingRequest.set(e,{id:e,topic:i,params:s,verifyContext:r})},this.sendRequest=async t=>{const{topic:e,method:i,params:s,expiry:r,relayRpcId:o,clientRpcId:a,throwOnFailedPublish:c}=t,h=Re(i,s,a);if(Rt()&&Qe.includes(i)){const p=te(JSON.stringify(h));this.client.core.verify.register({attestationId:p})}let d;try{d=await this.client.core.crypto.encode(e,h)}catch(p){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),p}const u=R[i].req;return r&&(u.ttl=r),o&&(u.id=o),this.client.core.history.set(e,h),c?(u.internal=L(y({},u.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,d,u)):this.client.core.relayer.publish(e,d,u).catch(p=>this.client.logger.error(p)),h.id},this.sendResult=async t=>{const{id:e,topic:i,result:s,throwOnFailedPublish:r,encodeOpts:o}=t,a=Mt(e,s);let c;try{c=await this.client.core.crypto.encode(i,a,o)}catch(u){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`),u}let h;try{h=await this.client.core.history.get(i,e)}catch(u){throw this.client.logger.error(`sendResult() -> history.get(${i}, ${e}) failed`),u}const d=R[h.request.method].res;r?(d.internal=L(y({},d.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,c,d)):this.client.core.relayer.publish(i,c,d).catch(u=>this.client.logger.error(u)),await this.client.core.history.resolve(a)},this.sendError=async t=>{const{id:e,topic:i,error:s,encodeOpts:r,rpcOpts:o}=t,a=Lt(e,s);let c;try{c=await this.client.core.crypto.encode(i,a,r)}catch(u){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`),u}let h;try{h=await this.client.core.history.get(i,e)}catch(u){throw this.client.logger.error(`sendError() -> history.get(${i}, ${e}) failed`),u}const d=o||R[h.request.method].res;this.client.core.relayer.publish(i,c,d),await this.client.core.history.resolve(a)},this.cleanup=async()=>{const t=[],e=[];this.client.session.getAll().forEach(i=>{let s=!1;k(i.expiry)&&(s=!0),this.client.core.crypto.keychain.has(i.topic)||(s=!0),s&&t.push(i.topic)}),this.client.proposal.getAll().forEach(i=>{k(i.expiryTimestamp)&&e.push(i.id)}),await Promise.all([...t.map(i=>this.deleteSession({topic:i})),...e.map(i=>this.deleteProposal(i))])},this.onRelayEventRequest=async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===D.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=D.active;const t=this.requestQueue.queue.shift();if(t)try{this.processRequest(t),await new Promise(e=>setTimeout(e,300))}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=D.idle},this.processRequest=t=>{const{topic:e,payload:i}=t,s=i.method;if(!this.shouldIgnorePairingRequest({topic:e,requestMethod:s}))switch(s){case"wc_sessionPropose":return this.onSessionProposeRequest(e,i);case"wc_sessionSettle":return this.onSessionSettleRequest(e,i);case"wc_sessionUpdate":return this.onSessionUpdateRequest(e,i);case"wc_sessionExtend":return this.onSessionExtendRequest(e,i);case"wc_sessionPing":return this.onSessionPingRequest(e,i);case"wc_sessionDelete":return this.onSessionDeleteRequest(e,i);case"wc_sessionRequest":return this.onSessionRequest(e,i);case"wc_sessionEvent":return this.onSessionEventRequest(e,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateRequest(e,i);default:return this.client.logger.info(`Unsupported request method ${s}`)}},this.onRelayEventResponse=async t=>{const{topic:e,payload:i}=t,s=(await this.client.core.history.get(e,i.id)).request.method;switch(s){case"wc_sessionPropose":return this.onSessionProposeResponse(e,i);case"wc_sessionSettle":return this.onSessionSettleResponse(e,i);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,i);case"wc_sessionExtend":return this.onSessionExtendResponse(e,i);case"wc_sessionPing":return this.onSessionPingResponse(e,i);case"wc_sessionRequest":return this.onSessionRequestResponse(e,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(e,i);default:return this.client.logger.info(`Unsupported response method ${s}`)}},this.onRelayEventUnknownPayload=t=>{const{topic:e}=t,{message:i}=l("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(i)},this.shouldIgnorePairingRequest=t=>{const{topic:e,requestMethod:i}=t,s=this.expectedPairingMethodMap.get(e);return!s||s.includes(i)?!1:!!(s.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async(t,e)=>{const{params:i,id:s}=e;try{this.isValidConnect(y({},e.params));const r=i.expiryTimestamp||N(R.wc_sessionPropose.req.ttl),o=y({id:s,pairingTopic:t,expiryTimestamp:r},i);await this.setProposal(s,o);const a=te(JSON.stringify(e)),c=await this.getVerifyContext(a,o.proposer.metadata);this.client.events.emit("session_proposal",{id:s,params:o,verifyContext:c})}catch(r){await this.sendError({id:s,topic:t,error:r,rpcOpts:R.wc_sessionPropose.autoReject}),this.client.logger.error(r)}},this.onSessionProposeResponse=async(t,e)=>{const{id:i}=e;if(b(e)){const{result:s}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:s});const r=this.client.proposal.get(i);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:r});const o=r.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:o});const a=s.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:a});const c=await this.client.core.crypto.generateSharedKey(o,a);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:c});const h=await this.client.core.relayer.subscribe(c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:t})}else if($(e)){await this.client.proposal.delete(i,I("USER_DISCONNECTED"));const s=g("session_connect");if(this.events.listenerCount(s)===0)throw new Error(`emitting ${s} without any listeners, 954`);this.events.emit(g("session_connect"),{error:e.error})}},this.onSessionSettleRequest=async(t,e)=>{const{id:i,params:s}=e;try{this.isValidSessionSettleRequest(s);const{relay:r,controller:o,expiry:a,namespaces:c,sessionProperties:h,sessionConfig:d}=e.params,u=y(y({topic:t,relay:r,expiry:a,namespaces:c,acknowledged:!0,pairingTopic:"",requiredNamespaces:{},optionalNamespaces:{},controller:o.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},h&&{sessionProperties:h}),d&&{sessionConfig:d});await this.sendResult({id:e.id,topic:t,result:!0,throwOnFailedPublish:!0});const p=g("session_connect");if(this.events.listenerCount(p)===0)throw new Error(`emitting ${p} without any listeners 997`);this.events.emit(g("session_connect"),{session:u})}catch(r){await this.sendError({id:i,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionSettleResponse=async(t,e)=>{const{id:i}=e;b(e)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(g("session_approve",i),{})):$(e)&&(await this.client.session.delete(t,I("USER_DISCONNECTED")),this.events.emit(g("session_approve",i),{error:e.error}))},this.onSessionUpdateRequest=async(t,e)=>{const{params:i,id:s}=e;try{const r=`${t}_session_update`,o=Y.get(r);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`),this.sendError({id:s,topic:t,error:I("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(y({topic:t},i));try{Y.set(r,s),await this.client.session.update(t,{namespaces:i.namespaces}),await this.sendResult({id:s,topic:t,result:!0,throwOnFailedPublish:!0})}catch(a){throw Y.delete(r),a}this.client.events.emit("session_update",{id:s,topic:t,params:i})}catch(r){await this.sendError({id:s,topic:t,error:r}),this.client.logger.error(r)}},this.isRequestOutOfSync=(t,e)=>parseInt(e.toString().slice(0,-3))<=parseInt(t.toString().slice(0,-3)),this.onSessionUpdateResponse=(t,e)=>{const{id:i}=e,s=g("session_update",i);if(this.events.listenerCount(s)===0)throw new Error(`emitting ${s} without any listeners`);b(e)?this.events.emit(g("session_update",i),{}):$(e)&&this.events.emit(g("session_update",i),{error:e.error})},this.onSessionExtendRequest=async(t,e)=>{const{id:i}=e;try{this.isValidExtend({topic:t}),await this.setExpiry(t,N(M)),await this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:i,topic:t})}catch(s){await this.sendError({id:i,topic:t,error:s}),this.client.logger.error(s)}},this.onSessionExtendResponse=(t,e)=>{const{id:i}=e,s=g("session_extend",i);if(this.events.listenerCount(s)===0)throw new Error(`emitting ${s} without any listeners`);b(e)?this.events.emit(g("session_extend",i),{}):$(e)&&this.events.emit(g("session_extend",i),{error:e.error})},this.onSessionPingRequest=async(t,e)=>{const{id:i}=e;try{this.isValidPing({topic:t}),await this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:i,topic:t})}catch(s){await this.sendError({id:i,topic:t,error:s}),this.client.logger.error(s)}},this.onSessionPingResponse=(t,e)=>{const{id:i}=e,s=g("session_ping",i);if(this.events.listenerCount(s)===0)throw new Error(`emitting ${s} without any listeners`);setTimeout(()=>{b(e)?this.events.emit(g("session_ping",i),{}):$(e)&&this.events.emit(g("session_ping",i),{error:e.error})},500)},this.onSessionDeleteRequest=async(t,e)=>{const{id:i}=e;try{this.isValidDisconnect({topic:t,reason:e.params}),await Promise.all([new Promise(s=>{this.client.core.relayer.once(ve.publish,async()=>{s(await this.deleteSession({topic:t,id:i}))})}),this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:I("USER_DISCONNECTED")})])}catch(s){this.client.logger.error(s)}},this.onSessionRequest=async(t,e)=>{var i;const{id:s,params:r}=e;try{await this.isValidRequest(y({topic:t},r));const o=te(JSON.stringify(Re("wc_sessionRequest",r,s))),a=this.client.session.get(t),c=await this.getVerifyContext(o,a.peer.metadata),h={id:s,topic:t,params:r,verifyContext:c};await this.setPendingSessionRequest(h),(i=this.client.signConfig)!=null&&i.disableRequestQueue?this.emitSessionRequest(h):(this.addSessionRequestToSessionRequestQueue(h),this.processSessionRequestQueue())}catch(o){await this.sendError({id:s,topic:t,error:o}),this.client.logger.error(o)}},this.onSessionRequestResponse=(t,e)=>{const{id:i}=e,s=g("session_request",i);if(this.events.listenerCount(s)===0)throw new Error(`emitting ${s} without any listeners`);b(e)?this.events.emit(g("session_request",i),{result:e.result}):$(e)&&this.events.emit(g("session_request",i),{error:e.error})},this.onSessionEventRequest=async(t,e)=>{const{id:i,params:s}=e;try{const r=`${t}_session_event_${s.event.name}`,o=Y.get(r);if(o&&this.isRequestOutOfSync(o,i)){this.client.logger.info(`Discarding out of sync request - ${i}`);return}this.isValidEmit(y({topic:t},s)),this.client.events.emit("session_event",{id:i,topic:t,params:s}),Y.set(r,i)}catch(r){await this.sendError({id:i,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionAuthenticateResponse=(t,e)=>{const{id:i}=e;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:e}),b(e)?this.events.emit(g("session_request",i),{result:e.result}):$(e)&&this.events.emit(g("session_request",i),{error:e.error})},this.onSessionAuthenticateRequest=async(t,e)=>{try{const{requester:i,authPayload:s,expiryTimestamp:r}=e.params,o=te(JSON.stringify(e)),a=await this.getVerifyContext(o,this.client.metadata),c={requester:i,pairingTopic:t,id:e.id,authPayload:s,verifyContext:a,expiryTimestamp:r};await this.setAuthRequest(e.id,{request:c,pairingTopic:t}),this.client.events.emit("session_authenticate",{topic:t,params:e.params,id:e.id})}catch(i){this.client.logger.error(i);const s=e.params.requester.publicKey,r=await this.client.core.crypto.generateKeyPair(),o={type:ye,receiverPublicKey:s,senderPublicKey:r};await this.sendError({id:e.id,topic:t,error:i,encodeOpts:o,rpcOpts:R.wc_sessionAuthenticate.autoReject})}},this.addSessionRequestToSessionRequestQueue=t=>{this.sessionRequestQueue.queue.push(t)},this.cleanupAfterResponse=t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=D.idle,this.processSessionRequestQueue()},Ke(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:t,error:e})=>{const i=this.client.core.history.pending;i.length>0&&i.filter(s=>s.topic===t&&s.request.method==="wc_sessionRequest").forEach(s=>{const r=s.request.id,o=g("session_request",r);if(this.events.listenerCount(o)===0)throw new Error(`emitting ${o} without any listeners`);this.events.emit(g("session_request",s.request.id),{error:e})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===D.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=D.active,this.emitSessionRequest(t)}catch(e){this.client.logger.error(e)}},this.emitSessionRequest=t=>{this.client.events.emit("session_request",t)},this.onPairingCreated=t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const e=this.client.proposal.getAll().find(i=>i.pairingTopic===t.topic);e&&this.onSessionProposeRequest(t.topic,Re("wc_sessionPropose",{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties},e.id))},this.isValidConnect=async t=>{if(!x(t)){const{message:a}=l("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(a)}const{pairingTopic:e,requiredNamespaces:i,optionalNamespaces:s,sessionProperties:r,relays:o}=t;if(X(e)||await this.isValidPairingTopic(e),!Et(o,!0)){const{message:a}=l("MISSING_OR_INVALID",`connect() relays: ${o}`);throw new Error(a)}!X(i)&&Ce(i)!==0&&this.validateNamespaces(i,"requiredNamespaces"),!X(s)&&Ce(s)!==0&&this.validateNamespaces(s,"optionalNamespaces"),X(r)||this.validateSessionProps(r,"sessionProperties")},this.validateNamespaces=(t,e)=>{const i=St(t,"connect()",e);if(i)throw new Error(i.message)},this.isValidApprove=async t=>{if(!x(t))throw new Error(l("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:e,namespaces:i,relayProtocol:s,sessionProperties:r}=t;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const o=this.client.proposal.get(e),a=me(i,"approve()");if(a)throw new Error(a.message);const c=be(o.requiredNamespaces,i,"approve()");if(c)throw new Error(c.message);if(!V(s,!0)){const{message:h}=l("MISSING_OR_INVALID",`approve() relayProtocol: ${s}`);throw new Error(h)}X(r)||this.validateSessionProps(r,"sessionProperties")},this.isValidReject=async t=>{if(!x(t)){const{message:s}=l("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(s)}const{id:e,reason:i}=t;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!_t(i)){const{message:s}=l("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(i)}`);throw new Error(s)}},this.isValidSessionSettleRequest=t=>{if(!x(t)){const{message:c}=l("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(c)}const{relay:e,controller:i,namespaces:s,expiry:r}=t;if(!ft(e)){const{message:c}=l("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(c)}const o=It(i,"onSessionSettleRequest()");if(o)throw new Error(o.message);const a=me(s,"onSessionSettleRequest()");if(a)throw new Error(a.message);if(k(r)){const{message:c}=l("EXPIRED","onSessionSettleRequest()");throw new Error(c)}},this.isValidUpdate=async t=>{if(!x(t)){const{message:a}=l("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(a)}const{topic:e,namespaces:i}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const s=this.client.session.get(e),r=me(i,"update()");if(r)throw new Error(r.message);const o=be(s.requiredNamespaces,i,"update()");if(o)throw new Error(o.message)},this.isValidExtend=async t=>{if(!x(t)){const{message:i}=l("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(i)}const{topic:e}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)},this.isValidRequest=async t=>{if(!x(t)){const{message:a}=l("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(a)}const{topic:e,request:i,chainId:s,expiry:r}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:o}=this.client.session.get(e);if(!$e(o,s)){const{message:a}=l("MISSING_OR_INVALID",`request() chainId: ${s}`);throw new Error(a)}if(!qt(i)){const{message:a}=l("MISSING_OR_INVALID",`request() ${JSON.stringify(i)}`);throw new Error(a)}if(!Nt(o,s,i.method)){const{message:a}=l("MISSING_OR_INVALID",`request() method: ${i.method}`);throw new Error(a)}if(r&&!vt(r,ne)){const{message:a}=l("MISSING_OR_INVALID",`request() expiry: ${r}. Expiry must be a number (in seconds) between ${ne.min} and ${ne.max}`);throw new Error(a)}},this.isValidRespond=async t=>{var e;if(!x(t)){const{message:r}=l("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(r)}const{topic:i,response:s}=t;try{await this.isValidSessionTopic(i)}catch(r){throw(e=t?.response)!=null&&e.id&&this.cleanupAfterResponse(t),r}if(!Pt(s)){const{message:r}=l("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(s)}`);throw new Error(r)}},this.isValidPing=async t=>{if(!x(t)){const{message:i}=l("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(i)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidEmit=async t=>{if(!x(t)){const{message:o}=l("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(o)}const{topic:e,event:i,chainId:s}=t;await this.isValidSessionTopic(e);const{namespaces:r}=this.client.session.get(e);if(!$e(r,s)){const{message:o}=l("MISSING_OR_INVALID",`emit() chainId: ${s}`);throw new Error(o)}if(!Ot(i)){const{message:o}=l("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(o)}if(!Tt(r,s,i.name)){const{message:o}=l("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(o)}},this.isValidDisconnect=async t=>{if(!x(t)){const{message:i}=l("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(i)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidAuthenticate=t=>{const{chains:e,uri:i,domain:s,nonce:r}=t;if(!Array.isArray(e)||e.length===0)throw new Error("chains is required and must be a non-empty array");if(!V(i,!1))throw new Error("uri is required parameter");if(!V(s,!1))throw new Error("domain is required parameter");if(!V(r,!1))throw new Error("nonce is required parameter");if([...new Set(e.map(a=>ge(a).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=ge(e[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async(t,e)=>{const i={verified:{verifyUrl:e.verifyUrl||st,validation:"UNKNOWN",origin:e.url||""}};try{const s=await this.client.core.verify.resolve({attestationId:t,verifyUrl:e.verifyUrl});s&&(i.verified.origin=s.origin,i.verified.isScam=s.isScam,i.verified.validation=s.origin===new URL(e.url).origin?"VALID":"INVALID")}catch(s){this.client.logger.info(s)}return this.client.logger.info(`Verify context: ${JSON.stringify(i)}`),i},this.validateSessionProps=(t,e)=>{Object.values(t).forEach(i=>{if(!V(i,!1)){const{message:s}=l("MISSING_OR_INVALID",`${e} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);throw new Error(s)}})},this.getPendingAuthRequest=t=>{const e=this.client.auth.requests.get(t);return typeof e=="object"?e:void 0},this.addToRecentlyDeleted=(t,e)=>{if(this.recentlyDeletedMap.set(t,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let i=0;const s=this.recentlyDeletedLimit/2;for(const r of this.recentlyDeletedMap.keys()){if(i++>=s)break;this.recentlyDeletedMap.delete(r)}}},this.checkRecentlyDeleted=t=>{const e=this.recentlyDeletedMap.get(t);if(e){const{message:i}=l("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${t}`);throw new Error(i)}}}async isInitialized(){if(!this.initialized){const{message:n}=l("NOT_INITIALIZED",this.name);throw new Error(n)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(ve.message,async n=>{const{topic:t,message:e}=n,{publicKey:i}=this.client.auth.authKeys.keys.includes(B)?this.client.auth.authKeys.get(B):{responseTopic:void 0,publicKey:void 0},s=await this.client.core.crypto.decode(t,e,{receiverPublicKey:i});try{Kt(s)?(this.client.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):Ut(s)?(await this.client.core.history.resolve(s),await this.onRelayEventResponse({topic:t,payload:s}),this.client.core.history.delete(t,s.id)):this.onRelayEventUnknownPayload({topic:t,payload:s})}catch(r){this.client.logger.error(r)}})}registerExpirerEvents(){this.client.core.expirer.on(rt.expired,async n=>{const{topic:t,id:e}=At(n.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,l("EXPIRED"),!0);if(e&&this.client.auth.requests.keys.includes(e))return await this.deletePendingAuthRequest(e,l("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))})}registerPairingEvents(){this.client.core.pairing.events.on(Pe.create,n=>this.onPairingCreated(n)),this.client.core.pairing.events.on(Pe.delete,n=>{this.addToRecentlyDeleted(n.topic,"pairing")})}isValidPairingTopic(n){if(!V(n,!1)){const{message:t}=l("MISSING_OR_INVALID",`pairing topic should be a string: ${n}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(n)){const{message:t}=l("NO_MATCHING_KEY",`pairing topic doesn't exist: ${n}`);throw new Error(t)}if(k(this.client.core.pairing.pairings.get(n).expiry)){const{message:t}=l("EXPIRED",`pairing topic: ${n}`);throw new Error(t)}}async isValidSessionTopic(n){if(!V(n,!1)){const{message:t}=l("MISSING_OR_INVALID",`session topic should be a string: ${n}`);throw new Error(t)}if(this.checkRecentlyDeleted(n),!this.client.session.keys.includes(n)){const{message:t}=l("NO_MATCHING_KEY",`session topic doesn't exist: ${n}`);throw new Error(t)}if(k(this.client.session.get(n).expiry)){await this.deleteSession({topic:n});const{message:t}=l("EXPIRED",`session topic: ${n}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(n)){const{message:t}=l("MISSING_OR_INVALID",`session topic does not exist in keychain: ${n}`);throw await this.deleteSession({topic:n}),new Error(t)}}async isValidSessionOrPairingTopic(n){if(this.checkRecentlyDeleted(n),this.client.session.keys.includes(n))await this.isValidSessionTopic(n);else if(this.client.core.pairing.pairings.keys.includes(n))this.isValidPairingTopic(n);else if(V(n,!1)){const{message:t}=l("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${n}`);throw new Error(t)}else{const{message:t}=l("MISSING_OR_INVALID",`session or pairing topic should be a string: ${n}`);throw new Error(t)}}async isValidProposalId(n){if(!xt(n)){const{message:t}=l("MISSING_OR_INVALID",`proposal id should be a number: ${n}`);throw new Error(t)}if(!this.client.proposal.keys.includes(n)){const{message:t}=l("NO_MATCHING_KEY",`proposal id doesn't exist: ${n}`);throw new Error(t)}if(k(this.client.proposal.get(n).expiryTimestamp)){await this.deleteProposal(n);const{message:t}=l("EXPIRED",`proposal id: ${n}`);throw new Error(t)}}}class ei extends U{constructor(n,t){super(n,t,Ue,se),this.core=n,this.logger=t}}class Ze extends U{constructor(n,t){super(n,t,ke,se),this.core=n,this.logger=t}}class ti extends U{constructor(n,t){super(n,t,Fe,se,e=>e.id),this.core=n,this.logger=t}}class ii extends U{constructor(n,t){super(n,t,Ye,J,()=>B),this.core=n,this.logger=t}}class si extends U{constructor(n,t){super(n,t,Xe,J),this.core=n,this.logger=t}}class ri extends U{constructor(n,t){super(n,t,Je,J,e=>e.id),this.core=n,this.logger=t}}class ni{constructor(n,t){this.core=n,this.logger=t,this.authKeys=new ii(this.core,this.logger),this.pairingTopics=new si(this.core,this.logger),this.requests=new ri(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class oe extends pt{constructor(n){super(n),this.protocol=Ee,this.version=Se,this.name=re.name,this.events=new Ct,this.on=(e,i)=>this.events.on(e,i),this.once=(e,i)=>this.events.once(e,i),this.off=(e,i)=>this.events.off(e,i),this.removeListener=(e,i)=>this.events.removeListener(e,i),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(i){throw this.logger.error(i.message),i}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(i){throw this.logger.error(i.message),i}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(i){throw this.logger.error(i.message),i}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(i){throw this.logger.error(i.message),i}},this.update=async e=>{try{return await this.engine.update(e)}catch(i){throw this.logger.error(i.message),i}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(i){throw this.logger.error(i.message),i}},this.request=async e=>{try{return await this.engine.request(e)}catch(i){throw this.logger.error(i.message),i}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(i){throw this.logger.error(i.message),i}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(i){throw this.logger.error(i.message),i}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(i){throw this.logger.error(i.message),i}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(i){throw this.logger.error(i.message),i}},this.find=e=>{try{return this.engine.find(e)}catch(i){throw this.logger.error(i.message),i}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.authenticate=async e=>{try{return await this.engine.authenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.formatAuthMessage=e=>{try{return this.engine.formatAuthMessage(e)}catch(i){throw this.logger.error(i.message),i}},this.approveSessionAuthenticate=async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.rejectSessionAuthenticate=async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.name=n?.name||re.name,this.metadata=n?.metadata||Dt(),this.signConfig=n?.signConfig;const t=typeof n?.logger<"u"&&typeof n?.logger!="string"?n.logger:ot(at({level:n?.logger||re.logger}));this.core=n?.core||new nt(n),this.logger=ct(t,this.name),this.session=new Ze(this.core,this.logger),this.proposal=new ei(this.core,this.logger),this.pendingRequest=new ti(this.core,this.logger),this.engine=new Zt(this),this.auth=new ni(this.core,this.logger)}static async init(n){const t=new oe(n);return await t.initialize(),t}get context(){return lt(this.logger)}get pairing(){return this.core.pairing.pairings}validateMetadata(n){if(!n.name)throw new Error("name is required value in metadata");if(!n.description)throw new Error("description is required value in metadata");if(!n.url)throw new Error("url is required value in metadata")}async initialize(){this.logger.trace("Initialized");try{await this.validateMetadata(this.metadata),await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),await this.auth.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(n){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(n.message),n}}}const oi=Ze,ai=oe;export{He as AUTH_CONTEXT,Ye as AUTH_KEYS_CONTEXT,Xe as AUTH_PAIRING_TOPIC_CONTEXT,ze as AUTH_PROTOCOL,B as AUTH_PUBLIC_KEY_NAME,Je as AUTH_REQUEST_CONTEXT,J as AUTH_STORAGE_PREFIX,Ht as AUTH_VERSION,je as ENGINE_CONTEXT,D as ENGINE_QUEUE_STATES,R as ENGINE_RPC_OPTS,Ft as HISTORY_CONTEXT,jt as HISTORY_EVENTS,Qt as HISTORY_STORAGE_VERSION,Qe as METHODS_TO_VERIFY,Ue as PROPOSAL_CONTEXT,zt as PROPOSAL_EXPIRY,Ge as PROPOSAL_EXPIRY_MESSAGE,Fe as REQUEST_CONTEXT,ke as SESSION_CONTEXT,M as SESSION_EXPIRY,ne as SESSION_REQUEST_EXPIRY_BOUNDARIES,_e as SIGN_CLIENT_CONTEXT,re as SIGN_CLIENT_DEFAULT,Gt as SIGN_CLIENT_EVENTS,Ee as SIGN_CLIENT_PROTOCOL,kt as SIGN_CLIENT_STORAGE_OPTIONS,se as SIGN_CLIENT_STORAGE_PREFIX,Se as SIGN_CLIENT_VERSION,oi as SessionStore,ai as SignClient,fe as WALLETCONNECT_DEEPLINK_CHOICE,oe as default};
//# sourceMappingURL=index.es.js.map
