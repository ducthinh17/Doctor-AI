"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteActiveAccount = exports.authEndpoint = exports.customJwt = exports.socialLogin = exports.validateEmailOTP = exports.sendVerificationSms = exports.sendVerificationEmail = void 0;
const aws_amplify_1 = require("aws-amplify");
const WebBrowser = require("expo-web-browser");
const type_js_1 = require("../core/authentication/type.js");
const fetchers_js_1 = require("./helpers/api/fetchers.js");
const cognitoAuth_js_1 = require("./helpers/auth/cognitoAuth.js");
const middleware_js_1 = require("./helpers/auth/middleware.js");
const constants_js_1 = require("./helpers/constants.js");
const errors_js_1 = require("./helpers/errors.js");
const local_js_1 = require("./helpers/storage/local.js");
const state_js_1 = require("./helpers/storage/state.js");
async function sendVerificationEmail(options) {
    await (0, fetchers_js_1.verifyClientId)(options.client);
    await (0, middleware_js_1.preAuth)({
        authenticationMethod: type_js_1.AuthProvider.COGNITO,
        email: options.email,
    });
    let result;
    try {
        result = await (0, fetchers_js_1.fetchUserDetails)({
            email: options.email,
            client: options.client,
        });
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from the send email OTP API", e));
    }
    let cognitoUser;
    try {
        cognitoUser = await (0, cognitoAuth_js_1.cognitoEmailSignIn)(options.email, options.client.clientId);
    }
    catch (e) {
        await (0, cognitoAuth_js_1.cognitoEmailSignUp)(options.email, options.client.clientId);
        cognitoUser = await (0, cognitoAuth_js_1.cognitoEmailSignIn)(options.email, options.client.clientId);
    }
    (0, state_js_1.setCognitoUser)(cognitoUser);
    return {
        isNewUser: false, // TODO (rn) check this assumption is ok
        isNewDevice: !(await (0, local_js_1.isDeviceSharePresentForUser)(options.client.clientId, result.walletUserId ?? "")),
        recoveryShareManagement: type_js_1.RecoveryShareManagement.CLOUD_MANAGED,
    };
}
exports.sendVerificationEmail = sendVerificationEmail;
async function sendVerificationSms(options) {
    await (0, fetchers_js_1.verifyClientId)(options.client);
    await (0, middleware_js_1.preAuth)({
        authenticationMethod: type_js_1.AuthProvider.COGNITO,
        phone: options.phoneNumber,
    });
    let result;
    try {
        result = await (0, fetchers_js_1.fetchUserDetails)({
            email: options.phoneNumber, // TODO should cleanup the API here
            client: options.client,
        });
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from the send email OTP API", e));
    }
    let cognitoUser;
    try {
        cognitoUser = await (0, cognitoAuth_js_1.cognitoPhoneSignIn)(options.phoneNumber, options.client.clientId);
    }
    catch (e) {
        await (0, cognitoAuth_js_1.cognitoPhoneSignUp)(options.phoneNumber, options.client.clientId);
        cognitoUser = await (0, cognitoAuth_js_1.cognitoPhoneSignIn)(options.phoneNumber, options.client.clientId);
    }
    (0, state_js_1.setCognitoUser)(cognitoUser);
    return {
        isNewUser: false, // TODO (rn) check this assumption is ok
        isNewDevice: !(await (0, local_js_1.isDeviceSharePresentForUser)(options.client.clientId, result.walletUserId ?? "")),
        recoveryShareManagement: type_js_1.RecoveryShareManagement.CLOUD_MANAGED,
    };
}
exports.sendVerificationSms = sendVerificationSms;
async function validateEmailOTP(options) {
    try {
        await (0, fetchers_js_1.fetchUserDetails)({
            email: options.email,
            client: options.client,
        });
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response validating the OTP", e));
    }
    let verifiedTokenResponse;
    try {
        let cognitoUser = (0, state_js_1.getCognitoUser)();
        if (!cognitoUser) {
            throw new Error("MISSING COGNITO USER");
        }
        cognitoUser = await aws_amplify_1.Auth.sendCustomChallengeAnswer(cognitoUser, options.otp);
        // It we get here, the answer was sent successfully,
        // but it might have been wrong (1st or 2nd time)
        // So we should test if the user is authenticated now
        const session = await aws_amplify_1.Auth.currentSession();
        verifiedTokenResponse = await (0, fetchers_js_1.generateAuthTokenFromCognitoEmailOtp)(session, options.client.clientId);
    }
    catch (e) {
        throw new Error(`Invalid OTP ${e}`);
    }
    try {
        const storedToken = {
            jwtToken: verifiedTokenResponse.verifiedToken.jwtToken,
            authDetails: verifiedTokenResponse.verifiedToken.authDetails,
            authProvider: verifiedTokenResponse.verifiedToken.authProvider,
            developerClientId: verifiedTokenResponse.verifiedToken.developerClientId,
            cookieString: verifiedTokenResponse.verifiedTokenJwtString,
            // we should always store the jwt cookie since there's no concept of cookie in react native
            shouldStoreCookieString: true,
            isNewUser: verifiedTokenResponse.verifiedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuth)({
            storedToken,
            client: options.client,
            recoveryCode: options.recoveryCode,
        });
        return { storedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from the verify one time password", e));
    }
}
exports.validateEmailOTP = validateEmailOTP;
async function socialLogin(oauthOptions, client) {
    const encodedProvider = encodeURIComponent(oauthOptions.provider);
    const headlessLoginLinkWithParams = `${constants_js_1.ROUTE_HEADLESS_OAUTH_LOGIN}?authProvider=${encodedProvider}&baseUrl=${encodeURIComponent(constants_js_1.DOMAIN_URL_2023)}&platform=${encodeURIComponent("mobile")}`;
    const resp = await fetch(headlessLoginLinkWithParams, {
        headers: {
            ...(0, fetchers_js_1.getSessionHeaders)(),
        },
    });
    if (!resp.ok) {
        const error = await resp.json();
        throw new Error(`Error getting headless sign in link: ${error.message}`);
    }
    const json = await resp.json();
    const { platformLoginLink } = json;
    const completeLoginUrl = `${platformLoginLink}?developerClientId=${encodeURIComponent(client.clientId)}&platform=${encodeURIComponent("mobile")}&redirectUrl=${encodeURIComponent(oauthOptions.redirectUrl)}&authOption=${encodedProvider}`;
    // TODO platform specific code should be extracted out
    const result = await WebBrowser.openAuthSessionAsync(completeLoginUrl, oauthOptions.redirectUrl, {
        preferEphemeralSession: false,
        showTitle: false,
        enableDefaultShareMenuItem: false,
        enableBarCollapsing: false,
    });
    if (result.type === "cancel") {
        throw new Error("Sign in cancelled");
    }
    if (result.type !== "success") {
        throw new Error(`Can't sign in with ${oauthOptions.provider}: ${result}`);
    }
    const decodedUrl = decodeURIComponent(result.url);
    const parts = decodedUrl.split("?authResult=");
    if (parts.length < 2) {
        // assume error
        const error = decodedUrl.split("?error=")?.[1];
        throw new Error(`Something went wrong: ${error}`);
    }
    const authResult = parts[1];
    if (!authResult) {
        throw new Error("No auth result found");
    }
    const { storedToken } = JSON.parse(authResult);
    try {
        const toStoreToken = {
            jwtToken: storedToken.jwtToken,
            authDetails: storedToken.authDetails,
            authProvider: storedToken.authProvider,
            developerClientId: storedToken.developerClientId,
            cookieString: storedToken.cookieString,
            // we should always store the jwt cookie since there's no concept of cookie in react native
            shouldStoreCookieString: true,
            isNewUser: storedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuth)({ storedToken: toStoreToken, client });
        return { storedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post authentication", e));
    }
}
exports.socialLogin = socialLogin;
async function customJwt(authOptions, client) {
    const { jwt, password } = authOptions;
    const resp = await fetch(constants_js_1.ROUTE_AUTH_JWT_CALLBACK, {
        method: "POST",
        headers: {
            ...(0, fetchers_js_1.getSessionHeaders)(),
        },
        body: JSON.stringify({
            jwt: jwt,
            developerClientId: client.clientId,
        }),
    });
    if (!resp.ok) {
        const error = await resp.json();
        throw new Error(`JWT authentication error: ${error.message}`);
    }
    try {
        const { verifiedToken, verifiedTokenJwtString } = await resp.json();
        const toStoreToken = {
            jwtToken: verifiedToken.jwtToken,
            authProvider: verifiedToken.authProvider,
            authDetails: {
                ...verifiedToken.authDetails,
                email: verifiedToken.authDetails.email,
            },
            developerClientId: verifiedToken.developerClientId,
            cookieString: verifiedTokenJwtString,
            shouldStoreCookieString: true,
            isNewUser: verifiedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuthUserManaged)(toStoreToken, client, password);
        return { storedToken: verifiedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post jwt authentication", e));
    }
}
exports.customJwt = customJwt;
async function authEndpoint(authOptions, client) {
    const { payload, encryptionKey } = authOptions;
    const resp = await fetch(constants_js_1.ROUTE_AUTH_ENDPOINT_CALLBACK, {
        method: "POST",
        headers: {
            ...(0, fetchers_js_1.getSessionHeaders)(),
        },
        body: JSON.stringify({
            payload: payload,
            developerClientId: client.clientId,
        }),
    });
    if (!resp.ok) {
        const error = await resp.json();
        throw new Error(`Custom auth endpoint authentication error: ${error.message}`);
    }
    try {
        const { verifiedToken, verifiedTokenJwtString } = await resp.json();
        const toStoreToken = {
            jwtToken: verifiedToken.jwtToken,
            authProvider: verifiedToken.authProvider,
            authDetails: {
                ...verifiedToken.authDetails,
                email: verifiedToken.authDetails.email,
            },
            developerClientId: verifiedToken.developerClientId,
            cookieString: verifiedTokenJwtString,
            shouldStoreCookieString: true,
            isNewUser: verifiedToken.isNewUser,
        };
        await (0, middleware_js_1.postAuthUserManaged)(toStoreToken, client, encryptionKey);
        return { storedToken: verifiedToken };
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Malformed response from post auth_endpoint authentication", e));
    }
}
exports.authEndpoint = authEndpoint;
async function deleteActiveAccount(options) {
    await (0, fetchers_js_1.verifyClientId)(options.client);
    try {
        return (0, fetchers_js_1.deleteAccount)(options.client);
    }
    catch (e) {
        throw new Error((0, errors_js_1.createErrorMessage)("Error deleting the active account", e));
    }
}
exports.deleteActiveAccount = deleteActiveAccount;
//# sourceMappingURL=auth.js.map